
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Criterio
 * 
 */
export type Criterio = $Result.DefaultSelection<Prisma.$CriterioPayload>
/**
 * Model Endpoint
 * 
 */
export type Endpoint = $Result.DefaultSelection<Prisma.$EndpointPayload>
/**
 * Model Equipo
 * 
 */
export type Equipo = $Result.DefaultSelection<Prisma.$EquipoPayload>
/**
 * Model Estudiante
 * 
 */
export type Estudiante = $Result.DefaultSelection<Prisma.$EstudiantePayload>
/**
 * Model EstudianteNRC
 * 
 */
export type EstudianteNRC = $Result.DefaultSelection<Prisma.$EstudianteNRCPayload>
/**
 * Model Evaluacion
 * 
 */
export type Evaluacion = $Result.DefaultSelection<Prisma.$EvaluacionPayload>
/**
 * Model Jurado
 * 
 */
export type Jurado = $Result.DefaultSelection<Prisma.$JuradoPayload>
/**
 * Model Materia
 * 
 */
export type Materia = $Result.DefaultSelection<Prisma.$MateriaPayload>
/**
 * Model NRC
 * 
 */
export type NRC = $Result.DefaultSelection<Prisma.$NRCPayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model RolEndpoint
 * 
 */
export type RolEndpoint = $Result.DefaultSelection<Prisma.$RolEndpointPayload>
/**
 * Model RolUsuario
 * 
 */
export type RolUsuario = $Result.DefaultSelection<Prisma.$RolUsuarioPayload>
/**
 * Model Rubrica
 * 
 */
export type Rubrica = $Result.DefaultSelection<Prisma.$RubricaPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Videojuego
 * 
 */
export type Videojuego = $Result.DefaultSelection<Prisma.$VideojuegoPayload>
/**
 * Model VideojuegoAsignado
 * 
 */
export type VideojuegoAsignado = $Result.DefaultSelection<Prisma.$VideojuegoAsignadoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Estado: {
  Pendiente_confirmacion: 'Pendiente_confirmacion',
  Inscrito_confirmado: 'Inscrito_confirmado',
  Inscripcion_completa: 'Inscripcion_completa',
  Rechazada: 'Rechazada'
};

export type Estado = (typeof Estado)[keyof typeof Estado]


export const EstadoJurado: {
  confirmado: 'confirmado',
  no_confirmado: 'no_confirmado'
};

export type EstadoJurado = (typeof EstadoJurado)[keyof typeof EstadoJurado]


export const Tipo: {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH'
};

export type Tipo = (typeof Tipo)[keyof typeof Tipo]

}

export type Estado = $Enums.Estado

export const Estado: typeof $Enums.Estado

export type EstadoJurado = $Enums.EstadoJurado

export const EstadoJurado: typeof $Enums.EstadoJurado

export type Tipo = $Enums.Tipo

export const Tipo: typeof $Enums.Tipo

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Criterios
 * const criterios = await prisma.criterio.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Criterios
   * const criterios = await prisma.criterio.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.criterio`: Exposes CRUD operations for the **Criterio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Criterios
    * const criterios = await prisma.criterio.findMany()
    * ```
    */
  get criterio(): Prisma.CriterioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endpoint`: Exposes CRUD operations for the **Endpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Endpoints
    * const endpoints = await prisma.endpoint.findMany()
    * ```
    */
  get endpoint(): Prisma.EndpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipo`: Exposes CRUD operations for the **Equipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipos
    * const equipos = await prisma.equipo.findMany()
    * ```
    */
  get equipo(): Prisma.EquipoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estudiante`: Exposes CRUD operations for the **Estudiante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiante.findMany()
    * ```
    */
  get estudiante(): Prisma.EstudianteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estudianteNRC`: Exposes CRUD operations for the **EstudianteNRC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstudianteNRCS
    * const estudianteNRCS = await prisma.estudianteNRC.findMany()
    * ```
    */
  get estudianteNRC(): Prisma.EstudianteNRCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluacion`: Exposes CRUD operations for the **Evaluacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluacions
    * const evaluacions = await prisma.evaluacion.findMany()
    * ```
    */
  get evaluacion(): Prisma.EvaluacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jurado`: Exposes CRUD operations for the **Jurado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jurados
    * const jurados = await prisma.jurado.findMany()
    * ```
    */
  get jurado(): Prisma.JuradoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materia`: Exposes CRUD operations for the **Materia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materias
    * const materias = await prisma.materia.findMany()
    * ```
    */
  get materia(): Prisma.MateriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nRC`: Exposes CRUD operations for the **NRC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NRCS
    * const nRCS = await prisma.nRC.findMany()
    * ```
    */
  get nRC(): Prisma.NRCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolEndpoint`: Exposes CRUD operations for the **RolEndpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolEndpoints
    * const rolEndpoints = await prisma.rolEndpoint.findMany()
    * ```
    */
  get rolEndpoint(): Prisma.RolEndpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolUsuario`: Exposes CRUD operations for the **RolUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolUsuarios
    * const rolUsuarios = await prisma.rolUsuario.findMany()
    * ```
    */
  get rolUsuario(): Prisma.RolUsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rubrica`: Exposes CRUD operations for the **Rubrica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rubricas
    * const rubricas = await prisma.rubrica.findMany()
    * ```
    */
  get rubrica(): Prisma.RubricaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videojuego`: Exposes CRUD operations for the **Videojuego** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videojuegos
    * const videojuegos = await prisma.videojuego.findMany()
    * ```
    */
  get videojuego(): Prisma.VideojuegoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videojuegoAsignado`: Exposes CRUD operations for the **VideojuegoAsignado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideojuegoAsignados
    * const videojuegoAsignados = await prisma.videojuegoAsignado.findMany()
    * ```
    */
  get videojuegoAsignado(): Prisma.VideojuegoAsignadoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Criterio: 'Criterio',
    Endpoint: 'Endpoint',
    Equipo: 'Equipo',
    Estudiante: 'Estudiante',
    EstudianteNRC: 'EstudianteNRC',
    Evaluacion: 'Evaluacion',
    Jurado: 'Jurado',
    Materia: 'Materia',
    NRC: 'NRC',
    Rol: 'Rol',
    RolEndpoint: 'RolEndpoint',
    RolUsuario: 'RolUsuario',
    Rubrica: 'Rubrica',
    Usuario: 'Usuario',
    Videojuego: 'Videojuego',
    VideojuegoAsignado: 'VideojuegoAsignado'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "criterio" | "endpoint" | "equipo" | "estudiante" | "estudianteNRC" | "evaluacion" | "jurado" | "materia" | "nRC" | "rol" | "rolEndpoint" | "rolUsuario" | "rubrica" | "usuario" | "videojuego" | "videojuegoAsignado"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Criterio: {
        payload: Prisma.$CriterioPayload<ExtArgs>
        fields: Prisma.CriterioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CriterioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CriterioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>
          }
          findFirst: {
            args: Prisma.CriterioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CriterioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>
          }
          findMany: {
            args: Prisma.CriterioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>[]
          }
          create: {
            args: Prisma.CriterioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>
          }
          createMany: {
            args: Prisma.CriterioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CriterioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>[]
          }
          delete: {
            args: Prisma.CriterioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>
          }
          update: {
            args: Prisma.CriterioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>
          }
          deleteMany: {
            args: Prisma.CriterioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CriterioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CriterioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>[]
          }
          upsert: {
            args: Prisma.CriterioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CriterioPayload>
          }
          aggregate: {
            args: Prisma.CriterioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCriterio>
          }
          groupBy: {
            args: Prisma.CriterioGroupByArgs<ExtArgs>
            result: $Utils.Optional<CriterioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CriterioCountArgs<ExtArgs>
            result: $Utils.Optional<CriterioCountAggregateOutputType> | number
          }
        }
      }
      Endpoint: {
        payload: Prisma.$EndpointPayload<ExtArgs>
        fields: Prisma.EndpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EndpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EndpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>
          }
          findFirst: {
            args: Prisma.EndpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EndpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>
          }
          findMany: {
            args: Prisma.EndpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[]
          }
          create: {
            args: Prisma.EndpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>
          }
          createMany: {
            args: Prisma.EndpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EndpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[]
          }
          delete: {
            args: Prisma.EndpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>
          }
          update: {
            args: Prisma.EndpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>
          }
          deleteMany: {
            args: Prisma.EndpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EndpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EndpointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[]
          }
          upsert: {
            args: Prisma.EndpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>
          }
          aggregate: {
            args: Prisma.EndpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndpoint>
          }
          groupBy: {
            args: Prisma.EndpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<EndpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.EndpointCountArgs<ExtArgs>
            result: $Utils.Optional<EndpointCountAggregateOutputType> | number
          }
        }
      }
      Equipo: {
        payload: Prisma.$EquipoPayload<ExtArgs>
        fields: Prisma.EquipoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>
          }
          findFirst: {
            args: Prisma.EquipoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>
          }
          findMany: {
            args: Prisma.EquipoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>[]
          }
          create: {
            args: Prisma.EquipoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>
          }
          createMany: {
            args: Prisma.EquipoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>[]
          }
          delete: {
            args: Prisma.EquipoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>
          }
          update: {
            args: Prisma.EquipoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>
          }
          deleteMany: {
            args: Prisma.EquipoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>[]
          }
          upsert: {
            args: Prisma.EquipoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoPayload>
          }
          aggregate: {
            args: Prisma.EquipoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipo>
          }
          groupBy: {
            args: Prisma.EquipoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipoCountArgs<ExtArgs>
            result: $Utils.Optional<EquipoCountAggregateOutputType> | number
          }
        }
      }
      Estudiante: {
        payload: Prisma.$EstudiantePayload<ExtArgs>
        fields: Prisma.EstudianteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudianteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudianteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findFirst: {
            args: Prisma.EstudianteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudianteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findMany: {
            args: Prisma.EstudianteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          create: {
            args: Prisma.EstudianteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          createMany: {
            args: Prisma.EstudianteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstudianteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          delete: {
            args: Prisma.EstudianteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          update: {
            args: Prisma.EstudianteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          deleteMany: {
            args: Prisma.EstudianteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudianteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EstudianteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          upsert: {
            args: Prisma.EstudianteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          aggregate: {
            args: Prisma.EstudianteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiante>
          }
          groupBy: {
            args: Prisma.EstudianteGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudianteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudianteCountArgs<ExtArgs>
            result: $Utils.Optional<EstudianteCountAggregateOutputType> | number
          }
        }
      }
      EstudianteNRC: {
        payload: Prisma.$EstudianteNRCPayload<ExtArgs>
        fields: Prisma.EstudianteNRCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudianteNRCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudianteNRCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>
          }
          findFirst: {
            args: Prisma.EstudianteNRCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudianteNRCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>
          }
          findMany: {
            args: Prisma.EstudianteNRCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>[]
          }
          create: {
            args: Prisma.EstudianteNRCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>
          }
          createMany: {
            args: Prisma.EstudianteNRCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstudianteNRCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>[]
          }
          delete: {
            args: Prisma.EstudianteNRCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>
          }
          update: {
            args: Prisma.EstudianteNRCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>
          }
          deleteMany: {
            args: Prisma.EstudianteNRCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudianteNRCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EstudianteNRCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>[]
          }
          upsert: {
            args: Prisma.EstudianteNRCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudianteNRCPayload>
          }
          aggregate: {
            args: Prisma.EstudianteNRCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudianteNRC>
          }
          groupBy: {
            args: Prisma.EstudianteNRCGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudianteNRCGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudianteNRCCountArgs<ExtArgs>
            result: $Utils.Optional<EstudianteNRCCountAggregateOutputType> | number
          }
        }
      }
      Evaluacion: {
        payload: Prisma.$EvaluacionPayload<ExtArgs>
        fields: Prisma.EvaluacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>
          }
          findFirst: {
            args: Prisma.EvaluacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>
          }
          findMany: {
            args: Prisma.EvaluacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>[]
          }
          create: {
            args: Prisma.EvaluacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>
          }
          createMany: {
            args: Prisma.EvaluacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>[]
          }
          delete: {
            args: Prisma.EvaluacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>
          }
          update: {
            args: Prisma.EvaluacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>
          }
          deleteMany: {
            args: Prisma.EvaluacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaluacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>[]
          }
          upsert: {
            args: Prisma.EvaluacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionPayload>
          }
          aggregate: {
            args: Prisma.EvaluacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluacion>
          }
          groupBy: {
            args: Prisma.EvaluacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluacionCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluacionCountAggregateOutputType> | number
          }
        }
      }
      Jurado: {
        payload: Prisma.$JuradoPayload<ExtArgs>
        fields: Prisma.JuradoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JuradoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JuradoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>
          }
          findFirst: {
            args: Prisma.JuradoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JuradoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>
          }
          findMany: {
            args: Prisma.JuradoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>[]
          }
          create: {
            args: Prisma.JuradoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>
          }
          createMany: {
            args: Prisma.JuradoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JuradoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>[]
          }
          delete: {
            args: Prisma.JuradoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>
          }
          update: {
            args: Prisma.JuradoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>
          }
          deleteMany: {
            args: Prisma.JuradoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JuradoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JuradoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>[]
          }
          upsert: {
            args: Prisma.JuradoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuradoPayload>
          }
          aggregate: {
            args: Prisma.JuradoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJurado>
          }
          groupBy: {
            args: Prisma.JuradoGroupByArgs<ExtArgs>
            result: $Utils.Optional<JuradoGroupByOutputType>[]
          }
          count: {
            args: Prisma.JuradoCountArgs<ExtArgs>
            result: $Utils.Optional<JuradoCountAggregateOutputType> | number
          }
        }
      }
      Materia: {
        payload: Prisma.$MateriaPayload<ExtArgs>
        fields: Prisma.MateriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MateriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MateriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          findFirst: {
            args: Prisma.MateriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MateriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          findMany: {
            args: Prisma.MateriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          create: {
            args: Prisma.MateriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          createMany: {
            args: Prisma.MateriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MateriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          delete: {
            args: Prisma.MateriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          update: {
            args: Prisma.MateriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          deleteMany: {
            args: Prisma.MateriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MateriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MateriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          upsert: {
            args: Prisma.MateriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          aggregate: {
            args: Prisma.MateriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateria>
          }
          groupBy: {
            args: Prisma.MateriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MateriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MateriaCountArgs<ExtArgs>
            result: $Utils.Optional<MateriaCountAggregateOutputType> | number
          }
        }
      }
      NRC: {
        payload: Prisma.$NRCPayload<ExtArgs>
        fields: Prisma.NRCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NRCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NRCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>
          }
          findFirst: {
            args: Prisma.NRCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NRCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>
          }
          findMany: {
            args: Prisma.NRCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>[]
          }
          create: {
            args: Prisma.NRCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>
          }
          createMany: {
            args: Prisma.NRCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NRCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>[]
          }
          delete: {
            args: Prisma.NRCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>
          }
          update: {
            args: Prisma.NRCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>
          }
          deleteMany: {
            args: Prisma.NRCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NRCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NRCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>[]
          }
          upsert: {
            args: Prisma.NRCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRCPayload>
          }
          aggregate: {
            args: Prisma.NRCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNRC>
          }
          groupBy: {
            args: Prisma.NRCGroupByArgs<ExtArgs>
            result: $Utils.Optional<NRCGroupByOutputType>[]
          }
          count: {
            args: Prisma.NRCCountArgs<ExtArgs>
            result: $Utils.Optional<NRCCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      RolEndpoint: {
        payload: Prisma.$RolEndpointPayload<ExtArgs>
        fields: Prisma.RolEndpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolEndpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolEndpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>
          }
          findFirst: {
            args: Prisma.RolEndpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolEndpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>
          }
          findMany: {
            args: Prisma.RolEndpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>[]
          }
          create: {
            args: Prisma.RolEndpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>
          }
          createMany: {
            args: Prisma.RolEndpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolEndpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>[]
          }
          delete: {
            args: Prisma.RolEndpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>
          }
          update: {
            args: Prisma.RolEndpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>
          }
          deleteMany: {
            args: Prisma.RolEndpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolEndpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolEndpointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>[]
          }
          upsert: {
            args: Prisma.RolEndpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolEndpointPayload>
          }
          aggregate: {
            args: Prisma.RolEndpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolEndpoint>
          }
          groupBy: {
            args: Prisma.RolEndpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolEndpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolEndpointCountArgs<ExtArgs>
            result: $Utils.Optional<RolEndpointCountAggregateOutputType> | number
          }
        }
      }
      RolUsuario: {
        payload: Prisma.$RolUsuarioPayload<ExtArgs>
        fields: Prisma.RolUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>
          }
          findFirst: {
            args: Prisma.RolUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>
          }
          findMany: {
            args: Prisma.RolUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>[]
          }
          create: {
            args: Prisma.RolUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>
          }
          createMany: {
            args: Prisma.RolUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>[]
          }
          delete: {
            args: Prisma.RolUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>
          }
          update: {
            args: Prisma.RolUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.RolUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolUsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>[]
          }
          upsert: {
            args: Prisma.RolUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolUsuarioPayload>
          }
          aggregate: {
            args: Prisma.RolUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolUsuario>
          }
          groupBy: {
            args: Prisma.RolUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<RolUsuarioCountAggregateOutputType> | number
          }
        }
      }
      Rubrica: {
        payload: Prisma.$RubricaPayload<ExtArgs>
        fields: Prisma.RubricaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RubricaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RubricaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>
          }
          findFirst: {
            args: Prisma.RubricaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RubricaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>
          }
          findMany: {
            args: Prisma.RubricaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>[]
          }
          create: {
            args: Prisma.RubricaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>
          }
          createMany: {
            args: Prisma.RubricaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RubricaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>[]
          }
          delete: {
            args: Prisma.RubricaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>
          }
          update: {
            args: Prisma.RubricaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>
          }
          deleteMany: {
            args: Prisma.RubricaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RubricaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RubricaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>[]
          }
          upsert: {
            args: Prisma.RubricaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricaPayload>
          }
          aggregate: {
            args: Prisma.RubricaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRubrica>
          }
          groupBy: {
            args: Prisma.RubricaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RubricaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RubricaCountArgs<ExtArgs>
            result: $Utils.Optional<RubricaCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Videojuego: {
        payload: Prisma.$VideojuegoPayload<ExtArgs>
        fields: Prisma.VideojuegoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideojuegoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideojuegoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>
          }
          findFirst: {
            args: Prisma.VideojuegoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideojuegoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>
          }
          findMany: {
            args: Prisma.VideojuegoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>[]
          }
          create: {
            args: Prisma.VideojuegoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>
          }
          createMany: {
            args: Prisma.VideojuegoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideojuegoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>[]
          }
          delete: {
            args: Prisma.VideojuegoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>
          }
          update: {
            args: Prisma.VideojuegoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>
          }
          deleteMany: {
            args: Prisma.VideojuegoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideojuegoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideojuegoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>[]
          }
          upsert: {
            args: Prisma.VideojuegoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoPayload>
          }
          aggregate: {
            args: Prisma.VideojuegoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideojuego>
          }
          groupBy: {
            args: Prisma.VideojuegoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideojuegoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideojuegoCountArgs<ExtArgs>
            result: $Utils.Optional<VideojuegoCountAggregateOutputType> | number
          }
        }
      }
      VideojuegoAsignado: {
        payload: Prisma.$VideojuegoAsignadoPayload<ExtArgs>
        fields: Prisma.VideojuegoAsignadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideojuegoAsignadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideojuegoAsignadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>
          }
          findFirst: {
            args: Prisma.VideojuegoAsignadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideojuegoAsignadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>
          }
          findMany: {
            args: Prisma.VideojuegoAsignadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>[]
          }
          create: {
            args: Prisma.VideojuegoAsignadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>
          }
          createMany: {
            args: Prisma.VideojuegoAsignadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideojuegoAsignadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>[]
          }
          delete: {
            args: Prisma.VideojuegoAsignadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>
          }
          update: {
            args: Prisma.VideojuegoAsignadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>
          }
          deleteMany: {
            args: Prisma.VideojuegoAsignadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideojuegoAsignadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideojuegoAsignadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>[]
          }
          upsert: {
            args: Prisma.VideojuegoAsignadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideojuegoAsignadoPayload>
          }
          aggregate: {
            args: Prisma.VideojuegoAsignadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideojuegoAsignado>
          }
          groupBy: {
            args: Prisma.VideojuegoAsignadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideojuegoAsignadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideojuegoAsignadoCountArgs<ExtArgs>
            result: $Utils.Optional<VideojuegoAsignadoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    criterio?: CriterioOmit
    endpoint?: EndpointOmit
    equipo?: EquipoOmit
    estudiante?: EstudianteOmit
    estudianteNRC?: EstudianteNRCOmit
    evaluacion?: EvaluacionOmit
    jurado?: JuradoOmit
    materia?: MateriaOmit
    nRC?: NRCOmit
    rol?: RolOmit
    rolEndpoint?: RolEndpointOmit
    rolUsuario?: RolUsuarioOmit
    rubrica?: RubricaOmit
    usuario?: UsuarioOmit
    videojuego?: VideojuegoOmit
    videojuegoAsignado?: VideojuegoAsignadoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CriterioCountOutputType
   */

  export type CriterioCountOutputType = {
    Rubrica: number
  }

  export type CriterioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rubrica?: boolean | CriterioCountOutputTypeCountRubricaArgs
  }

  // Custom InputTypes
  /**
   * CriterioCountOutputType without action
   */
  export type CriterioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CriterioCountOutputType
     */
    select?: CriterioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CriterioCountOutputType without action
   */
  export type CriterioCountOutputTypeCountRubricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RubricaWhereInput
  }


  /**
   * Count Type EndpointCountOutputType
   */

  export type EndpointCountOutputType = {
    RolEndpoint: number
  }

  export type EndpointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolEndpoint?: boolean | EndpointCountOutputTypeCountRolEndpointArgs
  }

  // Custom InputTypes
  /**
   * EndpointCountOutputType without action
   */
  export type EndpointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndpointCountOutputType
     */
    select?: EndpointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EndpointCountOutputType without action
   */
  export type EndpointCountOutputTypeCountRolEndpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolEndpointWhereInput
  }


  /**
   * Count Type EquipoCountOutputType
   */

  export type EquipoCountOutputType = {
    Estudiante: number
    Videojuego: number
  }

  export type EquipoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Estudiante?: boolean | EquipoCountOutputTypeCountEstudianteArgs
    Videojuego?: boolean | EquipoCountOutputTypeCountVideojuegoArgs
  }

  // Custom InputTypes
  /**
   * EquipoCountOutputType without action
   */
  export type EquipoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCountOutputType
     */
    select?: EquipoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipoCountOutputType without action
   */
  export type EquipoCountOutputTypeCountEstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteWhereInput
  }

  /**
   * EquipoCountOutputType without action
   */
  export type EquipoCountOutputTypeCountVideojuegoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideojuegoWhereInput
  }


  /**
   * Count Type EstudianteCountOutputType
   */

  export type EstudianteCountOutputType = {
    EstudianteNRC: number
  }

  export type EstudianteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EstudianteNRC?: boolean | EstudianteCountOutputTypeCountEstudianteNRCArgs
  }

  // Custom InputTypes
  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteCountOutputType
     */
    select?: EstudianteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountEstudianteNRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteNRCWhereInput
  }


  /**
   * Count Type EvaluacionCountOutputType
   */

  export type EvaluacionCountOutputType = {
    Rubrica: number
  }

  export type EvaluacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rubrica?: boolean | EvaluacionCountOutputTypeCountRubricaArgs
  }

  // Custom InputTypes
  /**
   * EvaluacionCountOutputType without action
   */
  export type EvaluacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluacionCountOutputType
     */
    select?: EvaluacionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluacionCountOutputType without action
   */
  export type EvaluacionCountOutputTypeCountRubricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RubricaWhereInput
  }


  /**
   * Count Type JuradoCountOutputType
   */

  export type JuradoCountOutputType = {
    Evaluacion: number
    VideojuegoAsignado: number
  }

  export type JuradoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Evaluacion?: boolean | JuradoCountOutputTypeCountEvaluacionArgs
    VideojuegoAsignado?: boolean | JuradoCountOutputTypeCountVideojuegoAsignadoArgs
  }

  // Custom InputTypes
  /**
   * JuradoCountOutputType without action
   */
  export type JuradoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JuradoCountOutputType
     */
    select?: JuradoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JuradoCountOutputType without action
   */
  export type JuradoCountOutputTypeCountEvaluacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionWhereInput
  }

  /**
   * JuradoCountOutputType without action
   */
  export type JuradoCountOutputTypeCountVideojuegoAsignadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideojuegoAsignadoWhereInput
  }


  /**
   * Count Type MateriaCountOutputType
   */

  export type MateriaCountOutputType = {
    NRC: number
  }

  export type MateriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NRC?: boolean | MateriaCountOutputTypeCountNRCArgs
  }

  // Custom InputTypes
  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MateriaCountOutputType
     */
    select?: MateriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeCountNRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NRCWhereInput
  }


  /**
   * Count Type NRCCountOutputType
   */

  export type NRCCountOutputType = {
    EstudianteNRC: number
  }

  export type NRCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EstudianteNRC?: boolean | NRCCountOutputTypeCountEstudianteNRCArgs
  }

  // Custom InputTypes
  /**
   * NRCCountOutputType without action
   */
  export type NRCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRCCountOutputType
     */
    select?: NRCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NRCCountOutputType without action
   */
  export type NRCCountOutputTypeCountEstudianteNRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteNRCWhereInput
  }


  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    RolEndpoint: number
    RolUsuario: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolEndpoint?: boolean | RolCountOutputTypeCountRolEndpointArgs
    RolUsuario?: boolean | RolCountOutputTypeCountRolUsuarioArgs
  }

  // Custom InputTypes
  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountRolEndpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolEndpointWhereInput
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountRolUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolUsuarioWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    NRC: number
    RolUsuario: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NRC?: boolean | UsuarioCountOutputTypeCountNRCArgs
    RolUsuario?: boolean | UsuarioCountOutputTypeCountRolUsuarioArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountNRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NRCWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRolUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolUsuarioWhereInput
  }


  /**
   * Count Type VideojuegoCountOutputType
   */

  export type VideojuegoCountOutputType = {
    Evaluacion: number
    VideojuegoAsignado: number
  }

  export type VideojuegoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Evaluacion?: boolean | VideojuegoCountOutputTypeCountEvaluacionArgs
    VideojuegoAsignado?: boolean | VideojuegoCountOutputTypeCountVideojuegoAsignadoArgs
  }

  // Custom InputTypes
  /**
   * VideojuegoCountOutputType without action
   */
  export type VideojuegoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoCountOutputType
     */
    select?: VideojuegoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideojuegoCountOutputType without action
   */
  export type VideojuegoCountOutputTypeCountEvaluacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionWhereInput
  }

  /**
   * VideojuegoCountOutputType without action
   */
  export type VideojuegoCountOutputTypeCountVideojuegoAsignadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideojuegoAsignadoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Criterio
   */

  export type AggregateCriterio = {
    _count: CriterioCountAggregateOutputType | null
    _avg: CriterioAvgAggregateOutputType | null
    _sum: CriterioSumAggregateOutputType | null
    _min: CriterioMinAggregateOutputType | null
    _max: CriterioMaxAggregateOutputType | null
  }

  export type CriterioAvgAggregateOutputType = {
    id: number | null
  }

  export type CriterioSumAggregateOutputType = {
    id: number | null
  }

  export type CriterioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type CriterioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type CriterioCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type CriterioAvgAggregateInputType = {
    id?: true
  }

  export type CriterioSumAggregateInputType = {
    id?: true
  }

  export type CriterioMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type CriterioMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type CriterioCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type CriterioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Criterio to aggregate.
     */
    where?: CriterioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Criterios to fetch.
     */
    orderBy?: CriterioOrderByWithRelationInput | CriterioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CriterioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Criterios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Criterios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Criterios
    **/
    _count?: true | CriterioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CriterioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CriterioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CriterioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CriterioMaxAggregateInputType
  }

  export type GetCriterioAggregateType<T extends CriterioAggregateArgs> = {
        [P in keyof T & keyof AggregateCriterio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCriterio[P]>
      : GetScalarType<T[P], AggregateCriterio[P]>
  }




  export type CriterioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CriterioWhereInput
    orderBy?: CriterioOrderByWithAggregationInput | CriterioOrderByWithAggregationInput[]
    by: CriterioScalarFieldEnum[] | CriterioScalarFieldEnum
    having?: CriterioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CriterioCountAggregateInputType | true
    _avg?: CriterioAvgAggregateInputType
    _sum?: CriterioSumAggregateInputType
    _min?: CriterioMinAggregateInputType
    _max?: CriterioMaxAggregateInputType
  }

  export type CriterioGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: CriterioCountAggregateOutputType | null
    _avg: CriterioAvgAggregateOutputType | null
    _sum: CriterioSumAggregateOutputType | null
    _min: CriterioMinAggregateOutputType | null
    _max: CriterioMaxAggregateOutputType | null
  }

  type GetCriterioGroupByPayload<T extends CriterioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CriterioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CriterioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CriterioGroupByOutputType[P]>
            : GetScalarType<T[P], CriterioGroupByOutputType[P]>
        }
      >
    >


  export type CriterioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Rubrica?: boolean | Criterio$RubricaArgs<ExtArgs>
    _count?: boolean | CriterioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["criterio"]>

  export type CriterioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["criterio"]>

  export type CriterioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["criterio"]>

  export type CriterioSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type CriterioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["criterio"]>
  export type CriterioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rubrica?: boolean | Criterio$RubricaArgs<ExtArgs>
    _count?: boolean | CriterioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CriterioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CriterioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CriterioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Criterio"
    objects: {
      Rubrica: Prisma.$RubricaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["criterio"]>
    composites: {}
  }

  type CriterioGetPayload<S extends boolean | null | undefined | CriterioDefaultArgs> = $Result.GetResult<Prisma.$CriterioPayload, S>

  type CriterioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CriterioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CriterioCountAggregateInputType | true
    }

  export interface CriterioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Criterio'], meta: { name: 'Criterio' } }
    /**
     * Find zero or one Criterio that matches the filter.
     * @param {CriterioFindUniqueArgs} args - Arguments to find a Criterio
     * @example
     * // Get one Criterio
     * const criterio = await prisma.criterio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CriterioFindUniqueArgs>(args: SelectSubset<T, CriterioFindUniqueArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Criterio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CriterioFindUniqueOrThrowArgs} args - Arguments to find a Criterio
     * @example
     * // Get one Criterio
     * const criterio = await prisma.criterio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CriterioFindUniqueOrThrowArgs>(args: SelectSubset<T, CriterioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Criterio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioFindFirstArgs} args - Arguments to find a Criterio
     * @example
     * // Get one Criterio
     * const criterio = await prisma.criterio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CriterioFindFirstArgs>(args?: SelectSubset<T, CriterioFindFirstArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Criterio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioFindFirstOrThrowArgs} args - Arguments to find a Criterio
     * @example
     * // Get one Criterio
     * const criterio = await prisma.criterio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CriterioFindFirstOrThrowArgs>(args?: SelectSubset<T, CriterioFindFirstOrThrowArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Criterios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Criterios
     * const criterios = await prisma.criterio.findMany()
     * 
     * // Get first 10 Criterios
     * const criterios = await prisma.criterio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const criterioWithIdOnly = await prisma.criterio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CriterioFindManyArgs>(args?: SelectSubset<T, CriterioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Criterio.
     * @param {CriterioCreateArgs} args - Arguments to create a Criterio.
     * @example
     * // Create one Criterio
     * const Criterio = await prisma.criterio.create({
     *   data: {
     *     // ... data to create a Criterio
     *   }
     * })
     * 
     */
    create<T extends CriterioCreateArgs>(args: SelectSubset<T, CriterioCreateArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Criterios.
     * @param {CriterioCreateManyArgs} args - Arguments to create many Criterios.
     * @example
     * // Create many Criterios
     * const criterio = await prisma.criterio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CriterioCreateManyArgs>(args?: SelectSubset<T, CriterioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Criterios and returns the data saved in the database.
     * @param {CriterioCreateManyAndReturnArgs} args - Arguments to create many Criterios.
     * @example
     * // Create many Criterios
     * const criterio = await prisma.criterio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Criterios and only return the `id`
     * const criterioWithIdOnly = await prisma.criterio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CriterioCreateManyAndReturnArgs>(args?: SelectSubset<T, CriterioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Criterio.
     * @param {CriterioDeleteArgs} args - Arguments to delete one Criterio.
     * @example
     * // Delete one Criterio
     * const Criterio = await prisma.criterio.delete({
     *   where: {
     *     // ... filter to delete one Criterio
     *   }
     * })
     * 
     */
    delete<T extends CriterioDeleteArgs>(args: SelectSubset<T, CriterioDeleteArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Criterio.
     * @param {CriterioUpdateArgs} args - Arguments to update one Criterio.
     * @example
     * // Update one Criterio
     * const criterio = await prisma.criterio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CriterioUpdateArgs>(args: SelectSubset<T, CriterioUpdateArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Criterios.
     * @param {CriterioDeleteManyArgs} args - Arguments to filter Criterios to delete.
     * @example
     * // Delete a few Criterios
     * const { count } = await prisma.criterio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CriterioDeleteManyArgs>(args?: SelectSubset<T, CriterioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Criterios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Criterios
     * const criterio = await prisma.criterio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CriterioUpdateManyArgs>(args: SelectSubset<T, CriterioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Criterios and returns the data updated in the database.
     * @param {CriterioUpdateManyAndReturnArgs} args - Arguments to update many Criterios.
     * @example
     * // Update many Criterios
     * const criterio = await prisma.criterio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Criterios and only return the `id`
     * const criterioWithIdOnly = await prisma.criterio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CriterioUpdateManyAndReturnArgs>(args: SelectSubset<T, CriterioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Criterio.
     * @param {CriterioUpsertArgs} args - Arguments to update or create a Criterio.
     * @example
     * // Update or create a Criterio
     * const criterio = await prisma.criterio.upsert({
     *   create: {
     *     // ... data to create a Criterio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Criterio we want to update
     *   }
     * })
     */
    upsert<T extends CriterioUpsertArgs>(args: SelectSubset<T, CriterioUpsertArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Criterios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioCountArgs} args - Arguments to filter Criterios to count.
     * @example
     * // Count the number of Criterios
     * const count = await prisma.criterio.count({
     *   where: {
     *     // ... the filter for the Criterios we want to count
     *   }
     * })
    **/
    count<T extends CriterioCountArgs>(
      args?: Subset<T, CriterioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CriterioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Criterio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CriterioAggregateArgs>(args: Subset<T, CriterioAggregateArgs>): Prisma.PrismaPromise<GetCriterioAggregateType<T>>

    /**
     * Group by Criterio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriterioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CriterioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CriterioGroupByArgs['orderBy'] }
        : { orderBy?: CriterioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CriterioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCriterioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Criterio model
   */
  readonly fields: CriterioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Criterio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CriterioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Rubrica<T extends Criterio$RubricaArgs<ExtArgs> = {}>(args?: Subset<T, Criterio$RubricaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Criterio model
   */
  interface CriterioFieldRefs {
    readonly id: FieldRef<"Criterio", 'Int'>
    readonly nombre: FieldRef<"Criterio", 'String'>
    readonly descripcion: FieldRef<"Criterio", 'String'>
    readonly create_at: FieldRef<"Criterio", 'DateTime'>
    readonly update_at: FieldRef<"Criterio", 'DateTime'>
    readonly deleted: FieldRef<"Criterio", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Criterio findUnique
   */
  export type CriterioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * Filter, which Criterio to fetch.
     */
    where: CriterioWhereUniqueInput
  }

  /**
   * Criterio findUniqueOrThrow
   */
  export type CriterioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * Filter, which Criterio to fetch.
     */
    where: CriterioWhereUniqueInput
  }

  /**
   * Criterio findFirst
   */
  export type CriterioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * Filter, which Criterio to fetch.
     */
    where?: CriterioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Criterios to fetch.
     */
    orderBy?: CriterioOrderByWithRelationInput | CriterioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Criterios.
     */
    cursor?: CriterioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Criterios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Criterios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Criterios.
     */
    distinct?: CriterioScalarFieldEnum | CriterioScalarFieldEnum[]
  }

  /**
   * Criterio findFirstOrThrow
   */
  export type CriterioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * Filter, which Criterio to fetch.
     */
    where?: CriterioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Criterios to fetch.
     */
    orderBy?: CriterioOrderByWithRelationInput | CriterioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Criterios.
     */
    cursor?: CriterioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Criterios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Criterios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Criterios.
     */
    distinct?: CriterioScalarFieldEnum | CriterioScalarFieldEnum[]
  }

  /**
   * Criterio findMany
   */
  export type CriterioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * Filter, which Criterios to fetch.
     */
    where?: CriterioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Criterios to fetch.
     */
    orderBy?: CriterioOrderByWithRelationInput | CriterioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Criterios.
     */
    cursor?: CriterioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Criterios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Criterios.
     */
    skip?: number
    distinct?: CriterioScalarFieldEnum | CriterioScalarFieldEnum[]
  }

  /**
   * Criterio create
   */
  export type CriterioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * The data needed to create a Criterio.
     */
    data: XOR<CriterioCreateInput, CriterioUncheckedCreateInput>
  }

  /**
   * Criterio createMany
   */
  export type CriterioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Criterios.
     */
    data: CriterioCreateManyInput | CriterioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Criterio createManyAndReturn
   */
  export type CriterioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * The data used to create many Criterios.
     */
    data: CriterioCreateManyInput | CriterioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Criterio update
   */
  export type CriterioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * The data needed to update a Criterio.
     */
    data: XOR<CriterioUpdateInput, CriterioUncheckedUpdateInput>
    /**
     * Choose, which Criterio to update.
     */
    where: CriterioWhereUniqueInput
  }

  /**
   * Criterio updateMany
   */
  export type CriterioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Criterios.
     */
    data: XOR<CriterioUpdateManyMutationInput, CriterioUncheckedUpdateManyInput>
    /**
     * Filter which Criterios to update
     */
    where?: CriterioWhereInput
    /**
     * Limit how many Criterios to update.
     */
    limit?: number
  }

  /**
   * Criterio updateManyAndReturn
   */
  export type CriterioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * The data used to update Criterios.
     */
    data: XOR<CriterioUpdateManyMutationInput, CriterioUncheckedUpdateManyInput>
    /**
     * Filter which Criterios to update
     */
    where?: CriterioWhereInput
    /**
     * Limit how many Criterios to update.
     */
    limit?: number
  }

  /**
   * Criterio upsert
   */
  export type CriterioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * The filter to search for the Criterio to update in case it exists.
     */
    where: CriterioWhereUniqueInput
    /**
     * In case the Criterio found by the `where` argument doesn't exist, create a new Criterio with this data.
     */
    create: XOR<CriterioCreateInput, CriterioUncheckedCreateInput>
    /**
     * In case the Criterio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CriterioUpdateInput, CriterioUncheckedUpdateInput>
  }

  /**
   * Criterio delete
   */
  export type CriterioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
    /**
     * Filter which Criterio to delete.
     */
    where: CriterioWhereUniqueInput
  }

  /**
   * Criterio deleteMany
   */
  export type CriterioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Criterios to delete
     */
    where?: CriterioWhereInput
    /**
     * Limit how many Criterios to delete.
     */
    limit?: number
  }

  /**
   * Criterio.Rubrica
   */
  export type Criterio$RubricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    where?: RubricaWhereInput
    orderBy?: RubricaOrderByWithRelationInput | RubricaOrderByWithRelationInput[]
    cursor?: RubricaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RubricaScalarFieldEnum | RubricaScalarFieldEnum[]
  }

  /**
   * Criterio without action
   */
  export type CriterioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Criterio
     */
    select?: CriterioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Criterio
     */
    omit?: CriterioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriterioInclude<ExtArgs> | null
  }


  /**
   * Model Endpoint
   */

  export type AggregateEndpoint = {
    _count: EndpointCountAggregateOutputType | null
    _avg: EndpointAvgAggregateOutputType | null
    _sum: EndpointSumAggregateOutputType | null
    _min: EndpointMinAggregateOutputType | null
    _max: EndpointMaxAggregateOutputType | null
  }

  export type EndpointAvgAggregateOutputType = {
    id: number | null
    num_parametros: number | null
  }

  export type EndpointSumAggregateOutputType = {
    id: number | null
    num_parametros: number | null
  }

  export type EndpointMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    metodo: $Enums.Tipo | null
    num_parametros: number | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EndpointMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    metodo: $Enums.Tipo | null
    num_parametros: number | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EndpointCountAggregateOutputType = {
    id: number
    nombre: number
    metodo: number
    num_parametros: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type EndpointAvgAggregateInputType = {
    id?: true
    num_parametros?: true
  }

  export type EndpointSumAggregateInputType = {
    id?: true
    num_parametros?: true
  }

  export type EndpointMinAggregateInputType = {
    id?: true
    nombre?: true
    metodo?: true
    num_parametros?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EndpointMaxAggregateInputType = {
    id?: true
    nombre?: true
    metodo?: true
    num_parametros?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EndpointCountAggregateInputType = {
    id?: true
    nombre?: true
    metodo?: true
    num_parametros?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type EndpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endpoint to aggregate.
     */
    where?: EndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Endpoints
    **/
    _count?: true | EndpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EndpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EndpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EndpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EndpointMaxAggregateInputType
  }

  export type GetEndpointAggregateType<T extends EndpointAggregateArgs> = {
        [P in keyof T & keyof AggregateEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndpoint[P]>
      : GetScalarType<T[P], AggregateEndpoint[P]>
  }




  export type EndpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EndpointWhereInput
    orderBy?: EndpointOrderByWithAggregationInput | EndpointOrderByWithAggregationInput[]
    by: EndpointScalarFieldEnum[] | EndpointScalarFieldEnum
    having?: EndpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EndpointCountAggregateInputType | true
    _avg?: EndpointAvgAggregateInputType
    _sum?: EndpointSumAggregateInputType
    _min?: EndpointMinAggregateInputType
    _max?: EndpointMaxAggregateInputType
  }

  export type EndpointGroupByOutputType = {
    id: number
    nombre: string | null
    metodo: $Enums.Tipo
    num_parametros: number
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: EndpointCountAggregateOutputType | null
    _avg: EndpointAvgAggregateOutputType | null
    _sum: EndpointSumAggregateOutputType | null
    _min: EndpointMinAggregateOutputType | null
    _max: EndpointMaxAggregateOutputType | null
  }

  type GetEndpointGroupByPayload<T extends EndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EndpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EndpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EndpointGroupByOutputType[P]>
            : GetScalarType<T[P], EndpointGroupByOutputType[P]>
        }
      >
    >


  export type EndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    metodo?: boolean
    num_parametros?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    RolEndpoint?: boolean | Endpoint$RolEndpointArgs<ExtArgs>
    _count?: boolean | EndpointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endpoint"]>

  export type EndpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    metodo?: boolean
    num_parametros?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["endpoint"]>

  export type EndpointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    metodo?: boolean
    num_parametros?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["endpoint"]>

  export type EndpointSelectScalar = {
    id?: boolean
    nombre?: boolean
    metodo?: boolean
    num_parametros?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type EndpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "metodo" | "num_parametros" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["endpoint"]>
  export type EndpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolEndpoint?: boolean | Endpoint$RolEndpointArgs<ExtArgs>
    _count?: boolean | EndpointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EndpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EndpointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Endpoint"
    objects: {
      RolEndpoint: Prisma.$RolEndpointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string | null
      metodo: $Enums.Tipo
      num_parametros: number
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["endpoint"]>
    composites: {}
  }

  type EndpointGetPayload<S extends boolean | null | undefined | EndpointDefaultArgs> = $Result.GetResult<Prisma.$EndpointPayload, S>

  type EndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EndpointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EndpointCountAggregateInputType | true
    }

  export interface EndpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Endpoint'], meta: { name: 'Endpoint' } }
    /**
     * Find zero or one Endpoint that matches the filter.
     * @param {EndpointFindUniqueArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EndpointFindUniqueArgs>(args: SelectSubset<T, EndpointFindUniqueArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Endpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EndpointFindUniqueOrThrowArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EndpointFindUniqueOrThrowArgs>(args: SelectSubset<T, EndpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindFirstArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EndpointFindFirstArgs>(args?: SelectSubset<T, EndpointFindFirstArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindFirstOrThrowArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EndpointFindFirstOrThrowArgs>(args?: SelectSubset<T, EndpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Endpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Endpoints
     * const endpoints = await prisma.endpoint.findMany()
     * 
     * // Get first 10 Endpoints
     * const endpoints = await prisma.endpoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const endpointWithIdOnly = await prisma.endpoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EndpointFindManyArgs>(args?: SelectSubset<T, EndpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Endpoint.
     * @param {EndpointCreateArgs} args - Arguments to create a Endpoint.
     * @example
     * // Create one Endpoint
     * const Endpoint = await prisma.endpoint.create({
     *   data: {
     *     // ... data to create a Endpoint
     *   }
     * })
     * 
     */
    create<T extends EndpointCreateArgs>(args: SelectSubset<T, EndpointCreateArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Endpoints.
     * @param {EndpointCreateManyArgs} args - Arguments to create many Endpoints.
     * @example
     * // Create many Endpoints
     * const endpoint = await prisma.endpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EndpointCreateManyArgs>(args?: SelectSubset<T, EndpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Endpoints and returns the data saved in the database.
     * @param {EndpointCreateManyAndReturnArgs} args - Arguments to create many Endpoints.
     * @example
     * // Create many Endpoints
     * const endpoint = await prisma.endpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Endpoints and only return the `id`
     * const endpointWithIdOnly = await prisma.endpoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EndpointCreateManyAndReturnArgs>(args?: SelectSubset<T, EndpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Endpoint.
     * @param {EndpointDeleteArgs} args - Arguments to delete one Endpoint.
     * @example
     * // Delete one Endpoint
     * const Endpoint = await prisma.endpoint.delete({
     *   where: {
     *     // ... filter to delete one Endpoint
     *   }
     * })
     * 
     */
    delete<T extends EndpointDeleteArgs>(args: SelectSubset<T, EndpointDeleteArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Endpoint.
     * @param {EndpointUpdateArgs} args - Arguments to update one Endpoint.
     * @example
     * // Update one Endpoint
     * const endpoint = await prisma.endpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EndpointUpdateArgs>(args: SelectSubset<T, EndpointUpdateArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Endpoints.
     * @param {EndpointDeleteManyArgs} args - Arguments to filter Endpoints to delete.
     * @example
     * // Delete a few Endpoints
     * const { count } = await prisma.endpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EndpointDeleteManyArgs>(args?: SelectSubset<T, EndpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Endpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Endpoints
     * const endpoint = await prisma.endpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EndpointUpdateManyArgs>(args: SelectSubset<T, EndpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Endpoints and returns the data updated in the database.
     * @param {EndpointUpdateManyAndReturnArgs} args - Arguments to update many Endpoints.
     * @example
     * // Update many Endpoints
     * const endpoint = await prisma.endpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Endpoints and only return the `id`
     * const endpointWithIdOnly = await prisma.endpoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EndpointUpdateManyAndReturnArgs>(args: SelectSubset<T, EndpointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Endpoint.
     * @param {EndpointUpsertArgs} args - Arguments to update or create a Endpoint.
     * @example
     * // Update or create a Endpoint
     * const endpoint = await prisma.endpoint.upsert({
     *   create: {
     *     // ... data to create a Endpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endpoint we want to update
     *   }
     * })
     */
    upsert<T extends EndpointUpsertArgs>(args: SelectSubset<T, EndpointUpsertArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Endpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointCountArgs} args - Arguments to filter Endpoints to count.
     * @example
     * // Count the number of Endpoints
     * const count = await prisma.endpoint.count({
     *   where: {
     *     // ... the filter for the Endpoints we want to count
     *   }
     * })
    **/
    count<T extends EndpointCountArgs>(
      args?: Subset<T, EndpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EndpointAggregateArgs>(args: Subset<T, EndpointAggregateArgs>): Prisma.PrismaPromise<GetEndpointAggregateType<T>>

    /**
     * Group by Endpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EndpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndpointGroupByArgs['orderBy'] }
        : { orderBy?: EndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EndpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Endpoint model
   */
  readonly fields: EndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EndpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RolEndpoint<T extends Endpoint$RolEndpointArgs<ExtArgs> = {}>(args?: Subset<T, Endpoint$RolEndpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Endpoint model
   */
  interface EndpointFieldRefs {
    readonly id: FieldRef<"Endpoint", 'Int'>
    readonly nombre: FieldRef<"Endpoint", 'String'>
    readonly metodo: FieldRef<"Endpoint", 'Tipo'>
    readonly num_parametros: FieldRef<"Endpoint", 'Int'>
    readonly create_at: FieldRef<"Endpoint", 'DateTime'>
    readonly update_at: FieldRef<"Endpoint", 'DateTime'>
    readonly deleted: FieldRef<"Endpoint", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Endpoint findUnique
   */
  export type EndpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * Filter, which Endpoint to fetch.
     */
    where: EndpointWhereUniqueInput
  }

  /**
   * Endpoint findUniqueOrThrow
   */
  export type EndpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * Filter, which Endpoint to fetch.
     */
    where: EndpointWhereUniqueInput
  }

  /**
   * Endpoint findFirst
   */
  export type EndpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * Filter, which Endpoint to fetch.
     */
    where?: EndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endpoints.
     */
    cursor?: EndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endpoints.
     */
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[]
  }

  /**
   * Endpoint findFirstOrThrow
   */
  export type EndpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * Filter, which Endpoint to fetch.
     */
    where?: EndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endpoints.
     */
    cursor?: EndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endpoints.
     */
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[]
  }

  /**
   * Endpoint findMany
   */
  export type EndpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * Filter, which Endpoints to fetch.
     */
    where?: EndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Endpoints.
     */
    cursor?: EndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endpoints.
     */
    skip?: number
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[]
  }

  /**
   * Endpoint create
   */
  export type EndpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * The data needed to create a Endpoint.
     */
    data: XOR<EndpointCreateInput, EndpointUncheckedCreateInput>
  }

  /**
   * Endpoint createMany
   */
  export type EndpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Endpoints.
     */
    data: EndpointCreateManyInput | EndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endpoint createManyAndReturn
   */
  export type EndpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * The data used to create many Endpoints.
     */
    data: EndpointCreateManyInput | EndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endpoint update
   */
  export type EndpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * The data needed to update a Endpoint.
     */
    data: XOR<EndpointUpdateInput, EndpointUncheckedUpdateInput>
    /**
     * Choose, which Endpoint to update.
     */
    where: EndpointWhereUniqueInput
  }

  /**
   * Endpoint updateMany
   */
  export type EndpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Endpoints.
     */
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyInput>
    /**
     * Filter which Endpoints to update
     */
    where?: EndpointWhereInput
    /**
     * Limit how many Endpoints to update.
     */
    limit?: number
  }

  /**
   * Endpoint updateManyAndReturn
   */
  export type EndpointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * The data used to update Endpoints.
     */
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyInput>
    /**
     * Filter which Endpoints to update
     */
    where?: EndpointWhereInput
    /**
     * Limit how many Endpoints to update.
     */
    limit?: number
  }

  /**
   * Endpoint upsert
   */
  export type EndpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * The filter to search for the Endpoint to update in case it exists.
     */
    where: EndpointWhereUniqueInput
    /**
     * In case the Endpoint found by the `where` argument doesn't exist, create a new Endpoint with this data.
     */
    create: XOR<EndpointCreateInput, EndpointUncheckedCreateInput>
    /**
     * In case the Endpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EndpointUpdateInput, EndpointUncheckedUpdateInput>
  }

  /**
   * Endpoint delete
   */
  export type EndpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
    /**
     * Filter which Endpoint to delete.
     */
    where: EndpointWhereUniqueInput
  }

  /**
   * Endpoint deleteMany
   */
  export type EndpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endpoints to delete
     */
    where?: EndpointWhereInput
    /**
     * Limit how many Endpoints to delete.
     */
    limit?: number
  }

  /**
   * Endpoint.RolEndpoint
   */
  export type Endpoint$RolEndpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    where?: RolEndpointWhereInput
    orderBy?: RolEndpointOrderByWithRelationInput | RolEndpointOrderByWithRelationInput[]
    cursor?: RolEndpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolEndpointScalarFieldEnum | RolEndpointScalarFieldEnum[]
  }

  /**
   * Endpoint without action
   */
  export type EndpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null
  }


  /**
   * Model Equipo
   */

  export type AggregateEquipo = {
    _count: EquipoCountAggregateOutputType | null
    _avg: EquipoAvgAggregateOutputType | null
    _sum: EquipoSumAggregateOutputType | null
    _min: EquipoMinAggregateOutputType | null
    _max: EquipoMaxAggregateOutputType | null
  }

  export type EquipoAvgAggregateOutputType = {
    id: number | null
  }

  export type EquipoSumAggregateOutputType = {
    id: number | null
  }

  export type EquipoMinAggregateOutputType = {
    id: number | null
    nombre_equipo: string | null
    url_logo: string | null
    estado: $Enums.Estado | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EquipoMaxAggregateOutputType = {
    id: number | null
    nombre_equipo: string | null
    url_logo: string | null
    estado: $Enums.Estado | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EquipoCountAggregateOutputType = {
    id: number
    nombre_equipo: number
    url_logo: number
    estado: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type EquipoAvgAggregateInputType = {
    id?: true
  }

  export type EquipoSumAggregateInputType = {
    id?: true
  }

  export type EquipoMinAggregateInputType = {
    id?: true
    nombre_equipo?: true
    url_logo?: true
    estado?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EquipoMaxAggregateInputType = {
    id?: true
    nombre_equipo?: true
    url_logo?: true
    estado?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EquipoCountAggregateInputType = {
    id?: true
    nombre_equipo?: true
    url_logo?: true
    estado?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type EquipoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipo to aggregate.
     */
    where?: EquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipos to fetch.
     */
    orderBy?: EquipoOrderByWithRelationInput | EquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipos
    **/
    _count?: true | EquipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipoMaxAggregateInputType
  }

  export type GetEquipoAggregateType<T extends EquipoAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipo[P]>
      : GetScalarType<T[P], AggregateEquipo[P]>
  }




  export type EquipoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipoWhereInput
    orderBy?: EquipoOrderByWithAggregationInput | EquipoOrderByWithAggregationInput[]
    by: EquipoScalarFieldEnum[] | EquipoScalarFieldEnum
    having?: EquipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipoCountAggregateInputType | true
    _avg?: EquipoAvgAggregateInputType
    _sum?: EquipoSumAggregateInputType
    _min?: EquipoMinAggregateInputType
    _max?: EquipoMaxAggregateInputType
  }

  export type EquipoGroupByOutputType = {
    id: number
    nombre_equipo: string
    url_logo: string
    estado: $Enums.Estado
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: EquipoCountAggregateOutputType | null
    _avg: EquipoAvgAggregateOutputType | null
    _sum: EquipoSumAggregateOutputType | null
    _min: EquipoMinAggregateOutputType | null
    _max: EquipoMaxAggregateOutputType | null
  }

  type GetEquipoGroupByPayload<T extends EquipoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipoGroupByOutputType[P]>
            : GetScalarType<T[P], EquipoGroupByOutputType[P]>
        }
      >
    >


  export type EquipoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_equipo?: boolean
    url_logo?: boolean
    estado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Estudiante?: boolean | Equipo$EstudianteArgs<ExtArgs>
    Videojuego?: boolean | Equipo$VideojuegoArgs<ExtArgs>
    _count?: boolean | EquipoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipo"]>

  export type EquipoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_equipo?: boolean
    url_logo?: boolean
    estado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["equipo"]>

  export type EquipoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_equipo?: boolean
    url_logo?: boolean
    estado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["equipo"]>

  export type EquipoSelectScalar = {
    id?: boolean
    nombre_equipo?: boolean
    url_logo?: boolean
    estado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type EquipoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_equipo" | "url_logo" | "estado" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["equipo"]>
  export type EquipoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Estudiante?: boolean | Equipo$EstudianteArgs<ExtArgs>
    Videojuego?: boolean | Equipo$VideojuegoArgs<ExtArgs>
    _count?: boolean | EquipoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EquipoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipo"
    objects: {
      Estudiante: Prisma.$EstudiantePayload<ExtArgs>[]
      Videojuego: Prisma.$VideojuegoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_equipo: string
      url_logo: string
      estado: $Enums.Estado
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["equipo"]>
    composites: {}
  }

  type EquipoGetPayload<S extends boolean | null | undefined | EquipoDefaultArgs> = $Result.GetResult<Prisma.$EquipoPayload, S>

  type EquipoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipoCountAggregateInputType | true
    }

  export interface EquipoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipo'], meta: { name: 'Equipo' } }
    /**
     * Find zero or one Equipo that matches the filter.
     * @param {EquipoFindUniqueArgs} args - Arguments to find a Equipo
     * @example
     * // Get one Equipo
     * const equipo = await prisma.equipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipoFindUniqueArgs>(args: SelectSubset<T, EquipoFindUniqueArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipoFindUniqueOrThrowArgs} args - Arguments to find a Equipo
     * @example
     * // Get one Equipo
     * const equipo = await prisma.equipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipoFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoFindFirstArgs} args - Arguments to find a Equipo
     * @example
     * // Get one Equipo
     * const equipo = await prisma.equipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipoFindFirstArgs>(args?: SelectSubset<T, EquipoFindFirstArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoFindFirstOrThrowArgs} args - Arguments to find a Equipo
     * @example
     * // Get one Equipo
     * const equipo = await prisma.equipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipoFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipos
     * const equipos = await prisma.equipo.findMany()
     * 
     * // Get first 10 Equipos
     * const equipos = await prisma.equipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipoWithIdOnly = await prisma.equipo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipoFindManyArgs>(args?: SelectSubset<T, EquipoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipo.
     * @param {EquipoCreateArgs} args - Arguments to create a Equipo.
     * @example
     * // Create one Equipo
     * const Equipo = await prisma.equipo.create({
     *   data: {
     *     // ... data to create a Equipo
     *   }
     * })
     * 
     */
    create<T extends EquipoCreateArgs>(args: SelectSubset<T, EquipoCreateArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipos.
     * @param {EquipoCreateManyArgs} args - Arguments to create many Equipos.
     * @example
     * // Create many Equipos
     * const equipo = await prisma.equipo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipoCreateManyArgs>(args?: SelectSubset<T, EquipoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipos and returns the data saved in the database.
     * @param {EquipoCreateManyAndReturnArgs} args - Arguments to create many Equipos.
     * @example
     * // Create many Equipos
     * const equipo = await prisma.equipo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipos and only return the `id`
     * const equipoWithIdOnly = await prisma.equipo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipoCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipo.
     * @param {EquipoDeleteArgs} args - Arguments to delete one Equipo.
     * @example
     * // Delete one Equipo
     * const Equipo = await prisma.equipo.delete({
     *   where: {
     *     // ... filter to delete one Equipo
     *   }
     * })
     * 
     */
    delete<T extends EquipoDeleteArgs>(args: SelectSubset<T, EquipoDeleteArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipo.
     * @param {EquipoUpdateArgs} args - Arguments to update one Equipo.
     * @example
     * // Update one Equipo
     * const equipo = await prisma.equipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipoUpdateArgs>(args: SelectSubset<T, EquipoUpdateArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipos.
     * @param {EquipoDeleteManyArgs} args - Arguments to filter Equipos to delete.
     * @example
     * // Delete a few Equipos
     * const { count } = await prisma.equipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipoDeleteManyArgs>(args?: SelectSubset<T, EquipoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipos
     * const equipo = await prisma.equipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipoUpdateManyArgs>(args: SelectSubset<T, EquipoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipos and returns the data updated in the database.
     * @param {EquipoUpdateManyAndReturnArgs} args - Arguments to update many Equipos.
     * @example
     * // Update many Equipos
     * const equipo = await prisma.equipo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipos and only return the `id`
     * const equipoWithIdOnly = await prisma.equipo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipoUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipo.
     * @param {EquipoUpsertArgs} args - Arguments to update or create a Equipo.
     * @example
     * // Update or create a Equipo
     * const equipo = await prisma.equipo.upsert({
     *   create: {
     *     // ... data to create a Equipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipo we want to update
     *   }
     * })
     */
    upsert<T extends EquipoUpsertArgs>(args: SelectSubset<T, EquipoUpsertArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCountArgs} args - Arguments to filter Equipos to count.
     * @example
     * // Count the number of Equipos
     * const count = await prisma.equipo.count({
     *   where: {
     *     // ... the filter for the Equipos we want to count
     *   }
     * })
    **/
    count<T extends EquipoCountArgs>(
      args?: Subset<T, EquipoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipoAggregateArgs>(args: Subset<T, EquipoAggregateArgs>): Prisma.PrismaPromise<GetEquipoAggregateType<T>>

    /**
     * Group by Equipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipoGroupByArgs['orderBy'] }
        : { orderBy?: EquipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipo model
   */
  readonly fields: EquipoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Estudiante<T extends Equipo$EstudianteArgs<ExtArgs> = {}>(args?: Subset<T, Equipo$EstudianteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Videojuego<T extends Equipo$VideojuegoArgs<ExtArgs> = {}>(args?: Subset<T, Equipo$VideojuegoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipo model
   */
  interface EquipoFieldRefs {
    readonly id: FieldRef<"Equipo", 'Int'>
    readonly nombre_equipo: FieldRef<"Equipo", 'String'>
    readonly url_logo: FieldRef<"Equipo", 'String'>
    readonly estado: FieldRef<"Equipo", 'Estado'>
    readonly create_at: FieldRef<"Equipo", 'DateTime'>
    readonly update_at: FieldRef<"Equipo", 'DateTime'>
    readonly deleted: FieldRef<"Equipo", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Equipo findUnique
   */
  export type EquipoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * Filter, which Equipo to fetch.
     */
    where: EquipoWhereUniqueInput
  }

  /**
   * Equipo findUniqueOrThrow
   */
  export type EquipoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * Filter, which Equipo to fetch.
     */
    where: EquipoWhereUniqueInput
  }

  /**
   * Equipo findFirst
   */
  export type EquipoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * Filter, which Equipo to fetch.
     */
    where?: EquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipos to fetch.
     */
    orderBy?: EquipoOrderByWithRelationInput | EquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipos.
     */
    cursor?: EquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipos.
     */
    distinct?: EquipoScalarFieldEnum | EquipoScalarFieldEnum[]
  }

  /**
   * Equipo findFirstOrThrow
   */
  export type EquipoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * Filter, which Equipo to fetch.
     */
    where?: EquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipos to fetch.
     */
    orderBy?: EquipoOrderByWithRelationInput | EquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipos.
     */
    cursor?: EquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipos.
     */
    distinct?: EquipoScalarFieldEnum | EquipoScalarFieldEnum[]
  }

  /**
   * Equipo findMany
   */
  export type EquipoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * Filter, which Equipos to fetch.
     */
    where?: EquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipos to fetch.
     */
    orderBy?: EquipoOrderByWithRelationInput | EquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipos.
     */
    cursor?: EquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipos.
     */
    skip?: number
    distinct?: EquipoScalarFieldEnum | EquipoScalarFieldEnum[]
  }

  /**
   * Equipo create
   */
  export type EquipoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipo.
     */
    data: XOR<EquipoCreateInput, EquipoUncheckedCreateInput>
  }

  /**
   * Equipo createMany
   */
  export type EquipoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipos.
     */
    data: EquipoCreateManyInput | EquipoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipo createManyAndReturn
   */
  export type EquipoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * The data used to create many Equipos.
     */
    data: EquipoCreateManyInput | EquipoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipo update
   */
  export type EquipoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipo.
     */
    data: XOR<EquipoUpdateInput, EquipoUncheckedUpdateInput>
    /**
     * Choose, which Equipo to update.
     */
    where: EquipoWhereUniqueInput
  }

  /**
   * Equipo updateMany
   */
  export type EquipoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipos.
     */
    data: XOR<EquipoUpdateManyMutationInput, EquipoUncheckedUpdateManyInput>
    /**
     * Filter which Equipos to update
     */
    where?: EquipoWhereInput
    /**
     * Limit how many Equipos to update.
     */
    limit?: number
  }

  /**
   * Equipo updateManyAndReturn
   */
  export type EquipoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * The data used to update Equipos.
     */
    data: XOR<EquipoUpdateManyMutationInput, EquipoUncheckedUpdateManyInput>
    /**
     * Filter which Equipos to update
     */
    where?: EquipoWhereInput
    /**
     * Limit how many Equipos to update.
     */
    limit?: number
  }

  /**
   * Equipo upsert
   */
  export type EquipoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipo to update in case it exists.
     */
    where: EquipoWhereUniqueInput
    /**
     * In case the Equipo found by the `where` argument doesn't exist, create a new Equipo with this data.
     */
    create: XOR<EquipoCreateInput, EquipoUncheckedCreateInput>
    /**
     * In case the Equipo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipoUpdateInput, EquipoUncheckedUpdateInput>
  }

  /**
   * Equipo delete
   */
  export type EquipoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
    /**
     * Filter which Equipo to delete.
     */
    where: EquipoWhereUniqueInput
  }

  /**
   * Equipo deleteMany
   */
  export type EquipoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipos to delete
     */
    where?: EquipoWhereInput
    /**
     * Limit how many Equipos to delete.
     */
    limit?: number
  }

  /**
   * Equipo.Estudiante
   */
  export type Equipo$EstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    cursor?: EstudianteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Equipo.Videojuego
   */
  export type Equipo$VideojuegoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    where?: VideojuegoWhereInput
    orderBy?: VideojuegoOrderByWithRelationInput | VideojuegoOrderByWithRelationInput[]
    cursor?: VideojuegoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideojuegoScalarFieldEnum | VideojuegoScalarFieldEnum[]
  }

  /**
   * Equipo without action
   */
  export type EquipoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipo
     */
    select?: EquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipo
     */
    omit?: EquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoInclude<ExtArgs> | null
  }


  /**
   * Model Estudiante
   */

  export type AggregateEstudiante = {
    _count: EstudianteCountAggregateOutputType | null
    _avg: EstudianteAvgAggregateOutputType | null
    _sum: EstudianteSumAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  export type EstudianteAvgAggregateOutputType = {
    id: number | null
    equipo_id: number | null
    id_user: number | null
  }

  export type EstudianteSumAggregateOutputType = {
    id: number | null
    equipo_id: number | null
    id_user: number | null
  }

  export type EstudianteMinAggregateOutputType = {
    id: number | null
    equipo_id: number | null
    id_user: number | null
    github: string | null
    confirmado: boolean | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EstudianteMaxAggregateOutputType = {
    id: number | null
    equipo_id: number | null
    id_user: number | null
    github: string | null
    confirmado: boolean | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EstudianteCountAggregateOutputType = {
    id: number
    equipo_id: number
    id_user: number
    github: number
    confirmado: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type EstudianteAvgAggregateInputType = {
    id?: true
    equipo_id?: true
    id_user?: true
  }

  export type EstudianteSumAggregateInputType = {
    id?: true
    equipo_id?: true
    id_user?: true
  }

  export type EstudianteMinAggregateInputType = {
    id?: true
    equipo_id?: true
    id_user?: true
    github?: true
    confirmado?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EstudianteMaxAggregateInputType = {
    id?: true
    equipo_id?: true
    id_user?: true
    github?: true
    confirmado?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EstudianteCountAggregateInputType = {
    id?: true
    equipo_id?: true
    id_user?: true
    github?: true
    confirmado?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type EstudianteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiante to aggregate.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estudiantes
    **/
    _count?: true | EstudianteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudianteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudianteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudianteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudianteMaxAggregateInputType
  }

  export type GetEstudianteAggregateType<T extends EstudianteAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiante[P]>
      : GetScalarType<T[P], AggregateEstudiante[P]>
  }




  export type EstudianteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteWhereInput
    orderBy?: EstudianteOrderByWithAggregationInput | EstudianteOrderByWithAggregationInput[]
    by: EstudianteScalarFieldEnum[] | EstudianteScalarFieldEnum
    having?: EstudianteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudianteCountAggregateInputType | true
    _avg?: EstudianteAvgAggregateInputType
    _sum?: EstudianteSumAggregateInputType
    _min?: EstudianteMinAggregateInputType
    _max?: EstudianteMaxAggregateInputType
  }

  export type EstudianteGroupByOutputType = {
    id: number
    equipo_id: number
    id_user: number
    github: string
    confirmado: boolean
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: EstudianteCountAggregateOutputType | null
    _avg: EstudianteAvgAggregateOutputType | null
    _sum: EstudianteSumAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  type GetEstudianteGroupByPayload<T extends EstudianteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudianteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudianteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
            : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
        }
      >
    >


  export type EstudianteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipo_id?: boolean
    id_user?: boolean
    github?: boolean
    confirmado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    EstudianteNRC?: boolean | Estudiante$EstudianteNRCArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipo_id?: boolean
    id_user?: boolean
    github?: boolean
    confirmado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipo_id?: boolean
    id_user?: boolean
    github?: boolean
    confirmado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectScalar = {
    id?: boolean
    equipo_id?: boolean
    id_user?: boolean
    github?: boolean
    confirmado?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type EstudianteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipo_id" | "id_user" | "github" | "confirmado" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["estudiante"]>
  export type EstudianteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    EstudianteNRC?: boolean | Estudiante$EstudianteNRCArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EstudianteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type EstudianteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EstudiantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estudiante"
    objects: {
      Equipo: Prisma.$EquipoPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      EstudianteNRC: Prisma.$EstudianteNRCPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      equipo_id: number
      id_user: number
      github: string
      confirmado: boolean
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["estudiante"]>
    composites: {}
  }

  type EstudianteGetPayload<S extends boolean | null | undefined | EstudianteDefaultArgs> = $Result.GetResult<Prisma.$EstudiantePayload, S>

  type EstudianteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EstudianteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstudianteCountAggregateInputType | true
    }

  export interface EstudianteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estudiante'], meta: { name: 'Estudiante' } }
    /**
     * Find zero or one Estudiante that matches the filter.
     * @param {EstudianteFindUniqueArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudianteFindUniqueArgs>(args: SelectSubset<T, EstudianteFindUniqueArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estudiante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EstudianteFindUniqueOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudianteFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudianteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudianteFindFirstArgs>(args?: SelectSubset<T, EstudianteFindFirstArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudianteFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudianteFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiante.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstudianteFindManyArgs>(args?: SelectSubset<T, EstudianteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estudiante.
     * @param {EstudianteCreateArgs} args - Arguments to create a Estudiante.
     * @example
     * // Create one Estudiante
     * const Estudiante = await prisma.estudiante.create({
     *   data: {
     *     // ... data to create a Estudiante
     *   }
     * })
     * 
     */
    create<T extends EstudianteCreateArgs>(args: SelectSubset<T, EstudianteCreateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estudiantes.
     * @param {EstudianteCreateManyArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudianteCreateManyArgs>(args?: SelectSubset<T, EstudianteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estudiantes and returns the data saved in the database.
     * @param {EstudianteCreateManyAndReturnArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstudianteCreateManyAndReturnArgs>(args?: SelectSubset<T, EstudianteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estudiante.
     * @param {EstudianteDeleteArgs} args - Arguments to delete one Estudiante.
     * @example
     * // Delete one Estudiante
     * const Estudiante = await prisma.estudiante.delete({
     *   where: {
     *     // ... filter to delete one Estudiante
     *   }
     * })
     * 
     */
    delete<T extends EstudianteDeleteArgs>(args: SelectSubset<T, EstudianteDeleteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estudiante.
     * @param {EstudianteUpdateArgs} args - Arguments to update one Estudiante.
     * @example
     * // Update one Estudiante
     * const estudiante = await prisma.estudiante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudianteUpdateArgs>(args: SelectSubset<T, EstudianteUpdateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estudiantes.
     * @param {EstudianteDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudianteDeleteManyArgs>(args?: SelectSubset<T, EstudianteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudianteUpdateManyArgs>(args: SelectSubset<T, EstudianteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes and returns the data updated in the database.
     * @param {EstudianteUpdateManyAndReturnArgs} args - Arguments to update many Estudiantes.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EstudianteUpdateManyAndReturnArgs>(args: SelectSubset<T, EstudianteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estudiante.
     * @param {EstudianteUpsertArgs} args - Arguments to update or create a Estudiante.
     * @example
     * // Update or create a Estudiante
     * const estudiante = await prisma.estudiante.upsert({
     *   create: {
     *     // ... data to create a Estudiante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiante we want to update
     *   }
     * })
     */
    upsert<T extends EstudianteUpsertArgs>(args: SelectSubset<T, EstudianteUpsertArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiante.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends EstudianteCountArgs>(
      args?: Subset<T, EstudianteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudianteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudianteAggregateArgs>(args: Subset<T, EstudianteAggregateArgs>): Prisma.PrismaPromise<GetEstudianteAggregateType<T>>

    /**
     * Group by Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudianteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudianteGroupByArgs['orderBy'] }
        : { orderBy?: EstudianteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudianteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudianteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estudiante model
   */
  readonly fields: EstudianteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estudiante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudianteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipo<T extends EquipoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipoDefaultArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    EstudianteNRC<T extends Estudiante$EstudianteNRCArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$EstudianteNRCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estudiante model
   */
  interface EstudianteFieldRefs {
    readonly id: FieldRef<"Estudiante", 'Int'>
    readonly equipo_id: FieldRef<"Estudiante", 'Int'>
    readonly id_user: FieldRef<"Estudiante", 'Int'>
    readonly github: FieldRef<"Estudiante", 'String'>
    readonly confirmado: FieldRef<"Estudiante", 'Boolean'>
    readonly create_at: FieldRef<"Estudiante", 'DateTime'>
    readonly update_at: FieldRef<"Estudiante", 'DateTime'>
    readonly deleted: FieldRef<"Estudiante", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Estudiante findUnique
   */
  export type EstudianteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findUniqueOrThrow
   */
  export type EstudianteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findFirst
   */
  export type EstudianteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findFirstOrThrow
   */
  export type EstudianteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findMany
   */
  export type EstudianteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiantes to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante create
   */
  export type EstudianteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to create a Estudiante.
     */
    data: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
  }

  /**
   * Estudiante createMany
   */
  export type EstudianteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estudiante createManyAndReturn
   */
  export type EstudianteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estudiante update
   */
  export type EstudianteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to update a Estudiante.
     */
    data: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
    /**
     * Choose, which Estudiante to update.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante updateMany
   */
  export type EstudianteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to update.
     */
    limit?: number
  }

  /**
   * Estudiante updateManyAndReturn
   */
  export type EstudianteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estudiante upsert
   */
  export type EstudianteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The filter to search for the Estudiante to update in case it exists.
     */
    where: EstudianteWhereUniqueInput
    /**
     * In case the Estudiante found by the `where` argument doesn't exist, create a new Estudiante with this data.
     */
    create: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
    /**
     * In case the Estudiante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
  }

  /**
   * Estudiante delete
   */
  export type EstudianteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter which Estudiante to delete.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante deleteMany
   */
  export type EstudianteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiantes to delete
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to delete.
     */
    limit?: number
  }

  /**
   * Estudiante.EstudianteNRC
   */
  export type Estudiante$EstudianteNRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    where?: EstudianteNRCWhereInput
    orderBy?: EstudianteNRCOrderByWithRelationInput | EstudianteNRCOrderByWithRelationInput[]
    cursor?: EstudianteNRCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudianteNRCScalarFieldEnum | EstudianteNRCScalarFieldEnum[]
  }

  /**
   * Estudiante without action
   */
  export type EstudianteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
  }


  /**
   * Model EstudianteNRC
   */

  export type AggregateEstudianteNRC = {
    _count: EstudianteNRCCountAggregateOutputType | null
    _avg: EstudianteNRCAvgAggregateOutputType | null
    _sum: EstudianteNRCSumAggregateOutputType | null
    _min: EstudianteNRCMinAggregateOutputType | null
    _max: EstudianteNRCMaxAggregateOutputType | null
  }

  export type EstudianteNRCAvgAggregateOutputType = {
    id_nrc: number | null
    id_estudiante: number | null
  }

  export type EstudianteNRCSumAggregateOutputType = {
    id_nrc: number | null
    id_estudiante: number | null
  }

  export type EstudianteNRCMinAggregateOutputType = {
    id_nrc: number | null
    id_estudiante: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type EstudianteNRCMaxAggregateOutputType = {
    id_nrc: number | null
    id_estudiante: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type EstudianteNRCCountAggregateOutputType = {
    id_nrc: number
    id_estudiante: number
    create_at: number
    deleted: number
    _all: number
  }


  export type EstudianteNRCAvgAggregateInputType = {
    id_nrc?: true
    id_estudiante?: true
  }

  export type EstudianteNRCSumAggregateInputType = {
    id_nrc?: true
    id_estudiante?: true
  }

  export type EstudianteNRCMinAggregateInputType = {
    id_nrc?: true
    id_estudiante?: true
    create_at?: true
    deleted?: true
  }

  export type EstudianteNRCMaxAggregateInputType = {
    id_nrc?: true
    id_estudiante?: true
    create_at?: true
    deleted?: true
  }

  export type EstudianteNRCCountAggregateInputType = {
    id_nrc?: true
    id_estudiante?: true
    create_at?: true
    deleted?: true
    _all?: true
  }

  export type EstudianteNRCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstudianteNRC to aggregate.
     */
    where?: EstudianteNRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudianteNRCS to fetch.
     */
    orderBy?: EstudianteNRCOrderByWithRelationInput | EstudianteNRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudianteNRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudianteNRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudianteNRCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstudianteNRCS
    **/
    _count?: true | EstudianteNRCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudianteNRCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudianteNRCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudianteNRCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudianteNRCMaxAggregateInputType
  }

  export type GetEstudianteNRCAggregateType<T extends EstudianteNRCAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudianteNRC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudianteNRC[P]>
      : GetScalarType<T[P], AggregateEstudianteNRC[P]>
  }




  export type EstudianteNRCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteNRCWhereInput
    orderBy?: EstudianteNRCOrderByWithAggregationInput | EstudianteNRCOrderByWithAggregationInput[]
    by: EstudianteNRCScalarFieldEnum[] | EstudianteNRCScalarFieldEnum
    having?: EstudianteNRCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudianteNRCCountAggregateInputType | true
    _avg?: EstudianteNRCAvgAggregateInputType
    _sum?: EstudianteNRCSumAggregateInputType
    _min?: EstudianteNRCMinAggregateInputType
    _max?: EstudianteNRCMaxAggregateInputType
  }

  export type EstudianteNRCGroupByOutputType = {
    id_nrc: number
    id_estudiante: number
    create_at: Date
    deleted: boolean
    _count: EstudianteNRCCountAggregateOutputType | null
    _avg: EstudianteNRCAvgAggregateOutputType | null
    _sum: EstudianteNRCSumAggregateOutputType | null
    _min: EstudianteNRCMinAggregateOutputType | null
    _max: EstudianteNRCMaxAggregateOutputType | null
  }

  type GetEstudianteNRCGroupByPayload<T extends EstudianteNRCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudianteNRCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudianteNRCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudianteNRCGroupByOutputType[P]>
            : GetScalarType<T[P], EstudianteNRCGroupByOutputType[P]>
        }
      >
    >


  export type EstudianteNRCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_nrc?: boolean
    id_estudiante?: boolean
    create_at?: boolean
    deleted?: boolean
    Estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    NRC?: boolean | NRCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudianteNRC"]>

  export type EstudianteNRCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_nrc?: boolean
    id_estudiante?: boolean
    create_at?: boolean
    deleted?: boolean
    Estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    NRC?: boolean | NRCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudianteNRC"]>

  export type EstudianteNRCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_nrc?: boolean
    id_estudiante?: boolean
    create_at?: boolean
    deleted?: boolean
    Estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    NRC?: boolean | NRCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudianteNRC"]>

  export type EstudianteNRCSelectScalar = {
    id_nrc?: boolean
    id_estudiante?: boolean
    create_at?: boolean
    deleted?: boolean
  }

  export type EstudianteNRCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_nrc" | "id_estudiante" | "create_at" | "deleted", ExtArgs["result"]["estudianteNRC"]>
  export type EstudianteNRCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    NRC?: boolean | NRCDefaultArgs<ExtArgs>
  }
  export type EstudianteNRCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    NRC?: boolean | NRCDefaultArgs<ExtArgs>
  }
  export type EstudianteNRCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    NRC?: boolean | NRCDefaultArgs<ExtArgs>
  }

  export type $EstudianteNRCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EstudianteNRC"
    objects: {
      Estudiante: Prisma.$EstudiantePayload<ExtArgs>
      NRC: Prisma.$NRCPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_nrc: number
      id_estudiante: number
      create_at: Date
      deleted: boolean
    }, ExtArgs["result"]["estudianteNRC"]>
    composites: {}
  }

  type EstudianteNRCGetPayload<S extends boolean | null | undefined | EstudianteNRCDefaultArgs> = $Result.GetResult<Prisma.$EstudianteNRCPayload, S>

  type EstudianteNRCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EstudianteNRCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstudianteNRCCountAggregateInputType | true
    }

  export interface EstudianteNRCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EstudianteNRC'], meta: { name: 'EstudianteNRC' } }
    /**
     * Find zero or one EstudianteNRC that matches the filter.
     * @param {EstudianteNRCFindUniqueArgs} args - Arguments to find a EstudianteNRC
     * @example
     * // Get one EstudianteNRC
     * const estudianteNRC = await prisma.estudianteNRC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudianteNRCFindUniqueArgs>(args: SelectSubset<T, EstudianteNRCFindUniqueArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EstudianteNRC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EstudianteNRCFindUniqueOrThrowArgs} args - Arguments to find a EstudianteNRC
     * @example
     * // Get one EstudianteNRC
     * const estudianteNRC = await prisma.estudianteNRC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudianteNRCFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudianteNRCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EstudianteNRC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCFindFirstArgs} args - Arguments to find a EstudianteNRC
     * @example
     * // Get one EstudianteNRC
     * const estudianteNRC = await prisma.estudianteNRC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudianteNRCFindFirstArgs>(args?: SelectSubset<T, EstudianteNRCFindFirstArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EstudianteNRC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCFindFirstOrThrowArgs} args - Arguments to find a EstudianteNRC
     * @example
     * // Get one EstudianteNRC
     * const estudianteNRC = await prisma.estudianteNRC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudianteNRCFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudianteNRCFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EstudianteNRCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstudianteNRCS
     * const estudianteNRCS = await prisma.estudianteNRC.findMany()
     * 
     * // Get first 10 EstudianteNRCS
     * const estudianteNRCS = await prisma.estudianteNRC.findMany({ take: 10 })
     * 
     * // Only select the `id_nrc`
     * const estudianteNRCWithId_nrcOnly = await prisma.estudianteNRC.findMany({ select: { id_nrc: true } })
     * 
     */
    findMany<T extends EstudianteNRCFindManyArgs>(args?: SelectSubset<T, EstudianteNRCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EstudianteNRC.
     * @param {EstudianteNRCCreateArgs} args - Arguments to create a EstudianteNRC.
     * @example
     * // Create one EstudianteNRC
     * const EstudianteNRC = await prisma.estudianteNRC.create({
     *   data: {
     *     // ... data to create a EstudianteNRC
     *   }
     * })
     * 
     */
    create<T extends EstudianteNRCCreateArgs>(args: SelectSubset<T, EstudianteNRCCreateArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EstudianteNRCS.
     * @param {EstudianteNRCCreateManyArgs} args - Arguments to create many EstudianteNRCS.
     * @example
     * // Create many EstudianteNRCS
     * const estudianteNRC = await prisma.estudianteNRC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudianteNRCCreateManyArgs>(args?: SelectSubset<T, EstudianteNRCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EstudianteNRCS and returns the data saved in the database.
     * @param {EstudianteNRCCreateManyAndReturnArgs} args - Arguments to create many EstudianteNRCS.
     * @example
     * // Create many EstudianteNRCS
     * const estudianteNRC = await prisma.estudianteNRC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EstudianteNRCS and only return the `id_nrc`
     * const estudianteNRCWithId_nrcOnly = await prisma.estudianteNRC.createManyAndReturn({
     *   select: { id_nrc: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstudianteNRCCreateManyAndReturnArgs>(args?: SelectSubset<T, EstudianteNRCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EstudianteNRC.
     * @param {EstudianteNRCDeleteArgs} args - Arguments to delete one EstudianteNRC.
     * @example
     * // Delete one EstudianteNRC
     * const EstudianteNRC = await prisma.estudianteNRC.delete({
     *   where: {
     *     // ... filter to delete one EstudianteNRC
     *   }
     * })
     * 
     */
    delete<T extends EstudianteNRCDeleteArgs>(args: SelectSubset<T, EstudianteNRCDeleteArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EstudianteNRC.
     * @param {EstudianteNRCUpdateArgs} args - Arguments to update one EstudianteNRC.
     * @example
     * // Update one EstudianteNRC
     * const estudianteNRC = await prisma.estudianteNRC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudianteNRCUpdateArgs>(args: SelectSubset<T, EstudianteNRCUpdateArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EstudianteNRCS.
     * @param {EstudianteNRCDeleteManyArgs} args - Arguments to filter EstudianteNRCS to delete.
     * @example
     * // Delete a few EstudianteNRCS
     * const { count } = await prisma.estudianteNRC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudianteNRCDeleteManyArgs>(args?: SelectSubset<T, EstudianteNRCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstudianteNRCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstudianteNRCS
     * const estudianteNRC = await prisma.estudianteNRC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudianteNRCUpdateManyArgs>(args: SelectSubset<T, EstudianteNRCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstudianteNRCS and returns the data updated in the database.
     * @param {EstudianteNRCUpdateManyAndReturnArgs} args - Arguments to update many EstudianteNRCS.
     * @example
     * // Update many EstudianteNRCS
     * const estudianteNRC = await prisma.estudianteNRC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EstudianteNRCS and only return the `id_nrc`
     * const estudianteNRCWithId_nrcOnly = await prisma.estudianteNRC.updateManyAndReturn({
     *   select: { id_nrc: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EstudianteNRCUpdateManyAndReturnArgs>(args: SelectSubset<T, EstudianteNRCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EstudianteNRC.
     * @param {EstudianteNRCUpsertArgs} args - Arguments to update or create a EstudianteNRC.
     * @example
     * // Update or create a EstudianteNRC
     * const estudianteNRC = await prisma.estudianteNRC.upsert({
     *   create: {
     *     // ... data to create a EstudianteNRC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstudianteNRC we want to update
     *   }
     * })
     */
    upsert<T extends EstudianteNRCUpsertArgs>(args: SelectSubset<T, EstudianteNRCUpsertArgs<ExtArgs>>): Prisma__EstudianteNRCClient<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EstudianteNRCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCCountArgs} args - Arguments to filter EstudianteNRCS to count.
     * @example
     * // Count the number of EstudianteNRCS
     * const count = await prisma.estudianteNRC.count({
     *   where: {
     *     // ... the filter for the EstudianteNRCS we want to count
     *   }
     * })
    **/
    count<T extends EstudianteNRCCountArgs>(
      args?: Subset<T, EstudianteNRCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudianteNRCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstudianteNRC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudianteNRCAggregateArgs>(args: Subset<T, EstudianteNRCAggregateArgs>): Prisma.PrismaPromise<GetEstudianteNRCAggregateType<T>>

    /**
     * Group by EstudianteNRC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteNRCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudianteNRCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudianteNRCGroupByArgs['orderBy'] }
        : { orderBy?: EstudianteNRCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudianteNRCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudianteNRCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EstudianteNRC model
   */
  readonly fields: EstudianteNRCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EstudianteNRC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudianteNRCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    NRC<T extends NRCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NRCDefaultArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EstudianteNRC model
   */
  interface EstudianteNRCFieldRefs {
    readonly id_nrc: FieldRef<"EstudianteNRC", 'Int'>
    readonly id_estudiante: FieldRef<"EstudianteNRC", 'Int'>
    readonly create_at: FieldRef<"EstudianteNRC", 'DateTime'>
    readonly deleted: FieldRef<"EstudianteNRC", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EstudianteNRC findUnique
   */
  export type EstudianteNRCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * Filter, which EstudianteNRC to fetch.
     */
    where: EstudianteNRCWhereUniqueInput
  }

  /**
   * EstudianteNRC findUniqueOrThrow
   */
  export type EstudianteNRCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * Filter, which EstudianteNRC to fetch.
     */
    where: EstudianteNRCWhereUniqueInput
  }

  /**
   * EstudianteNRC findFirst
   */
  export type EstudianteNRCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * Filter, which EstudianteNRC to fetch.
     */
    where?: EstudianteNRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudianteNRCS to fetch.
     */
    orderBy?: EstudianteNRCOrderByWithRelationInput | EstudianteNRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstudianteNRCS.
     */
    cursor?: EstudianteNRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudianteNRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudianteNRCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstudianteNRCS.
     */
    distinct?: EstudianteNRCScalarFieldEnum | EstudianteNRCScalarFieldEnum[]
  }

  /**
   * EstudianteNRC findFirstOrThrow
   */
  export type EstudianteNRCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * Filter, which EstudianteNRC to fetch.
     */
    where?: EstudianteNRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudianteNRCS to fetch.
     */
    orderBy?: EstudianteNRCOrderByWithRelationInput | EstudianteNRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstudianteNRCS.
     */
    cursor?: EstudianteNRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudianteNRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudianteNRCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstudianteNRCS.
     */
    distinct?: EstudianteNRCScalarFieldEnum | EstudianteNRCScalarFieldEnum[]
  }

  /**
   * EstudianteNRC findMany
   */
  export type EstudianteNRCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * Filter, which EstudianteNRCS to fetch.
     */
    where?: EstudianteNRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudianteNRCS to fetch.
     */
    orderBy?: EstudianteNRCOrderByWithRelationInput | EstudianteNRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstudianteNRCS.
     */
    cursor?: EstudianteNRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudianteNRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudianteNRCS.
     */
    skip?: number
    distinct?: EstudianteNRCScalarFieldEnum | EstudianteNRCScalarFieldEnum[]
  }

  /**
   * EstudianteNRC create
   */
  export type EstudianteNRCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * The data needed to create a EstudianteNRC.
     */
    data: XOR<EstudianteNRCCreateInput, EstudianteNRCUncheckedCreateInput>
  }

  /**
   * EstudianteNRC createMany
   */
  export type EstudianteNRCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EstudianteNRCS.
     */
    data: EstudianteNRCCreateManyInput | EstudianteNRCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EstudianteNRC createManyAndReturn
   */
  export type EstudianteNRCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * The data used to create many EstudianteNRCS.
     */
    data: EstudianteNRCCreateManyInput | EstudianteNRCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EstudianteNRC update
   */
  export type EstudianteNRCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * The data needed to update a EstudianteNRC.
     */
    data: XOR<EstudianteNRCUpdateInput, EstudianteNRCUncheckedUpdateInput>
    /**
     * Choose, which EstudianteNRC to update.
     */
    where: EstudianteNRCWhereUniqueInput
  }

  /**
   * EstudianteNRC updateMany
   */
  export type EstudianteNRCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EstudianteNRCS.
     */
    data: XOR<EstudianteNRCUpdateManyMutationInput, EstudianteNRCUncheckedUpdateManyInput>
    /**
     * Filter which EstudianteNRCS to update
     */
    where?: EstudianteNRCWhereInput
    /**
     * Limit how many EstudianteNRCS to update.
     */
    limit?: number
  }

  /**
   * EstudianteNRC updateManyAndReturn
   */
  export type EstudianteNRCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * The data used to update EstudianteNRCS.
     */
    data: XOR<EstudianteNRCUpdateManyMutationInput, EstudianteNRCUncheckedUpdateManyInput>
    /**
     * Filter which EstudianteNRCS to update
     */
    where?: EstudianteNRCWhereInput
    /**
     * Limit how many EstudianteNRCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EstudianteNRC upsert
   */
  export type EstudianteNRCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * The filter to search for the EstudianteNRC to update in case it exists.
     */
    where: EstudianteNRCWhereUniqueInput
    /**
     * In case the EstudianteNRC found by the `where` argument doesn't exist, create a new EstudianteNRC with this data.
     */
    create: XOR<EstudianteNRCCreateInput, EstudianteNRCUncheckedCreateInput>
    /**
     * In case the EstudianteNRC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudianteNRCUpdateInput, EstudianteNRCUncheckedUpdateInput>
  }

  /**
   * EstudianteNRC delete
   */
  export type EstudianteNRCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    /**
     * Filter which EstudianteNRC to delete.
     */
    where: EstudianteNRCWhereUniqueInput
  }

  /**
   * EstudianteNRC deleteMany
   */
  export type EstudianteNRCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstudianteNRCS to delete
     */
    where?: EstudianteNRCWhereInput
    /**
     * Limit how many EstudianteNRCS to delete.
     */
    limit?: number
  }

  /**
   * EstudianteNRC without action
   */
  export type EstudianteNRCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
  }


  /**
   * Model Evaluacion
   */

  export type AggregateEvaluacion = {
    _count: EvaluacionCountAggregateOutputType | null
    _avg: EvaluacionAvgAggregateOutputType | null
    _sum: EvaluacionSumAggregateOutputType | null
    _min: EvaluacionMinAggregateOutputType | null
    _max: EvaluacionMaxAggregateOutputType | null
  }

  export type EvaluacionAvgAggregateOutputType = {
    id: number | null
    jurado_id: number | null
    videojuego_id: number | null
  }

  export type EvaluacionSumAggregateOutputType = {
    id: number | null
    jurado_id: number | null
    videojuego_id: number | null
  }

  export type EvaluacionMinAggregateOutputType = {
    id: number | null
    jurado_id: number | null
    videojuego_id: number | null
    comentarios: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EvaluacionMaxAggregateOutputType = {
    id: number | null
    jurado_id: number | null
    videojuego_id: number | null
    comentarios: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type EvaluacionCountAggregateOutputType = {
    id: number
    jurado_id: number
    videojuego_id: number
    comentarios: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type EvaluacionAvgAggregateInputType = {
    id?: true
    jurado_id?: true
    videojuego_id?: true
  }

  export type EvaluacionSumAggregateInputType = {
    id?: true
    jurado_id?: true
    videojuego_id?: true
  }

  export type EvaluacionMinAggregateInputType = {
    id?: true
    jurado_id?: true
    videojuego_id?: true
    comentarios?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EvaluacionMaxAggregateInputType = {
    id?: true
    jurado_id?: true
    videojuego_id?: true
    comentarios?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type EvaluacionCountAggregateInputType = {
    id?: true
    jurado_id?: true
    videojuego_id?: true
    comentarios?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type EvaluacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluacion to aggregate.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: EvaluacionOrderByWithRelationInput | EvaluacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluacions
    **/
    _count?: true | EvaluacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluacionMaxAggregateInputType
  }

  export type GetEvaluacionAggregateType<T extends EvaluacionAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluacion[P]>
      : GetScalarType<T[P], AggregateEvaluacion[P]>
  }




  export type EvaluacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionWhereInput
    orderBy?: EvaluacionOrderByWithAggregationInput | EvaluacionOrderByWithAggregationInput[]
    by: EvaluacionScalarFieldEnum[] | EvaluacionScalarFieldEnum
    having?: EvaluacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluacionCountAggregateInputType | true
    _avg?: EvaluacionAvgAggregateInputType
    _sum?: EvaluacionSumAggregateInputType
    _min?: EvaluacionMinAggregateInputType
    _max?: EvaluacionMaxAggregateInputType
  }

  export type EvaluacionGroupByOutputType = {
    id: number
    jurado_id: number
    videojuego_id: number
    comentarios: string
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: EvaluacionCountAggregateOutputType | null
    _avg: EvaluacionAvgAggregateOutputType | null
    _sum: EvaluacionSumAggregateOutputType | null
    _min: EvaluacionMinAggregateOutputType | null
    _max: EvaluacionMaxAggregateOutputType | null
  }

  type GetEvaluacionGroupByPayload<T extends EvaluacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluacionGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluacionGroupByOutputType[P]>
        }
      >
    >


  export type EvaluacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jurado_id?: boolean
    videojuego_id?: boolean
    comentarios?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
    Rubrica?: boolean | Evaluacion$RubricaArgs<ExtArgs>
    _count?: boolean | EvaluacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluacion"]>

  export type EvaluacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jurado_id?: boolean
    videojuego_id?: boolean
    comentarios?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluacion"]>

  export type EvaluacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jurado_id?: boolean
    videojuego_id?: boolean
    comentarios?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluacion"]>

  export type EvaluacionSelectScalar = {
    id?: boolean
    jurado_id?: boolean
    videojuego_id?: boolean
    comentarios?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type EvaluacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jurado_id" | "videojuego_id" | "comentarios" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["evaluacion"]>
  export type EvaluacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
    Rubrica?: boolean | Evaluacion$RubricaArgs<ExtArgs>
    _count?: boolean | EvaluacionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvaluacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }
  export type EvaluacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }

  export type $EvaluacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluacion"
    objects: {
      Jurado: Prisma.$JuradoPayload<ExtArgs>
      Videojuego: Prisma.$VideojuegoPayload<ExtArgs>
      Rubrica: Prisma.$RubricaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jurado_id: number
      videojuego_id: number
      comentarios: string
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["evaluacion"]>
    composites: {}
  }

  type EvaluacionGetPayload<S extends boolean | null | undefined | EvaluacionDefaultArgs> = $Result.GetResult<Prisma.$EvaluacionPayload, S>

  type EvaluacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluacionCountAggregateInputType | true
    }

  export interface EvaluacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluacion'], meta: { name: 'Evaluacion' } }
    /**
     * Find zero or one Evaluacion that matches the filter.
     * @param {EvaluacionFindUniqueArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluacionFindUniqueArgs>(args: SelectSubset<T, EvaluacionFindUniqueArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evaluacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluacionFindUniqueOrThrowArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluacionFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionFindFirstArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluacionFindFirstArgs>(args?: SelectSubset<T, EvaluacionFindFirstArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionFindFirstOrThrowArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluacionFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evaluacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluacions
     * const evaluacions = await prisma.evaluacion.findMany()
     * 
     * // Get first 10 Evaluacions
     * const evaluacions = await prisma.evaluacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluacionWithIdOnly = await prisma.evaluacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluacionFindManyArgs>(args?: SelectSubset<T, EvaluacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evaluacion.
     * @param {EvaluacionCreateArgs} args - Arguments to create a Evaluacion.
     * @example
     * // Create one Evaluacion
     * const Evaluacion = await prisma.evaluacion.create({
     *   data: {
     *     // ... data to create a Evaluacion
     *   }
     * })
     * 
     */
    create<T extends EvaluacionCreateArgs>(args: SelectSubset<T, EvaluacionCreateArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evaluacions.
     * @param {EvaluacionCreateManyArgs} args - Arguments to create many Evaluacions.
     * @example
     * // Create many Evaluacions
     * const evaluacion = await prisma.evaluacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluacionCreateManyArgs>(args?: SelectSubset<T, EvaluacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluacions and returns the data saved in the database.
     * @param {EvaluacionCreateManyAndReturnArgs} args - Arguments to create many Evaluacions.
     * @example
     * // Create many Evaluacions
     * const evaluacion = await prisma.evaluacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluacions and only return the `id`
     * const evaluacionWithIdOnly = await prisma.evaluacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluacionCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evaluacion.
     * @param {EvaluacionDeleteArgs} args - Arguments to delete one Evaluacion.
     * @example
     * // Delete one Evaluacion
     * const Evaluacion = await prisma.evaluacion.delete({
     *   where: {
     *     // ... filter to delete one Evaluacion
     *   }
     * })
     * 
     */
    delete<T extends EvaluacionDeleteArgs>(args: SelectSubset<T, EvaluacionDeleteArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evaluacion.
     * @param {EvaluacionUpdateArgs} args - Arguments to update one Evaluacion.
     * @example
     * // Update one Evaluacion
     * const evaluacion = await prisma.evaluacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluacionUpdateArgs>(args: SelectSubset<T, EvaluacionUpdateArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evaluacions.
     * @param {EvaluacionDeleteManyArgs} args - Arguments to filter Evaluacions to delete.
     * @example
     * // Delete a few Evaluacions
     * const { count } = await prisma.evaluacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluacionDeleteManyArgs>(args?: SelectSubset<T, EvaluacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluacions
     * const evaluacion = await prisma.evaluacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluacionUpdateManyArgs>(args: SelectSubset<T, EvaluacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluacions and returns the data updated in the database.
     * @param {EvaluacionUpdateManyAndReturnArgs} args - Arguments to update many Evaluacions.
     * @example
     * // Update many Evaluacions
     * const evaluacion = await prisma.evaluacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evaluacions and only return the `id`
     * const evaluacionWithIdOnly = await prisma.evaluacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaluacionUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaluacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evaluacion.
     * @param {EvaluacionUpsertArgs} args - Arguments to update or create a Evaluacion.
     * @example
     * // Update or create a Evaluacion
     * const evaluacion = await prisma.evaluacion.upsert({
     *   create: {
     *     // ... data to create a Evaluacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluacion we want to update
     *   }
     * })
     */
    upsert<T extends EvaluacionUpsertArgs>(args: SelectSubset<T, EvaluacionUpsertArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evaluacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionCountArgs} args - Arguments to filter Evaluacions to count.
     * @example
     * // Count the number of Evaluacions
     * const count = await prisma.evaluacion.count({
     *   where: {
     *     // ... the filter for the Evaluacions we want to count
     *   }
     * })
    **/
    count<T extends EvaluacionCountArgs>(
      args?: Subset<T, EvaluacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluacionAggregateArgs>(args: Subset<T, EvaluacionAggregateArgs>): Prisma.PrismaPromise<GetEvaluacionAggregateType<T>>

    /**
     * Group by Evaluacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluacionGroupByArgs['orderBy'] }
        : { orderBy?: EvaluacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluacion model
   */
  readonly fields: EvaluacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Jurado<T extends JuradoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JuradoDefaultArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Videojuego<T extends VideojuegoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideojuegoDefaultArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Rubrica<T extends Evaluacion$RubricaArgs<ExtArgs> = {}>(args?: Subset<T, Evaluacion$RubricaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evaluacion model
   */
  interface EvaluacionFieldRefs {
    readonly id: FieldRef<"Evaluacion", 'Int'>
    readonly jurado_id: FieldRef<"Evaluacion", 'Int'>
    readonly videojuego_id: FieldRef<"Evaluacion", 'Int'>
    readonly comentarios: FieldRef<"Evaluacion", 'String'>
    readonly create_at: FieldRef<"Evaluacion", 'DateTime'>
    readonly update_at: FieldRef<"Evaluacion", 'DateTime'>
    readonly deleted: FieldRef<"Evaluacion", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Evaluacion findUnique
   */
  export type EvaluacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where: EvaluacionWhereUniqueInput
  }

  /**
   * Evaluacion findUniqueOrThrow
   */
  export type EvaluacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where: EvaluacionWhereUniqueInput
  }

  /**
   * Evaluacion findFirst
   */
  export type EvaluacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: EvaluacionOrderByWithRelationInput | EvaluacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluacions.
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluacions.
     */
    distinct?: EvaluacionScalarFieldEnum | EvaluacionScalarFieldEnum[]
  }

  /**
   * Evaluacion findFirstOrThrow
   */
  export type EvaluacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: EvaluacionOrderByWithRelationInput | EvaluacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluacions.
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluacions.
     */
    distinct?: EvaluacionScalarFieldEnum | EvaluacionScalarFieldEnum[]
  }

  /**
   * Evaluacion findMany
   */
  export type EvaluacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * Filter, which Evaluacions to fetch.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: EvaluacionOrderByWithRelationInput | EvaluacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluacions.
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    distinct?: EvaluacionScalarFieldEnum | EvaluacionScalarFieldEnum[]
  }

  /**
   * Evaluacion create
   */
  export type EvaluacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluacion.
     */
    data: XOR<EvaluacionCreateInput, EvaluacionUncheckedCreateInput>
  }

  /**
   * Evaluacion createMany
   */
  export type EvaluacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluacions.
     */
    data: EvaluacionCreateManyInput | EvaluacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluacion createManyAndReturn
   */
  export type EvaluacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * The data used to create many Evaluacions.
     */
    data: EvaluacionCreateManyInput | EvaluacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluacion update
   */
  export type EvaluacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluacion.
     */
    data: XOR<EvaluacionUpdateInput, EvaluacionUncheckedUpdateInput>
    /**
     * Choose, which Evaluacion to update.
     */
    where: EvaluacionWhereUniqueInput
  }

  /**
   * Evaluacion updateMany
   */
  export type EvaluacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluacions.
     */
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyInput>
    /**
     * Filter which Evaluacions to update
     */
    where?: EvaluacionWhereInput
    /**
     * Limit how many Evaluacions to update.
     */
    limit?: number
  }

  /**
   * Evaluacion updateManyAndReturn
   */
  export type EvaluacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * The data used to update Evaluacions.
     */
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyInput>
    /**
     * Filter which Evaluacions to update
     */
    where?: EvaluacionWhereInput
    /**
     * Limit how many Evaluacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluacion upsert
   */
  export type EvaluacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluacion to update in case it exists.
     */
    where: EvaluacionWhereUniqueInput
    /**
     * In case the Evaluacion found by the `where` argument doesn't exist, create a new Evaluacion with this data.
     */
    create: XOR<EvaluacionCreateInput, EvaluacionUncheckedCreateInput>
    /**
     * In case the Evaluacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluacionUpdateInput, EvaluacionUncheckedUpdateInput>
  }

  /**
   * Evaluacion delete
   */
  export type EvaluacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    /**
     * Filter which Evaluacion to delete.
     */
    where: EvaluacionWhereUniqueInput
  }

  /**
   * Evaluacion deleteMany
   */
  export type EvaluacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluacions to delete
     */
    where?: EvaluacionWhereInput
    /**
     * Limit how many Evaluacions to delete.
     */
    limit?: number
  }

  /**
   * Evaluacion.Rubrica
   */
  export type Evaluacion$RubricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    where?: RubricaWhereInput
    orderBy?: RubricaOrderByWithRelationInput | RubricaOrderByWithRelationInput[]
    cursor?: RubricaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RubricaScalarFieldEnum | RubricaScalarFieldEnum[]
  }

  /**
   * Evaluacion without action
   */
  export type EvaluacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
  }


  /**
   * Model Jurado
   */

  export type AggregateJurado = {
    _count: JuradoCountAggregateOutputType | null
    _avg: JuradoAvgAggregateOutputType | null
    _sum: JuradoSumAggregateOutputType | null
    _min: JuradoMinAggregateOutputType | null
    _max: JuradoMaxAggregateOutputType | null
  }

  export type JuradoAvgAggregateOutputType = {
    id: number | null
    id_user: number | null
  }

  export type JuradoSumAggregateOutputType = {
    id: number | null
    id_user: number | null
  }

  export type JuradoMinAggregateOutputType = {
    id: number | null
    id_user: number | null
    estado: $Enums.EstadoJurado | null
    token_confirmacion: string | null
    ultima_conexion: Date | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type JuradoMaxAggregateOutputType = {
    id: number | null
    id_user: number | null
    estado: $Enums.EstadoJurado | null
    token_confirmacion: string | null
    ultima_conexion: Date | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type JuradoCountAggregateOutputType = {
    id: number
    id_user: number
    estado: number
    token_confirmacion: number
    ultima_conexion: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type JuradoAvgAggregateInputType = {
    id?: true
    id_user?: true
  }

  export type JuradoSumAggregateInputType = {
    id?: true
    id_user?: true
  }

  export type JuradoMinAggregateInputType = {
    id?: true
    id_user?: true
    estado?: true
    token_confirmacion?: true
    ultima_conexion?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type JuradoMaxAggregateInputType = {
    id?: true
    id_user?: true
    estado?: true
    token_confirmacion?: true
    ultima_conexion?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type JuradoCountAggregateInputType = {
    id?: true
    id_user?: true
    estado?: true
    token_confirmacion?: true
    ultima_conexion?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type JuradoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jurado to aggregate.
     */
    where?: JuradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jurados to fetch.
     */
    orderBy?: JuradoOrderByWithRelationInput | JuradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JuradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jurados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jurados
    **/
    _count?: true | JuradoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JuradoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JuradoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JuradoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JuradoMaxAggregateInputType
  }

  export type GetJuradoAggregateType<T extends JuradoAggregateArgs> = {
        [P in keyof T & keyof AggregateJurado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJurado[P]>
      : GetScalarType<T[P], AggregateJurado[P]>
  }




  export type JuradoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JuradoWhereInput
    orderBy?: JuradoOrderByWithAggregationInput | JuradoOrderByWithAggregationInput[]
    by: JuradoScalarFieldEnum[] | JuradoScalarFieldEnum
    having?: JuradoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JuradoCountAggregateInputType | true
    _avg?: JuradoAvgAggregateInputType
    _sum?: JuradoSumAggregateInputType
    _min?: JuradoMinAggregateInputType
    _max?: JuradoMaxAggregateInputType
  }

  export type JuradoGroupByOutputType = {
    id: number
    id_user: number
    estado: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: JuradoCountAggregateOutputType | null
    _avg: JuradoAvgAggregateOutputType | null
    _sum: JuradoSumAggregateOutputType | null
    _min: JuradoMinAggregateOutputType | null
    _max: JuradoMaxAggregateOutputType | null
  }

  type GetJuradoGroupByPayload<T extends JuradoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JuradoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JuradoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JuradoGroupByOutputType[P]>
            : GetScalarType<T[P], JuradoGroupByOutputType[P]>
        }
      >
    >


  export type JuradoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_user?: boolean
    estado?: boolean
    token_confirmacion?: boolean
    ultima_conexion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Evaluacion?: boolean | Jurado$EvaluacionArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    VideojuegoAsignado?: boolean | Jurado$VideojuegoAsignadoArgs<ExtArgs>
    _count?: boolean | JuradoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jurado"]>

  export type JuradoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_user?: boolean
    estado?: boolean
    token_confirmacion?: boolean
    ultima_conexion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jurado"]>

  export type JuradoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_user?: boolean
    estado?: boolean
    token_confirmacion?: boolean
    ultima_conexion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jurado"]>

  export type JuradoSelectScalar = {
    id?: boolean
    id_user?: boolean
    estado?: boolean
    token_confirmacion?: boolean
    ultima_conexion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type JuradoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_user" | "estado" | "token_confirmacion" | "ultima_conexion" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["jurado"]>
  export type JuradoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Evaluacion?: boolean | Jurado$EvaluacionArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    VideojuegoAsignado?: boolean | Jurado$VideojuegoAsignadoArgs<ExtArgs>
    _count?: boolean | JuradoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JuradoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type JuradoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $JuradoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jurado"
    objects: {
      Evaluacion: Prisma.$EvaluacionPayload<ExtArgs>[]
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      VideojuegoAsignado: Prisma.$VideojuegoAsignadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_user: number
      estado: $Enums.EstadoJurado
      token_confirmacion: string
      ultima_conexion: Date
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["jurado"]>
    composites: {}
  }

  type JuradoGetPayload<S extends boolean | null | undefined | JuradoDefaultArgs> = $Result.GetResult<Prisma.$JuradoPayload, S>

  type JuradoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JuradoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JuradoCountAggregateInputType | true
    }

  export interface JuradoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jurado'], meta: { name: 'Jurado' } }
    /**
     * Find zero or one Jurado that matches the filter.
     * @param {JuradoFindUniqueArgs} args - Arguments to find a Jurado
     * @example
     * // Get one Jurado
     * const jurado = await prisma.jurado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JuradoFindUniqueArgs>(args: SelectSubset<T, JuradoFindUniqueArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jurado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JuradoFindUniqueOrThrowArgs} args - Arguments to find a Jurado
     * @example
     * // Get one Jurado
     * const jurado = await prisma.jurado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JuradoFindUniqueOrThrowArgs>(args: SelectSubset<T, JuradoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jurado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoFindFirstArgs} args - Arguments to find a Jurado
     * @example
     * // Get one Jurado
     * const jurado = await prisma.jurado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JuradoFindFirstArgs>(args?: SelectSubset<T, JuradoFindFirstArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jurado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoFindFirstOrThrowArgs} args - Arguments to find a Jurado
     * @example
     * // Get one Jurado
     * const jurado = await prisma.jurado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JuradoFindFirstOrThrowArgs>(args?: SelectSubset<T, JuradoFindFirstOrThrowArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jurados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jurados
     * const jurados = await prisma.jurado.findMany()
     * 
     * // Get first 10 Jurados
     * const jurados = await prisma.jurado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const juradoWithIdOnly = await prisma.jurado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JuradoFindManyArgs>(args?: SelectSubset<T, JuradoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jurado.
     * @param {JuradoCreateArgs} args - Arguments to create a Jurado.
     * @example
     * // Create one Jurado
     * const Jurado = await prisma.jurado.create({
     *   data: {
     *     // ... data to create a Jurado
     *   }
     * })
     * 
     */
    create<T extends JuradoCreateArgs>(args: SelectSubset<T, JuradoCreateArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jurados.
     * @param {JuradoCreateManyArgs} args - Arguments to create many Jurados.
     * @example
     * // Create many Jurados
     * const jurado = await prisma.jurado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JuradoCreateManyArgs>(args?: SelectSubset<T, JuradoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jurados and returns the data saved in the database.
     * @param {JuradoCreateManyAndReturnArgs} args - Arguments to create many Jurados.
     * @example
     * // Create many Jurados
     * const jurado = await prisma.jurado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jurados and only return the `id`
     * const juradoWithIdOnly = await prisma.jurado.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JuradoCreateManyAndReturnArgs>(args?: SelectSubset<T, JuradoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Jurado.
     * @param {JuradoDeleteArgs} args - Arguments to delete one Jurado.
     * @example
     * // Delete one Jurado
     * const Jurado = await prisma.jurado.delete({
     *   where: {
     *     // ... filter to delete one Jurado
     *   }
     * })
     * 
     */
    delete<T extends JuradoDeleteArgs>(args: SelectSubset<T, JuradoDeleteArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jurado.
     * @param {JuradoUpdateArgs} args - Arguments to update one Jurado.
     * @example
     * // Update one Jurado
     * const jurado = await prisma.jurado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JuradoUpdateArgs>(args: SelectSubset<T, JuradoUpdateArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jurados.
     * @param {JuradoDeleteManyArgs} args - Arguments to filter Jurados to delete.
     * @example
     * // Delete a few Jurados
     * const { count } = await prisma.jurado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JuradoDeleteManyArgs>(args?: SelectSubset<T, JuradoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jurados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jurados
     * const jurado = await prisma.jurado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JuradoUpdateManyArgs>(args: SelectSubset<T, JuradoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jurados and returns the data updated in the database.
     * @param {JuradoUpdateManyAndReturnArgs} args - Arguments to update many Jurados.
     * @example
     * // Update many Jurados
     * const jurado = await prisma.jurado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jurados and only return the `id`
     * const juradoWithIdOnly = await prisma.jurado.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JuradoUpdateManyAndReturnArgs>(args: SelectSubset<T, JuradoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Jurado.
     * @param {JuradoUpsertArgs} args - Arguments to update or create a Jurado.
     * @example
     * // Update or create a Jurado
     * const jurado = await prisma.jurado.upsert({
     *   create: {
     *     // ... data to create a Jurado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jurado we want to update
     *   }
     * })
     */
    upsert<T extends JuradoUpsertArgs>(args: SelectSubset<T, JuradoUpsertArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jurados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoCountArgs} args - Arguments to filter Jurados to count.
     * @example
     * // Count the number of Jurados
     * const count = await prisma.jurado.count({
     *   where: {
     *     // ... the filter for the Jurados we want to count
     *   }
     * })
    **/
    count<T extends JuradoCountArgs>(
      args?: Subset<T, JuradoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JuradoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jurado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JuradoAggregateArgs>(args: Subset<T, JuradoAggregateArgs>): Prisma.PrismaPromise<GetJuradoAggregateType<T>>

    /**
     * Group by Jurado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuradoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JuradoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JuradoGroupByArgs['orderBy'] }
        : { orderBy?: JuradoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JuradoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJuradoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jurado model
   */
  readonly fields: JuradoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jurado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JuradoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Evaluacion<T extends Jurado$EvaluacionArgs<ExtArgs> = {}>(args?: Subset<T, Jurado$EvaluacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    VideojuegoAsignado<T extends Jurado$VideojuegoAsignadoArgs<ExtArgs> = {}>(args?: Subset<T, Jurado$VideojuegoAsignadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jurado model
   */
  interface JuradoFieldRefs {
    readonly id: FieldRef<"Jurado", 'Int'>
    readonly id_user: FieldRef<"Jurado", 'Int'>
    readonly estado: FieldRef<"Jurado", 'EstadoJurado'>
    readonly token_confirmacion: FieldRef<"Jurado", 'String'>
    readonly ultima_conexion: FieldRef<"Jurado", 'DateTime'>
    readonly create_at: FieldRef<"Jurado", 'DateTime'>
    readonly update_at: FieldRef<"Jurado", 'DateTime'>
    readonly deleted: FieldRef<"Jurado", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Jurado findUnique
   */
  export type JuradoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * Filter, which Jurado to fetch.
     */
    where: JuradoWhereUniqueInput
  }

  /**
   * Jurado findUniqueOrThrow
   */
  export type JuradoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * Filter, which Jurado to fetch.
     */
    where: JuradoWhereUniqueInput
  }

  /**
   * Jurado findFirst
   */
  export type JuradoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * Filter, which Jurado to fetch.
     */
    where?: JuradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jurados to fetch.
     */
    orderBy?: JuradoOrderByWithRelationInput | JuradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jurados.
     */
    cursor?: JuradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jurados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jurados.
     */
    distinct?: JuradoScalarFieldEnum | JuradoScalarFieldEnum[]
  }

  /**
   * Jurado findFirstOrThrow
   */
  export type JuradoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * Filter, which Jurado to fetch.
     */
    where?: JuradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jurados to fetch.
     */
    orderBy?: JuradoOrderByWithRelationInput | JuradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jurados.
     */
    cursor?: JuradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jurados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jurados.
     */
    distinct?: JuradoScalarFieldEnum | JuradoScalarFieldEnum[]
  }

  /**
   * Jurado findMany
   */
  export type JuradoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * Filter, which Jurados to fetch.
     */
    where?: JuradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jurados to fetch.
     */
    orderBy?: JuradoOrderByWithRelationInput | JuradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jurados.
     */
    cursor?: JuradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jurados.
     */
    skip?: number
    distinct?: JuradoScalarFieldEnum | JuradoScalarFieldEnum[]
  }

  /**
   * Jurado create
   */
  export type JuradoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * The data needed to create a Jurado.
     */
    data: XOR<JuradoCreateInput, JuradoUncheckedCreateInput>
  }

  /**
   * Jurado createMany
   */
  export type JuradoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jurados.
     */
    data: JuradoCreateManyInput | JuradoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jurado createManyAndReturn
   */
  export type JuradoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * The data used to create many Jurados.
     */
    data: JuradoCreateManyInput | JuradoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Jurado update
   */
  export type JuradoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * The data needed to update a Jurado.
     */
    data: XOR<JuradoUpdateInput, JuradoUncheckedUpdateInput>
    /**
     * Choose, which Jurado to update.
     */
    where: JuradoWhereUniqueInput
  }

  /**
   * Jurado updateMany
   */
  export type JuradoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jurados.
     */
    data: XOR<JuradoUpdateManyMutationInput, JuradoUncheckedUpdateManyInput>
    /**
     * Filter which Jurados to update
     */
    where?: JuradoWhereInput
    /**
     * Limit how many Jurados to update.
     */
    limit?: number
  }

  /**
   * Jurado updateManyAndReturn
   */
  export type JuradoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * The data used to update Jurados.
     */
    data: XOR<JuradoUpdateManyMutationInput, JuradoUncheckedUpdateManyInput>
    /**
     * Filter which Jurados to update
     */
    where?: JuradoWhereInput
    /**
     * Limit how many Jurados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Jurado upsert
   */
  export type JuradoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * The filter to search for the Jurado to update in case it exists.
     */
    where: JuradoWhereUniqueInput
    /**
     * In case the Jurado found by the `where` argument doesn't exist, create a new Jurado with this data.
     */
    create: XOR<JuradoCreateInput, JuradoUncheckedCreateInput>
    /**
     * In case the Jurado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JuradoUpdateInput, JuradoUncheckedUpdateInput>
  }

  /**
   * Jurado delete
   */
  export type JuradoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    /**
     * Filter which Jurado to delete.
     */
    where: JuradoWhereUniqueInput
  }

  /**
   * Jurado deleteMany
   */
  export type JuradoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jurados to delete
     */
    where?: JuradoWhereInput
    /**
     * Limit how many Jurados to delete.
     */
    limit?: number
  }

  /**
   * Jurado.Evaluacion
   */
  export type Jurado$EvaluacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    where?: EvaluacionWhereInput
    orderBy?: EvaluacionOrderByWithRelationInput | EvaluacionOrderByWithRelationInput[]
    cursor?: EvaluacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluacionScalarFieldEnum | EvaluacionScalarFieldEnum[]
  }

  /**
   * Jurado.VideojuegoAsignado
   */
  export type Jurado$VideojuegoAsignadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    where?: VideojuegoAsignadoWhereInput
    orderBy?: VideojuegoAsignadoOrderByWithRelationInput | VideojuegoAsignadoOrderByWithRelationInput[]
    cursor?: VideojuegoAsignadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideojuegoAsignadoScalarFieldEnum | VideojuegoAsignadoScalarFieldEnum[]
  }

  /**
   * Jurado without action
   */
  export type JuradoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
  }


  /**
   * Model Materia
   */

  export type AggregateMateria = {
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  export type MateriaAvgAggregateOutputType = {
    id: number | null
  }

  export type MateriaSumAggregateOutputType = {
    id: number | null
  }

  export type MateriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    codigo: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type MateriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    codigo: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type MateriaCountAggregateOutputType = {
    id: number
    nombre: number
    codigo: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type MateriaAvgAggregateInputType = {
    id?: true
  }

  export type MateriaSumAggregateInputType = {
    id?: true
  }

  export type MateriaMinAggregateInputType = {
    id?: true
    nombre?: true
    codigo?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type MateriaMaxAggregateInputType = {
    id?: true
    nombre?: true
    codigo?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type MateriaCountAggregateInputType = {
    id?: true
    nombre?: true
    codigo?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type MateriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materia to aggregate.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materias
    **/
    _count?: true | MateriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MateriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MateriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MateriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MateriaMaxAggregateInputType
  }

  export type GetMateriaAggregateType<T extends MateriaAggregateArgs> = {
        [P in keyof T & keyof AggregateMateria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateria[P]>
      : GetScalarType<T[P], AggregateMateria[P]>
  }




  export type MateriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriaWhereInput
    orderBy?: MateriaOrderByWithAggregationInput | MateriaOrderByWithAggregationInput[]
    by: MateriaScalarFieldEnum[] | MateriaScalarFieldEnum
    having?: MateriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MateriaCountAggregateInputType | true
    _avg?: MateriaAvgAggregateInputType
    _sum?: MateriaSumAggregateInputType
    _min?: MateriaMinAggregateInputType
    _max?: MateriaMaxAggregateInputType
  }

  export type MateriaGroupByOutputType = {
    id: number
    nombre: string
    codigo: string
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  type GetMateriaGroupByPayload<T extends MateriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MateriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MateriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MateriaGroupByOutputType[P]>
            : GetScalarType<T[P], MateriaGroupByOutputType[P]>
        }
      >
    >


  export type MateriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    codigo?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    NRC?: boolean | Materia$NRCArgs<ExtArgs>
    _count?: boolean | MateriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia"]>

  export type MateriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    codigo?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["materia"]>

  export type MateriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    codigo?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["materia"]>

  export type MateriaSelectScalar = {
    id?: boolean
    nombre?: boolean
    codigo?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type MateriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "codigo" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["materia"]>
  export type MateriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NRC?: boolean | Materia$NRCArgs<ExtArgs>
    _count?: boolean | MateriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MateriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MateriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MateriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materia"
    objects: {
      NRC: Prisma.$NRCPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      codigo: string
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["materia"]>
    composites: {}
  }

  type MateriaGetPayload<S extends boolean | null | undefined | MateriaDefaultArgs> = $Result.GetResult<Prisma.$MateriaPayload, S>

  type MateriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MateriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MateriaCountAggregateInputType | true
    }

  export interface MateriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materia'], meta: { name: 'Materia' } }
    /**
     * Find zero or one Materia that matches the filter.
     * @param {MateriaFindUniqueArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MateriaFindUniqueArgs>(args: SelectSubset<T, MateriaFindUniqueArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MateriaFindUniqueOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MateriaFindUniqueOrThrowArgs>(args: SelectSubset<T, MateriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindFirstArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MateriaFindFirstArgs>(args?: SelectSubset<T, MateriaFindFirstArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindFirstOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MateriaFindFirstOrThrowArgs>(args?: SelectSubset<T, MateriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materias
     * const materias = await prisma.materia.findMany()
     * 
     * // Get first 10 Materias
     * const materias = await prisma.materia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materiaWithIdOnly = await prisma.materia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MateriaFindManyArgs>(args?: SelectSubset<T, MateriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materia.
     * @param {MateriaCreateArgs} args - Arguments to create a Materia.
     * @example
     * // Create one Materia
     * const Materia = await prisma.materia.create({
     *   data: {
     *     // ... data to create a Materia
     *   }
     * })
     * 
     */
    create<T extends MateriaCreateArgs>(args: SelectSubset<T, MateriaCreateArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materias.
     * @param {MateriaCreateManyArgs} args - Arguments to create many Materias.
     * @example
     * // Create many Materias
     * const materia = await prisma.materia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MateriaCreateManyArgs>(args?: SelectSubset<T, MateriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materias and returns the data saved in the database.
     * @param {MateriaCreateManyAndReturnArgs} args - Arguments to create many Materias.
     * @example
     * // Create many Materias
     * const materia = await prisma.materia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materias and only return the `id`
     * const materiaWithIdOnly = await prisma.materia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MateriaCreateManyAndReturnArgs>(args?: SelectSubset<T, MateriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Materia.
     * @param {MateriaDeleteArgs} args - Arguments to delete one Materia.
     * @example
     * // Delete one Materia
     * const Materia = await prisma.materia.delete({
     *   where: {
     *     // ... filter to delete one Materia
     *   }
     * })
     * 
     */
    delete<T extends MateriaDeleteArgs>(args: SelectSubset<T, MateriaDeleteArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materia.
     * @param {MateriaUpdateArgs} args - Arguments to update one Materia.
     * @example
     * // Update one Materia
     * const materia = await prisma.materia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MateriaUpdateArgs>(args: SelectSubset<T, MateriaUpdateArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materias.
     * @param {MateriaDeleteManyArgs} args - Arguments to filter Materias to delete.
     * @example
     * // Delete a few Materias
     * const { count } = await prisma.materia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MateriaDeleteManyArgs>(args?: SelectSubset<T, MateriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materias
     * const materia = await prisma.materia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MateriaUpdateManyArgs>(args: SelectSubset<T, MateriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias and returns the data updated in the database.
     * @param {MateriaUpdateManyAndReturnArgs} args - Arguments to update many Materias.
     * @example
     * // Update many Materias
     * const materia = await prisma.materia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materias and only return the `id`
     * const materiaWithIdOnly = await prisma.materia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MateriaUpdateManyAndReturnArgs>(args: SelectSubset<T, MateriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Materia.
     * @param {MateriaUpsertArgs} args - Arguments to update or create a Materia.
     * @example
     * // Update or create a Materia
     * const materia = await prisma.materia.upsert({
     *   create: {
     *     // ... data to create a Materia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materia we want to update
     *   }
     * })
     */
    upsert<T extends MateriaUpsertArgs>(args: SelectSubset<T, MateriaUpsertArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaCountArgs} args - Arguments to filter Materias to count.
     * @example
     * // Count the number of Materias
     * const count = await prisma.materia.count({
     *   where: {
     *     // ... the filter for the Materias we want to count
     *   }
     * })
    **/
    count<T extends MateriaCountArgs>(
      args?: Subset<T, MateriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MateriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MateriaAggregateArgs>(args: Subset<T, MateriaAggregateArgs>): Prisma.PrismaPromise<GetMateriaAggregateType<T>>

    /**
     * Group by Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MateriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MateriaGroupByArgs['orderBy'] }
        : { orderBy?: MateriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MateriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materia model
   */
  readonly fields: MateriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MateriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    NRC<T extends Materia$NRCArgs<ExtArgs> = {}>(args?: Subset<T, Materia$NRCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materia model
   */
  interface MateriaFieldRefs {
    readonly id: FieldRef<"Materia", 'Int'>
    readonly nombre: FieldRef<"Materia", 'String'>
    readonly codigo: FieldRef<"Materia", 'String'>
    readonly create_at: FieldRef<"Materia", 'DateTime'>
    readonly update_at: FieldRef<"Materia", 'DateTime'>
    readonly deleted: FieldRef<"Materia", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Materia findUnique
   */
  export type MateriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia findUniqueOrThrow
   */
  export type MateriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia findFirst
   */
  export type MateriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materias.
     */
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia findFirstOrThrow
   */
  export type MateriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materias.
     */
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia findMany
   */
  export type MateriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materias to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia create
   */
  export type MateriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Materia.
     */
    data: XOR<MateriaCreateInput, MateriaUncheckedCreateInput>
  }

  /**
   * Materia createMany
   */
  export type MateriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materias.
     */
    data: MateriaCreateManyInput | MateriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materia createManyAndReturn
   */
  export type MateriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * The data used to create many Materias.
     */
    data: MateriaCreateManyInput | MateriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materia update
   */
  export type MateriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Materia.
     */
    data: XOR<MateriaUpdateInput, MateriaUncheckedUpdateInput>
    /**
     * Choose, which Materia to update.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia updateMany
   */
  export type MateriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materias.
     */
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyInput>
    /**
     * Filter which Materias to update
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to update.
     */
    limit?: number
  }

  /**
   * Materia updateManyAndReturn
   */
  export type MateriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * The data used to update Materias.
     */
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyInput>
    /**
     * Filter which Materias to update
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to update.
     */
    limit?: number
  }

  /**
   * Materia upsert
   */
  export type MateriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Materia to update in case it exists.
     */
    where: MateriaWhereUniqueInput
    /**
     * In case the Materia found by the `where` argument doesn't exist, create a new Materia with this data.
     */
    create: XOR<MateriaCreateInput, MateriaUncheckedCreateInput>
    /**
     * In case the Materia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MateriaUpdateInput, MateriaUncheckedUpdateInput>
  }

  /**
   * Materia delete
   */
  export type MateriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter which Materia to delete.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia deleteMany
   */
  export type MateriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materias to delete
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to delete.
     */
    limit?: number
  }

  /**
   * Materia.NRC
   */
  export type Materia$NRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    where?: NRCWhereInput
    orderBy?: NRCOrderByWithRelationInput | NRCOrderByWithRelationInput[]
    cursor?: NRCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NRCScalarFieldEnum | NRCScalarFieldEnum[]
  }

  /**
   * Materia without action
   */
  export type MateriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
  }


  /**
   * Model NRC
   */

  export type AggregateNRC = {
    _count: NRCCountAggregateOutputType | null
    _avg: NRCAvgAggregateOutputType | null
    _sum: NRCSumAggregateOutputType | null
    _min: NRCMinAggregateOutputType | null
    _max: NRCMaxAggregateOutputType | null
  }

  export type NRCAvgAggregateOutputType = {
    codigo_nrc: number | null
    materia_id: number | null
    profesor_id: number | null
  }

  export type NRCSumAggregateOutputType = {
    codigo_nrc: number | null
    materia_id: number | null
    profesor_id: number | null
  }

  export type NRCMinAggregateOutputType = {
    codigo_nrc: number | null
    materia_id: number | null
    profesor_id: number | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type NRCMaxAggregateOutputType = {
    codigo_nrc: number | null
    materia_id: number | null
    profesor_id: number | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type NRCCountAggregateOutputType = {
    codigo_nrc: number
    materia_id: number
    profesor_id: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type NRCAvgAggregateInputType = {
    codigo_nrc?: true
    materia_id?: true
    profesor_id?: true
  }

  export type NRCSumAggregateInputType = {
    codigo_nrc?: true
    materia_id?: true
    profesor_id?: true
  }

  export type NRCMinAggregateInputType = {
    codigo_nrc?: true
    materia_id?: true
    profesor_id?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type NRCMaxAggregateInputType = {
    codigo_nrc?: true
    materia_id?: true
    profesor_id?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type NRCCountAggregateInputType = {
    codigo_nrc?: true
    materia_id?: true
    profesor_id?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type NRCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NRC to aggregate.
     */
    where?: NRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRCS to fetch.
     */
    orderBy?: NRCOrderByWithRelationInput | NRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NRCS
    **/
    _count?: true | NRCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NRCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NRCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NRCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NRCMaxAggregateInputType
  }

  export type GetNRCAggregateType<T extends NRCAggregateArgs> = {
        [P in keyof T & keyof AggregateNRC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNRC[P]>
      : GetScalarType<T[P], AggregateNRC[P]>
  }




  export type NRCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NRCWhereInput
    orderBy?: NRCOrderByWithAggregationInput | NRCOrderByWithAggregationInput[]
    by: NRCScalarFieldEnum[] | NRCScalarFieldEnum
    having?: NRCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NRCCountAggregateInputType | true
    _avg?: NRCAvgAggregateInputType
    _sum?: NRCSumAggregateInputType
    _min?: NRCMinAggregateInputType
    _max?: NRCMaxAggregateInputType
  }

  export type NRCGroupByOutputType = {
    codigo_nrc: number
    materia_id: number
    profesor_id: number
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: NRCCountAggregateOutputType | null
    _avg: NRCAvgAggregateOutputType | null
    _sum: NRCSumAggregateOutputType | null
    _min: NRCMinAggregateOutputType | null
    _max: NRCMaxAggregateOutputType | null
  }

  type GetNRCGroupByPayload<T extends NRCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NRCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NRCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NRCGroupByOutputType[P]>
            : GetScalarType<T[P], NRCGroupByOutputType[P]>
        }
      >
    >


  export type NRCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codigo_nrc?: boolean
    materia_id?: boolean
    profesor_id?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    EstudianteNRC?: boolean | NRC$EstudianteNRCArgs<ExtArgs>
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | NRCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nRC"]>

  export type NRCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codigo_nrc?: boolean
    materia_id?: boolean
    profesor_id?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nRC"]>

  export type NRCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codigo_nrc?: boolean
    materia_id?: boolean
    profesor_id?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nRC"]>

  export type NRCSelectScalar = {
    codigo_nrc?: boolean
    materia_id?: boolean
    profesor_id?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type NRCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"codigo_nrc" | "materia_id" | "profesor_id" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["nRC"]>
  export type NRCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EstudianteNRC?: boolean | NRC$EstudianteNRCArgs<ExtArgs>
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | NRCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NRCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type NRCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $NRCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NRC"
    objects: {
      EstudianteNRC: Prisma.$EstudianteNRCPayload<ExtArgs>[]
      Materia: Prisma.$MateriaPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codigo_nrc: number
      materia_id: number
      profesor_id: number
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["nRC"]>
    composites: {}
  }

  type NRCGetPayload<S extends boolean | null | undefined | NRCDefaultArgs> = $Result.GetResult<Prisma.$NRCPayload, S>

  type NRCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NRCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NRCCountAggregateInputType | true
    }

  export interface NRCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NRC'], meta: { name: 'NRC' } }
    /**
     * Find zero or one NRC that matches the filter.
     * @param {NRCFindUniqueArgs} args - Arguments to find a NRC
     * @example
     * // Get one NRC
     * const nRC = await prisma.nRC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NRCFindUniqueArgs>(args: SelectSubset<T, NRCFindUniqueArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NRC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NRCFindUniqueOrThrowArgs} args - Arguments to find a NRC
     * @example
     * // Get one NRC
     * const nRC = await prisma.nRC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NRCFindUniqueOrThrowArgs>(args: SelectSubset<T, NRCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NRC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCFindFirstArgs} args - Arguments to find a NRC
     * @example
     * // Get one NRC
     * const nRC = await prisma.nRC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NRCFindFirstArgs>(args?: SelectSubset<T, NRCFindFirstArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NRC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCFindFirstOrThrowArgs} args - Arguments to find a NRC
     * @example
     * // Get one NRC
     * const nRC = await prisma.nRC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NRCFindFirstOrThrowArgs>(args?: SelectSubset<T, NRCFindFirstOrThrowArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NRCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NRCS
     * const nRCS = await prisma.nRC.findMany()
     * 
     * // Get first 10 NRCS
     * const nRCS = await prisma.nRC.findMany({ take: 10 })
     * 
     * // Only select the `codigo_nrc`
     * const nRCWithCodigo_nrcOnly = await prisma.nRC.findMany({ select: { codigo_nrc: true } })
     * 
     */
    findMany<T extends NRCFindManyArgs>(args?: SelectSubset<T, NRCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NRC.
     * @param {NRCCreateArgs} args - Arguments to create a NRC.
     * @example
     * // Create one NRC
     * const NRC = await prisma.nRC.create({
     *   data: {
     *     // ... data to create a NRC
     *   }
     * })
     * 
     */
    create<T extends NRCCreateArgs>(args: SelectSubset<T, NRCCreateArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NRCS.
     * @param {NRCCreateManyArgs} args - Arguments to create many NRCS.
     * @example
     * // Create many NRCS
     * const nRC = await prisma.nRC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NRCCreateManyArgs>(args?: SelectSubset<T, NRCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NRCS and returns the data saved in the database.
     * @param {NRCCreateManyAndReturnArgs} args - Arguments to create many NRCS.
     * @example
     * // Create many NRCS
     * const nRC = await prisma.nRC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NRCS and only return the `codigo_nrc`
     * const nRCWithCodigo_nrcOnly = await prisma.nRC.createManyAndReturn({
     *   select: { codigo_nrc: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NRCCreateManyAndReturnArgs>(args?: SelectSubset<T, NRCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NRC.
     * @param {NRCDeleteArgs} args - Arguments to delete one NRC.
     * @example
     * // Delete one NRC
     * const NRC = await prisma.nRC.delete({
     *   where: {
     *     // ... filter to delete one NRC
     *   }
     * })
     * 
     */
    delete<T extends NRCDeleteArgs>(args: SelectSubset<T, NRCDeleteArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NRC.
     * @param {NRCUpdateArgs} args - Arguments to update one NRC.
     * @example
     * // Update one NRC
     * const nRC = await prisma.nRC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NRCUpdateArgs>(args: SelectSubset<T, NRCUpdateArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NRCS.
     * @param {NRCDeleteManyArgs} args - Arguments to filter NRCS to delete.
     * @example
     * // Delete a few NRCS
     * const { count } = await prisma.nRC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NRCDeleteManyArgs>(args?: SelectSubset<T, NRCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NRCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NRCS
     * const nRC = await prisma.nRC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NRCUpdateManyArgs>(args: SelectSubset<T, NRCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NRCS and returns the data updated in the database.
     * @param {NRCUpdateManyAndReturnArgs} args - Arguments to update many NRCS.
     * @example
     * // Update many NRCS
     * const nRC = await prisma.nRC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NRCS and only return the `codigo_nrc`
     * const nRCWithCodigo_nrcOnly = await prisma.nRC.updateManyAndReturn({
     *   select: { codigo_nrc: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NRCUpdateManyAndReturnArgs>(args: SelectSubset<T, NRCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NRC.
     * @param {NRCUpsertArgs} args - Arguments to update or create a NRC.
     * @example
     * // Update or create a NRC
     * const nRC = await prisma.nRC.upsert({
     *   create: {
     *     // ... data to create a NRC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NRC we want to update
     *   }
     * })
     */
    upsert<T extends NRCUpsertArgs>(args: SelectSubset<T, NRCUpsertArgs<ExtArgs>>): Prisma__NRCClient<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NRCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCCountArgs} args - Arguments to filter NRCS to count.
     * @example
     * // Count the number of NRCS
     * const count = await prisma.nRC.count({
     *   where: {
     *     // ... the filter for the NRCS we want to count
     *   }
     * })
    **/
    count<T extends NRCCountArgs>(
      args?: Subset<T, NRCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NRCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NRC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NRCAggregateArgs>(args: Subset<T, NRCAggregateArgs>): Prisma.PrismaPromise<GetNRCAggregateType<T>>

    /**
     * Group by NRC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NRCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NRCGroupByArgs['orderBy'] }
        : { orderBy?: NRCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NRCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNRCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NRC model
   */
  readonly fields: NRCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NRC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NRCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EstudianteNRC<T extends NRC$EstudianteNRCArgs<ExtArgs> = {}>(args?: Subset<T, NRC$EstudianteNRCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudianteNRCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Materia<T extends MateriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MateriaDefaultArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NRC model
   */
  interface NRCFieldRefs {
    readonly codigo_nrc: FieldRef<"NRC", 'Int'>
    readonly materia_id: FieldRef<"NRC", 'Int'>
    readonly profesor_id: FieldRef<"NRC", 'Int'>
    readonly create_at: FieldRef<"NRC", 'DateTime'>
    readonly update_at: FieldRef<"NRC", 'DateTime'>
    readonly deleted: FieldRef<"NRC", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NRC findUnique
   */
  export type NRCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * Filter, which NRC to fetch.
     */
    where: NRCWhereUniqueInput
  }

  /**
   * NRC findUniqueOrThrow
   */
  export type NRCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * Filter, which NRC to fetch.
     */
    where: NRCWhereUniqueInput
  }

  /**
   * NRC findFirst
   */
  export type NRCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * Filter, which NRC to fetch.
     */
    where?: NRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRCS to fetch.
     */
    orderBy?: NRCOrderByWithRelationInput | NRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NRCS.
     */
    cursor?: NRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NRCS.
     */
    distinct?: NRCScalarFieldEnum | NRCScalarFieldEnum[]
  }

  /**
   * NRC findFirstOrThrow
   */
  export type NRCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * Filter, which NRC to fetch.
     */
    where?: NRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRCS to fetch.
     */
    orderBy?: NRCOrderByWithRelationInput | NRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NRCS.
     */
    cursor?: NRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NRCS.
     */
    distinct?: NRCScalarFieldEnum | NRCScalarFieldEnum[]
  }

  /**
   * NRC findMany
   */
  export type NRCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * Filter, which NRCS to fetch.
     */
    where?: NRCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRCS to fetch.
     */
    orderBy?: NRCOrderByWithRelationInput | NRCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NRCS.
     */
    cursor?: NRCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRCS.
     */
    skip?: number
    distinct?: NRCScalarFieldEnum | NRCScalarFieldEnum[]
  }

  /**
   * NRC create
   */
  export type NRCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * The data needed to create a NRC.
     */
    data: XOR<NRCCreateInput, NRCUncheckedCreateInput>
  }

  /**
   * NRC createMany
   */
  export type NRCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NRCS.
     */
    data: NRCCreateManyInput | NRCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NRC createManyAndReturn
   */
  export type NRCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * The data used to create many NRCS.
     */
    data: NRCCreateManyInput | NRCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NRC update
   */
  export type NRCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * The data needed to update a NRC.
     */
    data: XOR<NRCUpdateInput, NRCUncheckedUpdateInput>
    /**
     * Choose, which NRC to update.
     */
    where: NRCWhereUniqueInput
  }

  /**
   * NRC updateMany
   */
  export type NRCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NRCS.
     */
    data: XOR<NRCUpdateManyMutationInput, NRCUncheckedUpdateManyInput>
    /**
     * Filter which NRCS to update
     */
    where?: NRCWhereInput
    /**
     * Limit how many NRCS to update.
     */
    limit?: number
  }

  /**
   * NRC updateManyAndReturn
   */
  export type NRCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * The data used to update NRCS.
     */
    data: XOR<NRCUpdateManyMutationInput, NRCUncheckedUpdateManyInput>
    /**
     * Filter which NRCS to update
     */
    where?: NRCWhereInput
    /**
     * Limit how many NRCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NRC upsert
   */
  export type NRCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * The filter to search for the NRC to update in case it exists.
     */
    where: NRCWhereUniqueInput
    /**
     * In case the NRC found by the `where` argument doesn't exist, create a new NRC with this data.
     */
    create: XOR<NRCCreateInput, NRCUncheckedCreateInput>
    /**
     * In case the NRC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NRCUpdateInput, NRCUncheckedUpdateInput>
  }

  /**
   * NRC delete
   */
  export type NRCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    /**
     * Filter which NRC to delete.
     */
    where: NRCWhereUniqueInput
  }

  /**
   * NRC deleteMany
   */
  export type NRCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NRCS to delete
     */
    where?: NRCWhereInput
    /**
     * Limit how many NRCS to delete.
     */
    limit?: number
  }

  /**
   * NRC.EstudianteNRC
   */
  export type NRC$EstudianteNRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteNRC
     */
    select?: EstudianteNRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EstudianteNRC
     */
    omit?: EstudianteNRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteNRCInclude<ExtArgs> | null
    where?: EstudianteNRCWhereInput
    orderBy?: EstudianteNRCOrderByWithRelationInput | EstudianteNRCOrderByWithRelationInput[]
    cursor?: EstudianteNRCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudianteNRCScalarFieldEnum | EstudianteNRCScalarFieldEnum[]
  }

  /**
   * NRC without action
   */
  export type NRCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
  }


  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    id: number | null
  }

  export type RolSumAggregateOutputType = {
    id: number | null
  }

  export type RolMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type RolMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    nombre: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    id?: true
  }

  export type RolSumAggregateInputType = {
    id?: true
  }

  export type RolMinAggregateInputType = {
    id?: true
    nombre?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    nombre?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    nombre?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id: number
    nombre: string
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    RolEndpoint?: boolean | Rol$RolEndpointArgs<ExtArgs>
    RolUsuario?: boolean | Rol$RolUsuarioArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type RolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectScalar = {
    id?: boolean
    nombre?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type RolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["rol"]>
  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolEndpoint?: boolean | Rol$RolEndpointArgs<ExtArgs>
    RolUsuario?: boolean | Rol$RolUsuarioArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      RolEndpoint: Prisma.$RolEndpointPayload<ExtArgs>[]
      RolUsuario: Prisma.$RolUsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }

  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolFindUniqueArgs>(args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs>(args: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolFindFirstArgs>(args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs>(args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolFindManyArgs>(args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
     */
    create<T extends RolCreateArgs>(args: SelectSubset<T, RolCreateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rols.
     * @param {RolCreateManyArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolCreateManyArgs>(args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rols and returns the data saved in the database.
     * @param {RolCreateManyAndReturnArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rols and only return the `id`
     * const rolWithIdOnly = await prisma.rol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolCreateManyAndReturnArgs>(args?: SelectSubset<T, RolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
     */
    delete<T extends RolDeleteArgs>(args: SelectSubset<T, RolDeleteArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUpdateArgs>(args: SelectSubset<T, RolUpdateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolDeleteManyArgs>(args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUpdateManyArgs>(args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols and returns the data updated in the database.
     * @param {RolUpdateManyAndReturnArgs} args - Arguments to update many Rols.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rols and only return the `id`
     * const rolWithIdOnly = await prisma.rol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolUpdateManyAndReturnArgs>(args: SelectSubset<T, RolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
     */
    upsert<T extends RolUpsertArgs>(args: SelectSubset<T, RolUpsertArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RolEndpoint<T extends Rol$RolEndpointArgs<ExtArgs> = {}>(args?: Subset<T, Rol$RolEndpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RolUsuario<T extends Rol$RolUsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Rol$RolUsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol model
   */
  interface RolFieldRefs {
    readonly id: FieldRef<"Rol", 'Int'>
    readonly nombre: FieldRef<"Rol", 'String'>
    readonly create_at: FieldRef<"Rol", 'DateTime'>
    readonly update_at: FieldRef<"Rol", 'DateTime'>
    readonly deleted: FieldRef<"Rol", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }

  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol createManyAndReturn
   */
  export type RolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to update.
     */
    limit?: number
  }

  /**
   * Rol updateManyAndReturn
   */
  export type RolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to update.
     */
    limit?: number
  }

  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }

  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to delete.
     */
    limit?: number
  }

  /**
   * Rol.RolEndpoint
   */
  export type Rol$RolEndpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    where?: RolEndpointWhereInput
    orderBy?: RolEndpointOrderByWithRelationInput | RolEndpointOrderByWithRelationInput[]
    cursor?: RolEndpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolEndpointScalarFieldEnum | RolEndpointScalarFieldEnum[]
  }

  /**
   * Rol.RolUsuario
   */
  export type Rol$RolUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    where?: RolUsuarioWhereInput
    orderBy?: RolUsuarioOrderByWithRelationInput | RolUsuarioOrderByWithRelationInput[]
    cursor?: RolUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolUsuarioScalarFieldEnum | RolUsuarioScalarFieldEnum[]
  }

  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
  }


  /**
   * Model RolEndpoint
   */

  export type AggregateRolEndpoint = {
    _count: RolEndpointCountAggregateOutputType | null
    _avg: RolEndpointAvgAggregateOutputType | null
    _sum: RolEndpointSumAggregateOutputType | null
    _min: RolEndpointMinAggregateOutputType | null
    _max: RolEndpointMaxAggregateOutputType | null
  }

  export type RolEndpointAvgAggregateOutputType = {
    id_rol: number | null
    id_endpoint: number | null
  }

  export type RolEndpointSumAggregateOutputType = {
    id_rol: number | null
    id_endpoint: number | null
  }

  export type RolEndpointMinAggregateOutputType = {
    id_rol: number | null
    id_endpoint: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type RolEndpointMaxAggregateOutputType = {
    id_rol: number | null
    id_endpoint: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type RolEndpointCountAggregateOutputType = {
    id_rol: number
    id_endpoint: number
    create_at: number
    deleted: number
    _all: number
  }


  export type RolEndpointAvgAggregateInputType = {
    id_rol?: true
    id_endpoint?: true
  }

  export type RolEndpointSumAggregateInputType = {
    id_rol?: true
    id_endpoint?: true
  }

  export type RolEndpointMinAggregateInputType = {
    id_rol?: true
    id_endpoint?: true
    create_at?: true
    deleted?: true
  }

  export type RolEndpointMaxAggregateInputType = {
    id_rol?: true
    id_endpoint?: true
    create_at?: true
    deleted?: true
  }

  export type RolEndpointCountAggregateInputType = {
    id_rol?: true
    id_endpoint?: true
    create_at?: true
    deleted?: true
    _all?: true
  }

  export type RolEndpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolEndpoint to aggregate.
     */
    where?: RolEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolEndpoints to fetch.
     */
    orderBy?: RolEndpointOrderByWithRelationInput | RolEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolEndpoints
    **/
    _count?: true | RolEndpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolEndpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolEndpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolEndpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolEndpointMaxAggregateInputType
  }

  export type GetRolEndpointAggregateType<T extends RolEndpointAggregateArgs> = {
        [P in keyof T & keyof AggregateRolEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolEndpoint[P]>
      : GetScalarType<T[P], AggregateRolEndpoint[P]>
  }




  export type RolEndpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolEndpointWhereInput
    orderBy?: RolEndpointOrderByWithAggregationInput | RolEndpointOrderByWithAggregationInput[]
    by: RolEndpointScalarFieldEnum[] | RolEndpointScalarFieldEnum
    having?: RolEndpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolEndpointCountAggregateInputType | true
    _avg?: RolEndpointAvgAggregateInputType
    _sum?: RolEndpointSumAggregateInputType
    _min?: RolEndpointMinAggregateInputType
    _max?: RolEndpointMaxAggregateInputType
  }

  export type RolEndpointGroupByOutputType = {
    id_rol: number
    id_endpoint: number
    create_at: Date
    deleted: boolean
    _count: RolEndpointCountAggregateOutputType | null
    _avg: RolEndpointAvgAggregateOutputType | null
    _sum: RolEndpointSumAggregateOutputType | null
    _min: RolEndpointMinAggregateOutputType | null
    _max: RolEndpointMaxAggregateOutputType | null
  }

  type GetRolEndpointGroupByPayload<T extends RolEndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolEndpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolEndpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolEndpointGroupByOutputType[P]>
            : GetScalarType<T[P], RolEndpointGroupByOutputType[P]>
        }
      >
    >


  export type RolEndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    id_endpoint?: boolean
    create_at?: boolean
    deleted?: boolean
    Endpoint?: boolean | EndpointDefaultArgs<ExtArgs>
    Rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolEndpoint"]>

  export type RolEndpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    id_endpoint?: boolean
    create_at?: boolean
    deleted?: boolean
    Endpoint?: boolean | EndpointDefaultArgs<ExtArgs>
    Rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolEndpoint"]>

  export type RolEndpointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    id_endpoint?: boolean
    create_at?: boolean
    deleted?: boolean
    Endpoint?: boolean | EndpointDefaultArgs<ExtArgs>
    Rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolEndpoint"]>

  export type RolEndpointSelectScalar = {
    id_rol?: boolean
    id_endpoint?: boolean
    create_at?: boolean
    deleted?: boolean
  }

  export type RolEndpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_rol" | "id_endpoint" | "create_at" | "deleted", ExtArgs["result"]["rolEndpoint"]>
  export type RolEndpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Endpoint?: boolean | EndpointDefaultArgs<ExtArgs>
    Rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type RolEndpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Endpoint?: boolean | EndpointDefaultArgs<ExtArgs>
    Rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type RolEndpointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Endpoint?: boolean | EndpointDefaultArgs<ExtArgs>
    Rol?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $RolEndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolEndpoint"
    objects: {
      Endpoint: Prisma.$EndpointPayload<ExtArgs>
      Rol: Prisma.$RolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_rol: number
      id_endpoint: number
      create_at: Date
      deleted: boolean
    }, ExtArgs["result"]["rolEndpoint"]>
    composites: {}
  }

  type RolEndpointGetPayload<S extends boolean | null | undefined | RolEndpointDefaultArgs> = $Result.GetResult<Prisma.$RolEndpointPayload, S>

  type RolEndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolEndpointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolEndpointCountAggregateInputType | true
    }

  export interface RolEndpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolEndpoint'], meta: { name: 'RolEndpoint' } }
    /**
     * Find zero or one RolEndpoint that matches the filter.
     * @param {RolEndpointFindUniqueArgs} args - Arguments to find a RolEndpoint
     * @example
     * // Get one RolEndpoint
     * const rolEndpoint = await prisma.rolEndpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolEndpointFindUniqueArgs>(args: SelectSubset<T, RolEndpointFindUniqueArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolEndpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolEndpointFindUniqueOrThrowArgs} args - Arguments to find a RolEndpoint
     * @example
     * // Get one RolEndpoint
     * const rolEndpoint = await prisma.rolEndpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolEndpointFindUniqueOrThrowArgs>(args: SelectSubset<T, RolEndpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolEndpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointFindFirstArgs} args - Arguments to find a RolEndpoint
     * @example
     * // Get one RolEndpoint
     * const rolEndpoint = await prisma.rolEndpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolEndpointFindFirstArgs>(args?: SelectSubset<T, RolEndpointFindFirstArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolEndpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointFindFirstOrThrowArgs} args - Arguments to find a RolEndpoint
     * @example
     * // Get one RolEndpoint
     * const rolEndpoint = await prisma.rolEndpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolEndpointFindFirstOrThrowArgs>(args?: SelectSubset<T, RolEndpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolEndpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolEndpoints
     * const rolEndpoints = await prisma.rolEndpoint.findMany()
     * 
     * // Get first 10 RolEndpoints
     * const rolEndpoints = await prisma.rolEndpoint.findMany({ take: 10 })
     * 
     * // Only select the `id_rol`
     * const rolEndpointWithId_rolOnly = await prisma.rolEndpoint.findMany({ select: { id_rol: true } })
     * 
     */
    findMany<T extends RolEndpointFindManyArgs>(args?: SelectSubset<T, RolEndpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolEndpoint.
     * @param {RolEndpointCreateArgs} args - Arguments to create a RolEndpoint.
     * @example
     * // Create one RolEndpoint
     * const RolEndpoint = await prisma.rolEndpoint.create({
     *   data: {
     *     // ... data to create a RolEndpoint
     *   }
     * })
     * 
     */
    create<T extends RolEndpointCreateArgs>(args: SelectSubset<T, RolEndpointCreateArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolEndpoints.
     * @param {RolEndpointCreateManyArgs} args - Arguments to create many RolEndpoints.
     * @example
     * // Create many RolEndpoints
     * const rolEndpoint = await prisma.rolEndpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolEndpointCreateManyArgs>(args?: SelectSubset<T, RolEndpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolEndpoints and returns the data saved in the database.
     * @param {RolEndpointCreateManyAndReturnArgs} args - Arguments to create many RolEndpoints.
     * @example
     * // Create many RolEndpoints
     * const rolEndpoint = await prisma.rolEndpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolEndpoints and only return the `id_rol`
     * const rolEndpointWithId_rolOnly = await prisma.rolEndpoint.createManyAndReturn({
     *   select: { id_rol: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolEndpointCreateManyAndReturnArgs>(args?: SelectSubset<T, RolEndpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolEndpoint.
     * @param {RolEndpointDeleteArgs} args - Arguments to delete one RolEndpoint.
     * @example
     * // Delete one RolEndpoint
     * const RolEndpoint = await prisma.rolEndpoint.delete({
     *   where: {
     *     // ... filter to delete one RolEndpoint
     *   }
     * })
     * 
     */
    delete<T extends RolEndpointDeleteArgs>(args: SelectSubset<T, RolEndpointDeleteArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolEndpoint.
     * @param {RolEndpointUpdateArgs} args - Arguments to update one RolEndpoint.
     * @example
     * // Update one RolEndpoint
     * const rolEndpoint = await prisma.rolEndpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolEndpointUpdateArgs>(args: SelectSubset<T, RolEndpointUpdateArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolEndpoints.
     * @param {RolEndpointDeleteManyArgs} args - Arguments to filter RolEndpoints to delete.
     * @example
     * // Delete a few RolEndpoints
     * const { count } = await prisma.rolEndpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolEndpointDeleteManyArgs>(args?: SelectSubset<T, RolEndpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolEndpoints
     * const rolEndpoint = await prisma.rolEndpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolEndpointUpdateManyArgs>(args: SelectSubset<T, RolEndpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolEndpoints and returns the data updated in the database.
     * @param {RolEndpointUpdateManyAndReturnArgs} args - Arguments to update many RolEndpoints.
     * @example
     * // Update many RolEndpoints
     * const rolEndpoint = await prisma.rolEndpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolEndpoints and only return the `id_rol`
     * const rolEndpointWithId_rolOnly = await prisma.rolEndpoint.updateManyAndReturn({
     *   select: { id_rol: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolEndpointUpdateManyAndReturnArgs>(args: SelectSubset<T, RolEndpointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolEndpoint.
     * @param {RolEndpointUpsertArgs} args - Arguments to update or create a RolEndpoint.
     * @example
     * // Update or create a RolEndpoint
     * const rolEndpoint = await prisma.rolEndpoint.upsert({
     *   create: {
     *     // ... data to create a RolEndpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolEndpoint we want to update
     *   }
     * })
     */
    upsert<T extends RolEndpointUpsertArgs>(args: SelectSubset<T, RolEndpointUpsertArgs<ExtArgs>>): Prisma__RolEndpointClient<$Result.GetResult<Prisma.$RolEndpointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointCountArgs} args - Arguments to filter RolEndpoints to count.
     * @example
     * // Count the number of RolEndpoints
     * const count = await prisma.rolEndpoint.count({
     *   where: {
     *     // ... the filter for the RolEndpoints we want to count
     *   }
     * })
    **/
    count<T extends RolEndpointCountArgs>(
      args?: Subset<T, RolEndpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolEndpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolEndpointAggregateArgs>(args: Subset<T, RolEndpointAggregateArgs>): Prisma.PrismaPromise<GetRolEndpointAggregateType<T>>

    /**
     * Group by RolEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolEndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolEndpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolEndpointGroupByArgs['orderBy'] }
        : { orderBy?: RolEndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolEndpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolEndpoint model
   */
  readonly fields: RolEndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolEndpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolEndpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Endpoint<T extends EndpointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EndpointDefaultArgs<ExtArgs>>): Prisma__EndpointClient<$Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolEndpoint model
   */
  interface RolEndpointFieldRefs {
    readonly id_rol: FieldRef<"RolEndpoint", 'Int'>
    readonly id_endpoint: FieldRef<"RolEndpoint", 'Int'>
    readonly create_at: FieldRef<"RolEndpoint", 'DateTime'>
    readonly deleted: FieldRef<"RolEndpoint", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RolEndpoint findUnique
   */
  export type RolEndpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * Filter, which RolEndpoint to fetch.
     */
    where: RolEndpointWhereUniqueInput
  }

  /**
   * RolEndpoint findUniqueOrThrow
   */
  export type RolEndpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * Filter, which RolEndpoint to fetch.
     */
    where: RolEndpointWhereUniqueInput
  }

  /**
   * RolEndpoint findFirst
   */
  export type RolEndpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * Filter, which RolEndpoint to fetch.
     */
    where?: RolEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolEndpoints to fetch.
     */
    orderBy?: RolEndpointOrderByWithRelationInput | RolEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolEndpoints.
     */
    cursor?: RolEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolEndpoints.
     */
    distinct?: RolEndpointScalarFieldEnum | RolEndpointScalarFieldEnum[]
  }

  /**
   * RolEndpoint findFirstOrThrow
   */
  export type RolEndpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * Filter, which RolEndpoint to fetch.
     */
    where?: RolEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolEndpoints to fetch.
     */
    orderBy?: RolEndpointOrderByWithRelationInput | RolEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolEndpoints.
     */
    cursor?: RolEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolEndpoints.
     */
    distinct?: RolEndpointScalarFieldEnum | RolEndpointScalarFieldEnum[]
  }

  /**
   * RolEndpoint findMany
   */
  export type RolEndpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * Filter, which RolEndpoints to fetch.
     */
    where?: RolEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolEndpoints to fetch.
     */
    orderBy?: RolEndpointOrderByWithRelationInput | RolEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolEndpoints.
     */
    cursor?: RolEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolEndpoints.
     */
    skip?: number
    distinct?: RolEndpointScalarFieldEnum | RolEndpointScalarFieldEnum[]
  }

  /**
   * RolEndpoint create
   */
  export type RolEndpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * The data needed to create a RolEndpoint.
     */
    data: XOR<RolEndpointCreateInput, RolEndpointUncheckedCreateInput>
  }

  /**
   * RolEndpoint createMany
   */
  export type RolEndpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolEndpoints.
     */
    data: RolEndpointCreateManyInput | RolEndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolEndpoint createManyAndReturn
   */
  export type RolEndpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * The data used to create many RolEndpoints.
     */
    data: RolEndpointCreateManyInput | RolEndpointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolEndpoint update
   */
  export type RolEndpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * The data needed to update a RolEndpoint.
     */
    data: XOR<RolEndpointUpdateInput, RolEndpointUncheckedUpdateInput>
    /**
     * Choose, which RolEndpoint to update.
     */
    where: RolEndpointWhereUniqueInput
  }

  /**
   * RolEndpoint updateMany
   */
  export type RolEndpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolEndpoints.
     */
    data: XOR<RolEndpointUpdateManyMutationInput, RolEndpointUncheckedUpdateManyInput>
    /**
     * Filter which RolEndpoints to update
     */
    where?: RolEndpointWhereInput
    /**
     * Limit how many RolEndpoints to update.
     */
    limit?: number
  }

  /**
   * RolEndpoint updateManyAndReturn
   */
  export type RolEndpointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * The data used to update RolEndpoints.
     */
    data: XOR<RolEndpointUpdateManyMutationInput, RolEndpointUncheckedUpdateManyInput>
    /**
     * Filter which RolEndpoints to update
     */
    where?: RolEndpointWhereInput
    /**
     * Limit how many RolEndpoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolEndpoint upsert
   */
  export type RolEndpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * The filter to search for the RolEndpoint to update in case it exists.
     */
    where: RolEndpointWhereUniqueInput
    /**
     * In case the RolEndpoint found by the `where` argument doesn't exist, create a new RolEndpoint with this data.
     */
    create: XOR<RolEndpointCreateInput, RolEndpointUncheckedCreateInput>
    /**
     * In case the RolEndpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolEndpointUpdateInput, RolEndpointUncheckedUpdateInput>
  }

  /**
   * RolEndpoint delete
   */
  export type RolEndpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
    /**
     * Filter which RolEndpoint to delete.
     */
    where: RolEndpointWhereUniqueInput
  }

  /**
   * RolEndpoint deleteMany
   */
  export type RolEndpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolEndpoints to delete
     */
    where?: RolEndpointWhereInput
    /**
     * Limit how many RolEndpoints to delete.
     */
    limit?: number
  }

  /**
   * RolEndpoint without action
   */
  export type RolEndpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolEndpoint
     */
    select?: RolEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolEndpoint
     */
    omit?: RolEndpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolEndpointInclude<ExtArgs> | null
  }


  /**
   * Model RolUsuario
   */

  export type AggregateRolUsuario = {
    _count: RolUsuarioCountAggregateOutputType | null
    _avg: RolUsuarioAvgAggregateOutputType | null
    _sum: RolUsuarioSumAggregateOutputType | null
    _min: RolUsuarioMinAggregateOutputType | null
    _max: RolUsuarioMaxAggregateOutputType | null
  }

  export type RolUsuarioAvgAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
  }

  export type RolUsuarioSumAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
  }

  export type RolUsuarioMinAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type RolUsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type RolUsuarioCountAggregateOutputType = {
    id_usuario: number
    id_rol: number
    create_at: number
    deleted: number
    _all: number
  }


  export type RolUsuarioAvgAggregateInputType = {
    id_usuario?: true
    id_rol?: true
  }

  export type RolUsuarioSumAggregateInputType = {
    id_usuario?: true
    id_rol?: true
  }

  export type RolUsuarioMinAggregateInputType = {
    id_usuario?: true
    id_rol?: true
    create_at?: true
    deleted?: true
  }

  export type RolUsuarioMaxAggregateInputType = {
    id_usuario?: true
    id_rol?: true
    create_at?: true
    deleted?: true
  }

  export type RolUsuarioCountAggregateInputType = {
    id_usuario?: true
    id_rol?: true
    create_at?: true
    deleted?: true
    _all?: true
  }

  export type RolUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolUsuario to aggregate.
     */
    where?: RolUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolUsuarios to fetch.
     */
    orderBy?: RolUsuarioOrderByWithRelationInput | RolUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolUsuarios
    **/
    _count?: true | RolUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolUsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolUsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolUsuarioMaxAggregateInputType
  }

  export type GetRolUsuarioAggregateType<T extends RolUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateRolUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolUsuario[P]>
      : GetScalarType<T[P], AggregateRolUsuario[P]>
  }




  export type RolUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolUsuarioWhereInput
    orderBy?: RolUsuarioOrderByWithAggregationInput | RolUsuarioOrderByWithAggregationInput[]
    by: RolUsuarioScalarFieldEnum[] | RolUsuarioScalarFieldEnum
    having?: RolUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolUsuarioCountAggregateInputType | true
    _avg?: RolUsuarioAvgAggregateInputType
    _sum?: RolUsuarioSumAggregateInputType
    _min?: RolUsuarioMinAggregateInputType
    _max?: RolUsuarioMaxAggregateInputType
  }

  export type RolUsuarioGroupByOutputType = {
    id_usuario: number
    id_rol: number
    create_at: Date
    deleted: boolean
    _count: RolUsuarioCountAggregateOutputType | null
    _avg: RolUsuarioAvgAggregateOutputType | null
    _sum: RolUsuarioSumAggregateOutputType | null
    _min: RolUsuarioMinAggregateOutputType | null
    _max: RolUsuarioMaxAggregateOutputType | null
  }

  type GetRolUsuarioGroupByPayload<T extends RolUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], RolUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type RolUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_rol?: boolean
    create_at?: boolean
    deleted?: boolean
    Rol?: boolean | RolDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolUsuario"]>

  export type RolUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_rol?: boolean
    create_at?: boolean
    deleted?: boolean
    Rol?: boolean | RolDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolUsuario"]>

  export type RolUsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_rol?: boolean
    create_at?: boolean
    deleted?: boolean
    Rol?: boolean | RolDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolUsuario"]>

  export type RolUsuarioSelectScalar = {
    id_usuario?: boolean
    id_rol?: boolean
    create_at?: boolean
    deleted?: boolean
  }

  export type RolUsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_usuario" | "id_rol" | "create_at" | "deleted", ExtArgs["result"]["rolUsuario"]>
  export type RolUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rol?: boolean | RolDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RolUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rol?: boolean | RolDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RolUsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rol?: boolean | RolDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $RolUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolUsuario"
    objects: {
      Rol: Prisma.$RolPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      id_rol: number
      create_at: Date
      deleted: boolean
    }, ExtArgs["result"]["rolUsuario"]>
    composites: {}
  }

  type RolUsuarioGetPayload<S extends boolean | null | undefined | RolUsuarioDefaultArgs> = $Result.GetResult<Prisma.$RolUsuarioPayload, S>

  type RolUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolUsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolUsuarioCountAggregateInputType | true
    }

  export interface RolUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolUsuario'], meta: { name: 'RolUsuario' } }
    /**
     * Find zero or one RolUsuario that matches the filter.
     * @param {RolUsuarioFindUniqueArgs} args - Arguments to find a RolUsuario
     * @example
     * // Get one RolUsuario
     * const rolUsuario = await prisma.rolUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolUsuarioFindUniqueArgs>(args: SelectSubset<T, RolUsuarioFindUniqueArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolUsuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolUsuarioFindUniqueOrThrowArgs} args - Arguments to find a RolUsuario
     * @example
     * // Get one RolUsuario
     * const rolUsuario = await prisma.rolUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, RolUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioFindFirstArgs} args - Arguments to find a RolUsuario
     * @example
     * // Get one RolUsuario
     * const rolUsuario = await prisma.rolUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolUsuarioFindFirstArgs>(args?: SelectSubset<T, RolUsuarioFindFirstArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioFindFirstOrThrowArgs} args - Arguments to find a RolUsuario
     * @example
     * // Get one RolUsuario
     * const rolUsuario = await prisma.rolUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, RolUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolUsuarios
     * const rolUsuarios = await prisma.rolUsuario.findMany()
     * 
     * // Get first 10 RolUsuarios
     * const rolUsuarios = await prisma.rolUsuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const rolUsuarioWithId_usuarioOnly = await prisma.rolUsuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends RolUsuarioFindManyArgs>(args?: SelectSubset<T, RolUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolUsuario.
     * @param {RolUsuarioCreateArgs} args - Arguments to create a RolUsuario.
     * @example
     * // Create one RolUsuario
     * const RolUsuario = await prisma.rolUsuario.create({
     *   data: {
     *     // ... data to create a RolUsuario
     *   }
     * })
     * 
     */
    create<T extends RolUsuarioCreateArgs>(args: SelectSubset<T, RolUsuarioCreateArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolUsuarios.
     * @param {RolUsuarioCreateManyArgs} args - Arguments to create many RolUsuarios.
     * @example
     * // Create many RolUsuarios
     * const rolUsuario = await prisma.rolUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolUsuarioCreateManyArgs>(args?: SelectSubset<T, RolUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolUsuarios and returns the data saved in the database.
     * @param {RolUsuarioCreateManyAndReturnArgs} args - Arguments to create many RolUsuarios.
     * @example
     * // Create many RolUsuarios
     * const rolUsuario = await prisma.rolUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolUsuarios and only return the `id_usuario`
     * const rolUsuarioWithId_usuarioOnly = await prisma.rolUsuario.createManyAndReturn({
     *   select: { id_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, RolUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolUsuario.
     * @param {RolUsuarioDeleteArgs} args - Arguments to delete one RolUsuario.
     * @example
     * // Delete one RolUsuario
     * const RolUsuario = await prisma.rolUsuario.delete({
     *   where: {
     *     // ... filter to delete one RolUsuario
     *   }
     * })
     * 
     */
    delete<T extends RolUsuarioDeleteArgs>(args: SelectSubset<T, RolUsuarioDeleteArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolUsuario.
     * @param {RolUsuarioUpdateArgs} args - Arguments to update one RolUsuario.
     * @example
     * // Update one RolUsuario
     * const rolUsuario = await prisma.rolUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUsuarioUpdateArgs>(args: SelectSubset<T, RolUsuarioUpdateArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolUsuarios.
     * @param {RolUsuarioDeleteManyArgs} args - Arguments to filter RolUsuarios to delete.
     * @example
     * // Delete a few RolUsuarios
     * const { count } = await prisma.rolUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolUsuarioDeleteManyArgs>(args?: SelectSubset<T, RolUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolUsuarios
     * const rolUsuario = await prisma.rolUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUsuarioUpdateManyArgs>(args: SelectSubset<T, RolUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolUsuarios and returns the data updated in the database.
     * @param {RolUsuarioUpdateManyAndReturnArgs} args - Arguments to update many RolUsuarios.
     * @example
     * // Update many RolUsuarios
     * const rolUsuario = await prisma.rolUsuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolUsuarios and only return the `id_usuario`
     * const rolUsuarioWithId_usuarioOnly = await prisma.rolUsuario.updateManyAndReturn({
     *   select: { id_usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolUsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, RolUsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolUsuario.
     * @param {RolUsuarioUpsertArgs} args - Arguments to update or create a RolUsuario.
     * @example
     * // Update or create a RolUsuario
     * const rolUsuario = await prisma.rolUsuario.upsert({
     *   create: {
     *     // ... data to create a RolUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolUsuario we want to update
     *   }
     * })
     */
    upsert<T extends RolUsuarioUpsertArgs>(args: SelectSubset<T, RolUsuarioUpsertArgs<ExtArgs>>): Prisma__RolUsuarioClient<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioCountArgs} args - Arguments to filter RolUsuarios to count.
     * @example
     * // Count the number of RolUsuarios
     * const count = await prisma.rolUsuario.count({
     *   where: {
     *     // ... the filter for the RolUsuarios we want to count
     *   }
     * })
    **/
    count<T extends RolUsuarioCountArgs>(
      args?: Subset<T, RolUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolUsuarioAggregateArgs>(args: Subset<T, RolUsuarioAggregateArgs>): Prisma.PrismaPromise<GetRolUsuarioAggregateType<T>>

    /**
     * Group by RolUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: RolUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolUsuario model
   */
  readonly fields: RolUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolUsuario model
   */
  interface RolUsuarioFieldRefs {
    readonly id_usuario: FieldRef<"RolUsuario", 'Int'>
    readonly id_rol: FieldRef<"RolUsuario", 'Int'>
    readonly create_at: FieldRef<"RolUsuario", 'DateTime'>
    readonly deleted: FieldRef<"RolUsuario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RolUsuario findUnique
   */
  export type RolUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolUsuario to fetch.
     */
    where: RolUsuarioWhereUniqueInput
  }

  /**
   * RolUsuario findUniqueOrThrow
   */
  export type RolUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolUsuario to fetch.
     */
    where: RolUsuarioWhereUniqueInput
  }

  /**
   * RolUsuario findFirst
   */
  export type RolUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolUsuario to fetch.
     */
    where?: RolUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolUsuarios to fetch.
     */
    orderBy?: RolUsuarioOrderByWithRelationInput | RolUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolUsuarios.
     */
    cursor?: RolUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolUsuarios.
     */
    distinct?: RolUsuarioScalarFieldEnum | RolUsuarioScalarFieldEnum[]
  }

  /**
   * RolUsuario findFirstOrThrow
   */
  export type RolUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolUsuario to fetch.
     */
    where?: RolUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolUsuarios to fetch.
     */
    orderBy?: RolUsuarioOrderByWithRelationInput | RolUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolUsuarios.
     */
    cursor?: RolUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolUsuarios.
     */
    distinct?: RolUsuarioScalarFieldEnum | RolUsuarioScalarFieldEnum[]
  }

  /**
   * RolUsuario findMany
   */
  export type RolUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolUsuarios to fetch.
     */
    where?: RolUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolUsuarios to fetch.
     */
    orderBy?: RolUsuarioOrderByWithRelationInput | RolUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolUsuarios.
     */
    cursor?: RolUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolUsuarios.
     */
    skip?: number
    distinct?: RolUsuarioScalarFieldEnum | RolUsuarioScalarFieldEnum[]
  }

  /**
   * RolUsuario create
   */
  export type RolUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a RolUsuario.
     */
    data: XOR<RolUsuarioCreateInput, RolUsuarioUncheckedCreateInput>
  }

  /**
   * RolUsuario createMany
   */
  export type RolUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolUsuarios.
     */
    data: RolUsuarioCreateManyInput | RolUsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolUsuario createManyAndReturn
   */
  export type RolUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many RolUsuarios.
     */
    data: RolUsuarioCreateManyInput | RolUsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolUsuario update
   */
  export type RolUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a RolUsuario.
     */
    data: XOR<RolUsuarioUpdateInput, RolUsuarioUncheckedUpdateInput>
    /**
     * Choose, which RolUsuario to update.
     */
    where: RolUsuarioWhereUniqueInput
  }

  /**
   * RolUsuario updateMany
   */
  export type RolUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolUsuarios.
     */
    data: XOR<RolUsuarioUpdateManyMutationInput, RolUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which RolUsuarios to update
     */
    where?: RolUsuarioWhereInput
    /**
     * Limit how many RolUsuarios to update.
     */
    limit?: number
  }

  /**
   * RolUsuario updateManyAndReturn
   */
  export type RolUsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * The data used to update RolUsuarios.
     */
    data: XOR<RolUsuarioUpdateManyMutationInput, RolUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which RolUsuarios to update
     */
    where?: RolUsuarioWhereInput
    /**
     * Limit how many RolUsuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolUsuario upsert
   */
  export type RolUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the RolUsuario to update in case it exists.
     */
    where: RolUsuarioWhereUniqueInput
    /**
     * In case the RolUsuario found by the `where` argument doesn't exist, create a new RolUsuario with this data.
     */
    create: XOR<RolUsuarioCreateInput, RolUsuarioUncheckedCreateInput>
    /**
     * In case the RolUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUsuarioUpdateInput, RolUsuarioUncheckedUpdateInput>
  }

  /**
   * RolUsuario delete
   */
  export type RolUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    /**
     * Filter which RolUsuario to delete.
     */
    where: RolUsuarioWhereUniqueInput
  }

  /**
   * RolUsuario deleteMany
   */
  export type RolUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolUsuarios to delete
     */
    where?: RolUsuarioWhereInput
    /**
     * Limit how many RolUsuarios to delete.
     */
    limit?: number
  }

  /**
   * RolUsuario without action
   */
  export type RolUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Rubrica
   */

  export type AggregateRubrica = {
    _count: RubricaCountAggregateOutputType | null
    _avg: RubricaAvgAggregateOutputType | null
    _sum: RubricaSumAggregateOutputType | null
    _min: RubricaMinAggregateOutputType | null
    _max: RubricaMaxAggregateOutputType | null
  }

  export type RubricaAvgAggregateOutputType = {
    id_evaluacion: number | null
    id_criterio: number | null
    valoracion: number | null
  }

  export type RubricaSumAggregateOutputType = {
    id_evaluacion: number | null
    id_criterio: number | null
    valoracion: number | null
  }

  export type RubricaMinAggregateOutputType = {
    id_evaluacion: number | null
    id_criterio: number | null
    valoracion: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type RubricaMaxAggregateOutputType = {
    id_evaluacion: number | null
    id_criterio: number | null
    valoracion: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type RubricaCountAggregateOutputType = {
    id_evaluacion: number
    id_criterio: number
    valoracion: number
    create_at: number
    deleted: number
    _all: number
  }


  export type RubricaAvgAggregateInputType = {
    id_evaluacion?: true
    id_criterio?: true
    valoracion?: true
  }

  export type RubricaSumAggregateInputType = {
    id_evaluacion?: true
    id_criterio?: true
    valoracion?: true
  }

  export type RubricaMinAggregateInputType = {
    id_evaluacion?: true
    id_criterio?: true
    valoracion?: true
    create_at?: true
    deleted?: true
  }

  export type RubricaMaxAggregateInputType = {
    id_evaluacion?: true
    id_criterio?: true
    valoracion?: true
    create_at?: true
    deleted?: true
  }

  export type RubricaCountAggregateInputType = {
    id_evaluacion?: true
    id_criterio?: true
    valoracion?: true
    create_at?: true
    deleted?: true
    _all?: true
  }

  export type RubricaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rubrica to aggregate.
     */
    where?: RubricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubricas to fetch.
     */
    orderBy?: RubricaOrderByWithRelationInput | RubricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RubricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubricas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rubricas
    **/
    _count?: true | RubricaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RubricaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RubricaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RubricaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RubricaMaxAggregateInputType
  }

  export type GetRubricaAggregateType<T extends RubricaAggregateArgs> = {
        [P in keyof T & keyof AggregateRubrica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRubrica[P]>
      : GetScalarType<T[P], AggregateRubrica[P]>
  }




  export type RubricaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RubricaWhereInput
    orderBy?: RubricaOrderByWithAggregationInput | RubricaOrderByWithAggregationInput[]
    by: RubricaScalarFieldEnum[] | RubricaScalarFieldEnum
    having?: RubricaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RubricaCountAggregateInputType | true
    _avg?: RubricaAvgAggregateInputType
    _sum?: RubricaSumAggregateInputType
    _min?: RubricaMinAggregateInputType
    _max?: RubricaMaxAggregateInputType
  }

  export type RubricaGroupByOutputType = {
    id_evaluacion: number
    id_criterio: number
    valoracion: number
    create_at: Date
    deleted: boolean
    _count: RubricaCountAggregateOutputType | null
    _avg: RubricaAvgAggregateOutputType | null
    _sum: RubricaSumAggregateOutputType | null
    _min: RubricaMinAggregateOutputType | null
    _max: RubricaMaxAggregateOutputType | null
  }

  type GetRubricaGroupByPayload<T extends RubricaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RubricaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RubricaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RubricaGroupByOutputType[P]>
            : GetScalarType<T[P], RubricaGroupByOutputType[P]>
        }
      >
    >


  export type RubricaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_evaluacion?: boolean
    id_criterio?: boolean
    valoracion?: boolean
    create_at?: boolean
    deleted?: boolean
    Criterio?: boolean | CriterioDefaultArgs<ExtArgs>
    Evaluacion?: boolean | EvaluacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubrica"]>

  export type RubricaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_evaluacion?: boolean
    id_criterio?: boolean
    valoracion?: boolean
    create_at?: boolean
    deleted?: boolean
    Criterio?: boolean | CriterioDefaultArgs<ExtArgs>
    Evaluacion?: boolean | EvaluacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubrica"]>

  export type RubricaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_evaluacion?: boolean
    id_criterio?: boolean
    valoracion?: boolean
    create_at?: boolean
    deleted?: boolean
    Criterio?: boolean | CriterioDefaultArgs<ExtArgs>
    Evaluacion?: boolean | EvaluacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubrica"]>

  export type RubricaSelectScalar = {
    id_evaluacion?: boolean
    id_criterio?: boolean
    valoracion?: boolean
    create_at?: boolean
    deleted?: boolean
  }

  export type RubricaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_evaluacion" | "id_criterio" | "valoracion" | "create_at" | "deleted", ExtArgs["result"]["rubrica"]>
  export type RubricaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Criterio?: boolean | CriterioDefaultArgs<ExtArgs>
    Evaluacion?: boolean | EvaluacionDefaultArgs<ExtArgs>
  }
  export type RubricaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Criterio?: boolean | CriterioDefaultArgs<ExtArgs>
    Evaluacion?: boolean | EvaluacionDefaultArgs<ExtArgs>
  }
  export type RubricaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Criterio?: boolean | CriterioDefaultArgs<ExtArgs>
    Evaluacion?: boolean | EvaluacionDefaultArgs<ExtArgs>
  }

  export type $RubricaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rubrica"
    objects: {
      Criterio: Prisma.$CriterioPayload<ExtArgs>
      Evaluacion: Prisma.$EvaluacionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_evaluacion: number
      id_criterio: number
      valoracion: number
      create_at: Date
      deleted: boolean
    }, ExtArgs["result"]["rubrica"]>
    composites: {}
  }

  type RubricaGetPayload<S extends boolean | null | undefined | RubricaDefaultArgs> = $Result.GetResult<Prisma.$RubricaPayload, S>

  type RubricaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RubricaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RubricaCountAggregateInputType | true
    }

  export interface RubricaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rubrica'], meta: { name: 'Rubrica' } }
    /**
     * Find zero or one Rubrica that matches the filter.
     * @param {RubricaFindUniqueArgs} args - Arguments to find a Rubrica
     * @example
     * // Get one Rubrica
     * const rubrica = await prisma.rubrica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RubricaFindUniqueArgs>(args: SelectSubset<T, RubricaFindUniqueArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rubrica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RubricaFindUniqueOrThrowArgs} args - Arguments to find a Rubrica
     * @example
     * // Get one Rubrica
     * const rubrica = await prisma.rubrica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RubricaFindUniqueOrThrowArgs>(args: SelectSubset<T, RubricaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rubrica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaFindFirstArgs} args - Arguments to find a Rubrica
     * @example
     * // Get one Rubrica
     * const rubrica = await prisma.rubrica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RubricaFindFirstArgs>(args?: SelectSubset<T, RubricaFindFirstArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rubrica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaFindFirstOrThrowArgs} args - Arguments to find a Rubrica
     * @example
     * // Get one Rubrica
     * const rubrica = await prisma.rubrica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RubricaFindFirstOrThrowArgs>(args?: SelectSubset<T, RubricaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rubricas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rubricas
     * const rubricas = await prisma.rubrica.findMany()
     * 
     * // Get first 10 Rubricas
     * const rubricas = await prisma.rubrica.findMany({ take: 10 })
     * 
     * // Only select the `id_evaluacion`
     * const rubricaWithId_evaluacionOnly = await prisma.rubrica.findMany({ select: { id_evaluacion: true } })
     * 
     */
    findMany<T extends RubricaFindManyArgs>(args?: SelectSubset<T, RubricaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rubrica.
     * @param {RubricaCreateArgs} args - Arguments to create a Rubrica.
     * @example
     * // Create one Rubrica
     * const Rubrica = await prisma.rubrica.create({
     *   data: {
     *     // ... data to create a Rubrica
     *   }
     * })
     * 
     */
    create<T extends RubricaCreateArgs>(args: SelectSubset<T, RubricaCreateArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rubricas.
     * @param {RubricaCreateManyArgs} args - Arguments to create many Rubricas.
     * @example
     * // Create many Rubricas
     * const rubrica = await prisma.rubrica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RubricaCreateManyArgs>(args?: SelectSubset<T, RubricaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rubricas and returns the data saved in the database.
     * @param {RubricaCreateManyAndReturnArgs} args - Arguments to create many Rubricas.
     * @example
     * // Create many Rubricas
     * const rubrica = await prisma.rubrica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rubricas and only return the `id_evaluacion`
     * const rubricaWithId_evaluacionOnly = await prisma.rubrica.createManyAndReturn({
     *   select: { id_evaluacion: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RubricaCreateManyAndReturnArgs>(args?: SelectSubset<T, RubricaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rubrica.
     * @param {RubricaDeleteArgs} args - Arguments to delete one Rubrica.
     * @example
     * // Delete one Rubrica
     * const Rubrica = await prisma.rubrica.delete({
     *   where: {
     *     // ... filter to delete one Rubrica
     *   }
     * })
     * 
     */
    delete<T extends RubricaDeleteArgs>(args: SelectSubset<T, RubricaDeleteArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rubrica.
     * @param {RubricaUpdateArgs} args - Arguments to update one Rubrica.
     * @example
     * // Update one Rubrica
     * const rubrica = await prisma.rubrica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RubricaUpdateArgs>(args: SelectSubset<T, RubricaUpdateArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rubricas.
     * @param {RubricaDeleteManyArgs} args - Arguments to filter Rubricas to delete.
     * @example
     * // Delete a few Rubricas
     * const { count } = await prisma.rubrica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RubricaDeleteManyArgs>(args?: SelectSubset<T, RubricaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rubricas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rubricas
     * const rubrica = await prisma.rubrica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RubricaUpdateManyArgs>(args: SelectSubset<T, RubricaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rubricas and returns the data updated in the database.
     * @param {RubricaUpdateManyAndReturnArgs} args - Arguments to update many Rubricas.
     * @example
     * // Update many Rubricas
     * const rubrica = await prisma.rubrica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rubricas and only return the `id_evaluacion`
     * const rubricaWithId_evaluacionOnly = await prisma.rubrica.updateManyAndReturn({
     *   select: { id_evaluacion: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RubricaUpdateManyAndReturnArgs>(args: SelectSubset<T, RubricaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rubrica.
     * @param {RubricaUpsertArgs} args - Arguments to update or create a Rubrica.
     * @example
     * // Update or create a Rubrica
     * const rubrica = await prisma.rubrica.upsert({
     *   create: {
     *     // ... data to create a Rubrica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rubrica we want to update
     *   }
     * })
     */
    upsert<T extends RubricaUpsertArgs>(args: SelectSubset<T, RubricaUpsertArgs<ExtArgs>>): Prisma__RubricaClient<$Result.GetResult<Prisma.$RubricaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rubricas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaCountArgs} args - Arguments to filter Rubricas to count.
     * @example
     * // Count the number of Rubricas
     * const count = await prisma.rubrica.count({
     *   where: {
     *     // ... the filter for the Rubricas we want to count
     *   }
     * })
    **/
    count<T extends RubricaCountArgs>(
      args?: Subset<T, RubricaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RubricaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rubrica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RubricaAggregateArgs>(args: Subset<T, RubricaAggregateArgs>): Prisma.PrismaPromise<GetRubricaAggregateType<T>>

    /**
     * Group by Rubrica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RubricaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RubricaGroupByArgs['orderBy'] }
        : { orderBy?: RubricaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RubricaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRubricaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rubrica model
   */
  readonly fields: RubricaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rubrica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RubricaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Criterio<T extends CriterioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CriterioDefaultArgs<ExtArgs>>): Prisma__CriterioClient<$Result.GetResult<Prisma.$CriterioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Evaluacion<T extends EvaluacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluacionDefaultArgs<ExtArgs>>): Prisma__EvaluacionClient<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rubrica model
   */
  interface RubricaFieldRefs {
    readonly id_evaluacion: FieldRef<"Rubrica", 'Int'>
    readonly id_criterio: FieldRef<"Rubrica", 'Int'>
    readonly valoracion: FieldRef<"Rubrica", 'Int'>
    readonly create_at: FieldRef<"Rubrica", 'DateTime'>
    readonly deleted: FieldRef<"Rubrica", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Rubrica findUnique
   */
  export type RubricaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * Filter, which Rubrica to fetch.
     */
    where: RubricaWhereUniqueInput
  }

  /**
   * Rubrica findUniqueOrThrow
   */
  export type RubricaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * Filter, which Rubrica to fetch.
     */
    where: RubricaWhereUniqueInput
  }

  /**
   * Rubrica findFirst
   */
  export type RubricaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * Filter, which Rubrica to fetch.
     */
    where?: RubricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubricas to fetch.
     */
    orderBy?: RubricaOrderByWithRelationInput | RubricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rubricas.
     */
    cursor?: RubricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubricas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rubricas.
     */
    distinct?: RubricaScalarFieldEnum | RubricaScalarFieldEnum[]
  }

  /**
   * Rubrica findFirstOrThrow
   */
  export type RubricaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * Filter, which Rubrica to fetch.
     */
    where?: RubricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubricas to fetch.
     */
    orderBy?: RubricaOrderByWithRelationInput | RubricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rubricas.
     */
    cursor?: RubricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubricas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rubricas.
     */
    distinct?: RubricaScalarFieldEnum | RubricaScalarFieldEnum[]
  }

  /**
   * Rubrica findMany
   */
  export type RubricaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * Filter, which Rubricas to fetch.
     */
    where?: RubricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubricas to fetch.
     */
    orderBy?: RubricaOrderByWithRelationInput | RubricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rubricas.
     */
    cursor?: RubricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubricas.
     */
    skip?: number
    distinct?: RubricaScalarFieldEnum | RubricaScalarFieldEnum[]
  }

  /**
   * Rubrica create
   */
  export type RubricaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * The data needed to create a Rubrica.
     */
    data: XOR<RubricaCreateInput, RubricaUncheckedCreateInput>
  }

  /**
   * Rubrica createMany
   */
  export type RubricaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rubricas.
     */
    data: RubricaCreateManyInput | RubricaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rubrica createManyAndReturn
   */
  export type RubricaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * The data used to create many Rubricas.
     */
    data: RubricaCreateManyInput | RubricaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rubrica update
   */
  export type RubricaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * The data needed to update a Rubrica.
     */
    data: XOR<RubricaUpdateInput, RubricaUncheckedUpdateInput>
    /**
     * Choose, which Rubrica to update.
     */
    where: RubricaWhereUniqueInput
  }

  /**
   * Rubrica updateMany
   */
  export type RubricaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rubricas.
     */
    data: XOR<RubricaUpdateManyMutationInput, RubricaUncheckedUpdateManyInput>
    /**
     * Filter which Rubricas to update
     */
    where?: RubricaWhereInput
    /**
     * Limit how many Rubricas to update.
     */
    limit?: number
  }

  /**
   * Rubrica updateManyAndReturn
   */
  export type RubricaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * The data used to update Rubricas.
     */
    data: XOR<RubricaUpdateManyMutationInput, RubricaUncheckedUpdateManyInput>
    /**
     * Filter which Rubricas to update
     */
    where?: RubricaWhereInput
    /**
     * Limit how many Rubricas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rubrica upsert
   */
  export type RubricaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * The filter to search for the Rubrica to update in case it exists.
     */
    where: RubricaWhereUniqueInput
    /**
     * In case the Rubrica found by the `where` argument doesn't exist, create a new Rubrica with this data.
     */
    create: XOR<RubricaCreateInput, RubricaUncheckedCreateInput>
    /**
     * In case the Rubrica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RubricaUpdateInput, RubricaUncheckedUpdateInput>
  }

  /**
   * Rubrica delete
   */
  export type RubricaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
    /**
     * Filter which Rubrica to delete.
     */
    where: RubricaWhereUniqueInput
  }

  /**
   * Rubrica deleteMany
   */
  export type RubricaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rubricas to delete
     */
    where?: RubricaWhereInput
    /**
     * Limit how many Rubricas to delete.
     */
    limit?: number
  }

  /**
   * Rubrica without action
   */
  export type RubricaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubrica
     */
    select?: RubricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubrica
     */
    omit?: RubricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricaInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre_completo: string | null
    email: string | null
    hash_contrasena: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre_completo: string | null
    email: string | null
    hash_contrasena: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre_completo: number
    email: number
    hash_contrasena: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre_completo?: true
    email?: true
    hash_contrasena?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre_completo?: true
    email?: true
    hash_contrasena?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre_completo?: true
    email?: true
    hash_contrasena?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    email?: boolean
    hash_contrasena?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Estudiante?: boolean | Usuario$EstudianteArgs<ExtArgs>
    Jurado?: boolean | Usuario$JuradoArgs<ExtArgs>
    NRC?: boolean | Usuario$NRCArgs<ExtArgs>
    RolUsuario?: boolean | Usuario$RolUsuarioArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    email?: boolean
    hash_contrasena?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    email?: boolean
    hash_contrasena?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre_completo?: boolean
    email?: boolean
    hash_contrasena?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_completo" | "email" | "hash_contrasena" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Estudiante?: boolean | Usuario$EstudianteArgs<ExtArgs>
    Jurado?: boolean | Usuario$JuradoArgs<ExtArgs>
    NRC?: boolean | Usuario$NRCArgs<ExtArgs>
    RolUsuario?: boolean | Usuario$RolUsuarioArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      Estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
      Jurado: Prisma.$JuradoPayload<ExtArgs> | null
      NRC: Prisma.$NRCPayload<ExtArgs>[]
      RolUsuario: Prisma.$RolUsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_completo: string
      email: string
      hash_contrasena: string
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Estudiante<T extends Usuario$EstudianteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$EstudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Jurado<T extends Usuario$JuradoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$JuradoArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    NRC<T extends Usuario$NRCArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$NRCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RolUsuario<T extends Usuario$RolUsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$RolUsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre_completo: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly hash_contrasena: FieldRef<"Usuario", 'String'>
    readonly create_at: FieldRef<"Usuario", 'DateTime'>
    readonly update_at: FieldRef<"Usuario", 'DateTime'>
    readonly deleted: FieldRef<"Usuario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.Estudiante
   */
  export type Usuario$EstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * Usuario.Jurado
   */
  export type Usuario$JuradoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jurado
     */
    select?: JuradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jurado
     */
    omit?: JuradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuradoInclude<ExtArgs> | null
    where?: JuradoWhereInput
  }

  /**
   * Usuario.NRC
   */
  export type Usuario$NRCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRC
     */
    select?: NRCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NRC
     */
    omit?: NRCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRCInclude<ExtArgs> | null
    where?: NRCWhereInput
    orderBy?: NRCOrderByWithRelationInput | NRCOrderByWithRelationInput[]
    cursor?: NRCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NRCScalarFieldEnum | NRCScalarFieldEnum[]
  }

  /**
   * Usuario.RolUsuario
   */
  export type Usuario$RolUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolUsuario
     */
    select?: RolUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolUsuario
     */
    omit?: RolUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolUsuarioInclude<ExtArgs> | null
    where?: RolUsuarioWhereInput
    orderBy?: RolUsuarioOrderByWithRelationInput | RolUsuarioOrderByWithRelationInput[]
    cursor?: RolUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolUsuarioScalarFieldEnum | RolUsuarioScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Videojuego
   */

  export type AggregateVideojuego = {
    _count: VideojuegoCountAggregateOutputType | null
    _avg: VideojuegoAvgAggregateOutputType | null
    _sum: VideojuegoSumAggregateOutputType | null
    _min: VideojuegoMinAggregateOutputType | null
    _max: VideojuegoMaxAggregateOutputType | null
  }

  export type VideojuegoAvgAggregateOutputType = {
    id: number | null
    equipo_id: number | null
  }

  export type VideojuegoSumAggregateOutputType = {
    id: number | null
    equipo_id: number | null
  }

  export type VideojuegoMinAggregateOutputType = {
    id: number | null
    equipo_id: number | null
    nombre_videojuego: string | null
    descripcion: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type VideojuegoMaxAggregateOutputType = {
    id: number | null
    equipo_id: number | null
    nombre_videojuego: string | null
    descripcion: string | null
    create_at: Date | null
    update_at: Date | null
    deleted: boolean | null
  }

  export type VideojuegoCountAggregateOutputType = {
    id: number
    equipo_id: number
    nombre_videojuego: number
    descripcion: number
    create_at: number
    update_at: number
    deleted: number
    _all: number
  }


  export type VideojuegoAvgAggregateInputType = {
    id?: true
    equipo_id?: true
  }

  export type VideojuegoSumAggregateInputType = {
    id?: true
    equipo_id?: true
  }

  export type VideojuegoMinAggregateInputType = {
    id?: true
    equipo_id?: true
    nombre_videojuego?: true
    descripcion?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type VideojuegoMaxAggregateInputType = {
    id?: true
    equipo_id?: true
    nombre_videojuego?: true
    descripcion?: true
    create_at?: true
    update_at?: true
    deleted?: true
  }

  export type VideojuegoCountAggregateInputType = {
    id?: true
    equipo_id?: true
    nombre_videojuego?: true
    descripcion?: true
    create_at?: true
    update_at?: true
    deleted?: true
    _all?: true
  }

  export type VideojuegoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videojuego to aggregate.
     */
    where?: VideojuegoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videojuegos to fetch.
     */
    orderBy?: VideojuegoOrderByWithRelationInput | VideojuegoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideojuegoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videojuegos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videojuegos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videojuegos
    **/
    _count?: true | VideojuegoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideojuegoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideojuegoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideojuegoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideojuegoMaxAggregateInputType
  }

  export type GetVideojuegoAggregateType<T extends VideojuegoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideojuego]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideojuego[P]>
      : GetScalarType<T[P], AggregateVideojuego[P]>
  }




  export type VideojuegoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideojuegoWhereInput
    orderBy?: VideojuegoOrderByWithAggregationInput | VideojuegoOrderByWithAggregationInput[]
    by: VideojuegoScalarFieldEnum[] | VideojuegoScalarFieldEnum
    having?: VideojuegoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideojuegoCountAggregateInputType | true
    _avg?: VideojuegoAvgAggregateInputType
    _sum?: VideojuegoSumAggregateInputType
    _min?: VideojuegoMinAggregateInputType
    _max?: VideojuegoMaxAggregateInputType
  }

  export type VideojuegoGroupByOutputType = {
    id: number
    equipo_id: number
    nombre_videojuego: string
    descripcion: string
    create_at: Date
    update_at: Date
    deleted: boolean
    _count: VideojuegoCountAggregateOutputType | null
    _avg: VideojuegoAvgAggregateOutputType | null
    _sum: VideojuegoSumAggregateOutputType | null
    _min: VideojuegoMinAggregateOutputType | null
    _max: VideojuegoMaxAggregateOutputType | null
  }

  type GetVideojuegoGroupByPayload<T extends VideojuegoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideojuegoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideojuegoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideojuegoGroupByOutputType[P]>
            : GetScalarType<T[P], VideojuegoGroupByOutputType[P]>
        }
      >
    >


  export type VideojuegoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipo_id?: boolean
    nombre_videojuego?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Evaluacion?: boolean | Videojuego$EvaluacionArgs<ExtArgs>
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    VideojuegoAsignado?: boolean | Videojuego$VideojuegoAsignadoArgs<ExtArgs>
    _count?: boolean | VideojuegoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videojuego"]>

  export type VideojuegoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipo_id?: boolean
    nombre_videojuego?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videojuego"]>

  export type VideojuegoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipo_id?: boolean
    nombre_videojuego?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videojuego"]>

  export type VideojuegoSelectScalar = {
    id?: boolean
    equipo_id?: boolean
    nombre_videojuego?: boolean
    descripcion?: boolean
    create_at?: boolean
    update_at?: boolean
    deleted?: boolean
  }

  export type VideojuegoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipo_id" | "nombre_videojuego" | "descripcion" | "create_at" | "update_at" | "deleted", ExtArgs["result"]["videojuego"]>
  export type VideojuegoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Evaluacion?: boolean | Videojuego$EvaluacionArgs<ExtArgs>
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
    VideojuegoAsignado?: boolean | Videojuego$VideojuegoAsignadoArgs<ExtArgs>
    _count?: boolean | VideojuegoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideojuegoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
  }
  export type VideojuegoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipo?: boolean | EquipoDefaultArgs<ExtArgs>
  }

  export type $VideojuegoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Videojuego"
    objects: {
      Evaluacion: Prisma.$EvaluacionPayload<ExtArgs>[]
      Equipo: Prisma.$EquipoPayload<ExtArgs>
      VideojuegoAsignado: Prisma.$VideojuegoAsignadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      equipo_id: number
      nombre_videojuego: string
      descripcion: string
      create_at: Date
      update_at: Date
      deleted: boolean
    }, ExtArgs["result"]["videojuego"]>
    composites: {}
  }

  type VideojuegoGetPayload<S extends boolean | null | undefined | VideojuegoDefaultArgs> = $Result.GetResult<Prisma.$VideojuegoPayload, S>

  type VideojuegoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideojuegoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideojuegoCountAggregateInputType | true
    }

  export interface VideojuegoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Videojuego'], meta: { name: 'Videojuego' } }
    /**
     * Find zero or one Videojuego that matches the filter.
     * @param {VideojuegoFindUniqueArgs} args - Arguments to find a Videojuego
     * @example
     * // Get one Videojuego
     * const videojuego = await prisma.videojuego.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideojuegoFindUniqueArgs>(args: SelectSubset<T, VideojuegoFindUniqueArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videojuego that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideojuegoFindUniqueOrThrowArgs} args - Arguments to find a Videojuego
     * @example
     * // Get one Videojuego
     * const videojuego = await prisma.videojuego.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideojuegoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideojuegoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videojuego that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoFindFirstArgs} args - Arguments to find a Videojuego
     * @example
     * // Get one Videojuego
     * const videojuego = await prisma.videojuego.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideojuegoFindFirstArgs>(args?: SelectSubset<T, VideojuegoFindFirstArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videojuego that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoFindFirstOrThrowArgs} args - Arguments to find a Videojuego
     * @example
     * // Get one Videojuego
     * const videojuego = await prisma.videojuego.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideojuegoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideojuegoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videojuegos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videojuegos
     * const videojuegos = await prisma.videojuego.findMany()
     * 
     * // Get first 10 Videojuegos
     * const videojuegos = await prisma.videojuego.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videojuegoWithIdOnly = await prisma.videojuego.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideojuegoFindManyArgs>(args?: SelectSubset<T, VideojuegoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videojuego.
     * @param {VideojuegoCreateArgs} args - Arguments to create a Videojuego.
     * @example
     * // Create one Videojuego
     * const Videojuego = await prisma.videojuego.create({
     *   data: {
     *     // ... data to create a Videojuego
     *   }
     * })
     * 
     */
    create<T extends VideojuegoCreateArgs>(args: SelectSubset<T, VideojuegoCreateArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videojuegos.
     * @param {VideojuegoCreateManyArgs} args - Arguments to create many Videojuegos.
     * @example
     * // Create many Videojuegos
     * const videojuego = await prisma.videojuego.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideojuegoCreateManyArgs>(args?: SelectSubset<T, VideojuegoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videojuegos and returns the data saved in the database.
     * @param {VideojuegoCreateManyAndReturnArgs} args - Arguments to create many Videojuegos.
     * @example
     * // Create many Videojuegos
     * const videojuego = await prisma.videojuego.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videojuegos and only return the `id`
     * const videojuegoWithIdOnly = await prisma.videojuego.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideojuegoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideojuegoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Videojuego.
     * @param {VideojuegoDeleteArgs} args - Arguments to delete one Videojuego.
     * @example
     * // Delete one Videojuego
     * const Videojuego = await prisma.videojuego.delete({
     *   where: {
     *     // ... filter to delete one Videojuego
     *   }
     * })
     * 
     */
    delete<T extends VideojuegoDeleteArgs>(args: SelectSubset<T, VideojuegoDeleteArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videojuego.
     * @param {VideojuegoUpdateArgs} args - Arguments to update one Videojuego.
     * @example
     * // Update one Videojuego
     * const videojuego = await prisma.videojuego.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideojuegoUpdateArgs>(args: SelectSubset<T, VideojuegoUpdateArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videojuegos.
     * @param {VideojuegoDeleteManyArgs} args - Arguments to filter Videojuegos to delete.
     * @example
     * // Delete a few Videojuegos
     * const { count } = await prisma.videojuego.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideojuegoDeleteManyArgs>(args?: SelectSubset<T, VideojuegoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videojuegos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videojuegos
     * const videojuego = await prisma.videojuego.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideojuegoUpdateManyArgs>(args: SelectSubset<T, VideojuegoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videojuegos and returns the data updated in the database.
     * @param {VideojuegoUpdateManyAndReturnArgs} args - Arguments to update many Videojuegos.
     * @example
     * // Update many Videojuegos
     * const videojuego = await prisma.videojuego.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videojuegos and only return the `id`
     * const videojuegoWithIdOnly = await prisma.videojuego.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideojuegoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideojuegoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Videojuego.
     * @param {VideojuegoUpsertArgs} args - Arguments to update or create a Videojuego.
     * @example
     * // Update or create a Videojuego
     * const videojuego = await prisma.videojuego.upsert({
     *   create: {
     *     // ... data to create a Videojuego
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videojuego we want to update
     *   }
     * })
     */
    upsert<T extends VideojuegoUpsertArgs>(args: SelectSubset<T, VideojuegoUpsertArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videojuegos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoCountArgs} args - Arguments to filter Videojuegos to count.
     * @example
     * // Count the number of Videojuegos
     * const count = await prisma.videojuego.count({
     *   where: {
     *     // ... the filter for the Videojuegos we want to count
     *   }
     * })
    **/
    count<T extends VideojuegoCountArgs>(
      args?: Subset<T, VideojuegoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideojuegoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videojuego.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideojuegoAggregateArgs>(args: Subset<T, VideojuegoAggregateArgs>): Prisma.PrismaPromise<GetVideojuegoAggregateType<T>>

    /**
     * Group by Videojuego.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideojuegoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideojuegoGroupByArgs['orderBy'] }
        : { orderBy?: VideojuegoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideojuegoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideojuegoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Videojuego model
   */
  readonly fields: VideojuegoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Videojuego.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideojuegoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Evaluacion<T extends Videojuego$EvaluacionArgs<ExtArgs> = {}>(args?: Subset<T, Videojuego$EvaluacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Equipo<T extends EquipoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipoDefaultArgs<ExtArgs>>): Prisma__EquipoClient<$Result.GetResult<Prisma.$EquipoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    VideojuegoAsignado<T extends Videojuego$VideojuegoAsignadoArgs<ExtArgs> = {}>(args?: Subset<T, Videojuego$VideojuegoAsignadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Videojuego model
   */
  interface VideojuegoFieldRefs {
    readonly id: FieldRef<"Videojuego", 'Int'>
    readonly equipo_id: FieldRef<"Videojuego", 'Int'>
    readonly nombre_videojuego: FieldRef<"Videojuego", 'String'>
    readonly descripcion: FieldRef<"Videojuego", 'String'>
    readonly create_at: FieldRef<"Videojuego", 'DateTime'>
    readonly update_at: FieldRef<"Videojuego", 'DateTime'>
    readonly deleted: FieldRef<"Videojuego", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Videojuego findUnique
   */
  export type VideojuegoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * Filter, which Videojuego to fetch.
     */
    where: VideojuegoWhereUniqueInput
  }

  /**
   * Videojuego findUniqueOrThrow
   */
  export type VideojuegoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * Filter, which Videojuego to fetch.
     */
    where: VideojuegoWhereUniqueInput
  }

  /**
   * Videojuego findFirst
   */
  export type VideojuegoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * Filter, which Videojuego to fetch.
     */
    where?: VideojuegoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videojuegos to fetch.
     */
    orderBy?: VideojuegoOrderByWithRelationInput | VideojuegoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videojuegos.
     */
    cursor?: VideojuegoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videojuegos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videojuegos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videojuegos.
     */
    distinct?: VideojuegoScalarFieldEnum | VideojuegoScalarFieldEnum[]
  }

  /**
   * Videojuego findFirstOrThrow
   */
  export type VideojuegoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * Filter, which Videojuego to fetch.
     */
    where?: VideojuegoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videojuegos to fetch.
     */
    orderBy?: VideojuegoOrderByWithRelationInput | VideojuegoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videojuegos.
     */
    cursor?: VideojuegoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videojuegos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videojuegos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videojuegos.
     */
    distinct?: VideojuegoScalarFieldEnum | VideojuegoScalarFieldEnum[]
  }

  /**
   * Videojuego findMany
   */
  export type VideojuegoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * Filter, which Videojuegos to fetch.
     */
    where?: VideojuegoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videojuegos to fetch.
     */
    orderBy?: VideojuegoOrderByWithRelationInput | VideojuegoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videojuegos.
     */
    cursor?: VideojuegoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videojuegos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videojuegos.
     */
    skip?: number
    distinct?: VideojuegoScalarFieldEnum | VideojuegoScalarFieldEnum[]
  }

  /**
   * Videojuego create
   */
  export type VideojuegoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * The data needed to create a Videojuego.
     */
    data: XOR<VideojuegoCreateInput, VideojuegoUncheckedCreateInput>
  }

  /**
   * Videojuego createMany
   */
  export type VideojuegoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videojuegos.
     */
    data: VideojuegoCreateManyInput | VideojuegoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Videojuego createManyAndReturn
   */
  export type VideojuegoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * The data used to create many Videojuegos.
     */
    data: VideojuegoCreateManyInput | VideojuegoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Videojuego update
   */
  export type VideojuegoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * The data needed to update a Videojuego.
     */
    data: XOR<VideojuegoUpdateInput, VideojuegoUncheckedUpdateInput>
    /**
     * Choose, which Videojuego to update.
     */
    where: VideojuegoWhereUniqueInput
  }

  /**
   * Videojuego updateMany
   */
  export type VideojuegoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videojuegos.
     */
    data: XOR<VideojuegoUpdateManyMutationInput, VideojuegoUncheckedUpdateManyInput>
    /**
     * Filter which Videojuegos to update
     */
    where?: VideojuegoWhereInput
    /**
     * Limit how many Videojuegos to update.
     */
    limit?: number
  }

  /**
   * Videojuego updateManyAndReturn
   */
  export type VideojuegoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * The data used to update Videojuegos.
     */
    data: XOR<VideojuegoUpdateManyMutationInput, VideojuegoUncheckedUpdateManyInput>
    /**
     * Filter which Videojuegos to update
     */
    where?: VideojuegoWhereInput
    /**
     * Limit how many Videojuegos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Videojuego upsert
   */
  export type VideojuegoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * The filter to search for the Videojuego to update in case it exists.
     */
    where: VideojuegoWhereUniqueInput
    /**
     * In case the Videojuego found by the `where` argument doesn't exist, create a new Videojuego with this data.
     */
    create: XOR<VideojuegoCreateInput, VideojuegoUncheckedCreateInput>
    /**
     * In case the Videojuego was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideojuegoUpdateInput, VideojuegoUncheckedUpdateInput>
  }

  /**
   * Videojuego delete
   */
  export type VideojuegoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
    /**
     * Filter which Videojuego to delete.
     */
    where: VideojuegoWhereUniqueInput
  }

  /**
   * Videojuego deleteMany
   */
  export type VideojuegoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videojuegos to delete
     */
    where?: VideojuegoWhereInput
    /**
     * Limit how many Videojuegos to delete.
     */
    limit?: number
  }

  /**
   * Videojuego.Evaluacion
   */
  export type Videojuego$EvaluacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluacion
     */
    omit?: EvaluacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionInclude<ExtArgs> | null
    where?: EvaluacionWhereInput
    orderBy?: EvaluacionOrderByWithRelationInput | EvaluacionOrderByWithRelationInput[]
    cursor?: EvaluacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluacionScalarFieldEnum | EvaluacionScalarFieldEnum[]
  }

  /**
   * Videojuego.VideojuegoAsignado
   */
  export type Videojuego$VideojuegoAsignadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    where?: VideojuegoAsignadoWhereInput
    orderBy?: VideojuegoAsignadoOrderByWithRelationInput | VideojuegoAsignadoOrderByWithRelationInput[]
    cursor?: VideojuegoAsignadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideojuegoAsignadoScalarFieldEnum | VideojuegoAsignadoScalarFieldEnum[]
  }

  /**
   * Videojuego without action
   */
  export type VideojuegoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videojuego
     */
    select?: VideojuegoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videojuego
     */
    omit?: VideojuegoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoInclude<ExtArgs> | null
  }


  /**
   * Model VideojuegoAsignado
   */

  export type AggregateVideojuegoAsignado = {
    _count: VideojuegoAsignadoCountAggregateOutputType | null
    _avg: VideojuegoAsignadoAvgAggregateOutputType | null
    _sum: VideojuegoAsignadoSumAggregateOutputType | null
    _min: VideojuegoAsignadoMinAggregateOutputType | null
    _max: VideojuegoAsignadoMaxAggregateOutputType | null
  }

  export type VideojuegoAsignadoAvgAggregateOutputType = {
    id_videojuego: number | null
    id_jurado: number | null
  }

  export type VideojuegoAsignadoSumAggregateOutputType = {
    id_videojuego: number | null
    id_jurado: number | null
  }

  export type VideojuegoAsignadoMinAggregateOutputType = {
    id_videojuego: number | null
    id_jurado: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type VideojuegoAsignadoMaxAggregateOutputType = {
    id_videojuego: number | null
    id_jurado: number | null
    create_at: Date | null
    deleted: boolean | null
  }

  export type VideojuegoAsignadoCountAggregateOutputType = {
    id_videojuego: number
    id_jurado: number
    create_at: number
    deleted: number
    _all: number
  }


  export type VideojuegoAsignadoAvgAggregateInputType = {
    id_videojuego?: true
    id_jurado?: true
  }

  export type VideojuegoAsignadoSumAggregateInputType = {
    id_videojuego?: true
    id_jurado?: true
  }

  export type VideojuegoAsignadoMinAggregateInputType = {
    id_videojuego?: true
    id_jurado?: true
    create_at?: true
    deleted?: true
  }

  export type VideojuegoAsignadoMaxAggregateInputType = {
    id_videojuego?: true
    id_jurado?: true
    create_at?: true
    deleted?: true
  }

  export type VideojuegoAsignadoCountAggregateInputType = {
    id_videojuego?: true
    id_jurado?: true
    create_at?: true
    deleted?: true
    _all?: true
  }

  export type VideojuegoAsignadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideojuegoAsignado to aggregate.
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideojuegoAsignados to fetch.
     */
    orderBy?: VideojuegoAsignadoOrderByWithRelationInput | VideojuegoAsignadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideojuegoAsignadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideojuegoAsignados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideojuegoAsignados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideojuegoAsignados
    **/
    _count?: true | VideojuegoAsignadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideojuegoAsignadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideojuegoAsignadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideojuegoAsignadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideojuegoAsignadoMaxAggregateInputType
  }

  export type GetVideojuegoAsignadoAggregateType<T extends VideojuegoAsignadoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideojuegoAsignado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideojuegoAsignado[P]>
      : GetScalarType<T[P], AggregateVideojuegoAsignado[P]>
  }




  export type VideojuegoAsignadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideojuegoAsignadoWhereInput
    orderBy?: VideojuegoAsignadoOrderByWithAggregationInput | VideojuegoAsignadoOrderByWithAggregationInput[]
    by: VideojuegoAsignadoScalarFieldEnum[] | VideojuegoAsignadoScalarFieldEnum
    having?: VideojuegoAsignadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideojuegoAsignadoCountAggregateInputType | true
    _avg?: VideojuegoAsignadoAvgAggregateInputType
    _sum?: VideojuegoAsignadoSumAggregateInputType
    _min?: VideojuegoAsignadoMinAggregateInputType
    _max?: VideojuegoAsignadoMaxAggregateInputType
  }

  export type VideojuegoAsignadoGroupByOutputType = {
    id_videojuego: number
    id_jurado: number
    create_at: Date
    deleted: boolean
    _count: VideojuegoAsignadoCountAggregateOutputType | null
    _avg: VideojuegoAsignadoAvgAggregateOutputType | null
    _sum: VideojuegoAsignadoSumAggregateOutputType | null
    _min: VideojuegoAsignadoMinAggregateOutputType | null
    _max: VideojuegoAsignadoMaxAggregateOutputType | null
  }

  type GetVideojuegoAsignadoGroupByPayload<T extends VideojuegoAsignadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideojuegoAsignadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideojuegoAsignadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideojuegoAsignadoGroupByOutputType[P]>
            : GetScalarType<T[P], VideojuegoAsignadoGroupByOutputType[P]>
        }
      >
    >


  export type VideojuegoAsignadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_videojuego?: boolean
    id_jurado?: boolean
    create_at?: boolean
    deleted?: boolean
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videojuegoAsignado"]>

  export type VideojuegoAsignadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_videojuego?: boolean
    id_jurado?: boolean
    create_at?: boolean
    deleted?: boolean
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videojuegoAsignado"]>

  export type VideojuegoAsignadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_videojuego?: boolean
    id_jurado?: boolean
    create_at?: boolean
    deleted?: boolean
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videojuegoAsignado"]>

  export type VideojuegoAsignadoSelectScalar = {
    id_videojuego?: boolean
    id_jurado?: boolean
    create_at?: boolean
    deleted?: boolean
  }

  export type VideojuegoAsignadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_videojuego" | "id_jurado" | "create_at" | "deleted", ExtArgs["result"]["videojuegoAsignado"]>
  export type VideojuegoAsignadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }
  export type VideojuegoAsignadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }
  export type VideojuegoAsignadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jurado?: boolean | JuradoDefaultArgs<ExtArgs>
    Videojuego?: boolean | VideojuegoDefaultArgs<ExtArgs>
  }

  export type $VideojuegoAsignadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideojuegoAsignado"
    objects: {
      Jurado: Prisma.$JuradoPayload<ExtArgs>
      Videojuego: Prisma.$VideojuegoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_videojuego: number
      id_jurado: number
      create_at: Date
      deleted: boolean
    }, ExtArgs["result"]["videojuegoAsignado"]>
    composites: {}
  }

  type VideojuegoAsignadoGetPayload<S extends boolean | null | undefined | VideojuegoAsignadoDefaultArgs> = $Result.GetResult<Prisma.$VideojuegoAsignadoPayload, S>

  type VideojuegoAsignadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideojuegoAsignadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideojuegoAsignadoCountAggregateInputType | true
    }

  export interface VideojuegoAsignadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideojuegoAsignado'], meta: { name: 'VideojuegoAsignado' } }
    /**
     * Find zero or one VideojuegoAsignado that matches the filter.
     * @param {VideojuegoAsignadoFindUniqueArgs} args - Arguments to find a VideojuegoAsignado
     * @example
     * // Get one VideojuegoAsignado
     * const videojuegoAsignado = await prisma.videojuegoAsignado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideojuegoAsignadoFindUniqueArgs>(args: SelectSubset<T, VideojuegoAsignadoFindUniqueArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideojuegoAsignado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideojuegoAsignadoFindUniqueOrThrowArgs} args - Arguments to find a VideojuegoAsignado
     * @example
     * // Get one VideojuegoAsignado
     * const videojuegoAsignado = await prisma.videojuegoAsignado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideojuegoAsignadoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideojuegoAsignadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideojuegoAsignado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoFindFirstArgs} args - Arguments to find a VideojuegoAsignado
     * @example
     * // Get one VideojuegoAsignado
     * const videojuegoAsignado = await prisma.videojuegoAsignado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideojuegoAsignadoFindFirstArgs>(args?: SelectSubset<T, VideojuegoAsignadoFindFirstArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideojuegoAsignado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoFindFirstOrThrowArgs} args - Arguments to find a VideojuegoAsignado
     * @example
     * // Get one VideojuegoAsignado
     * const videojuegoAsignado = await prisma.videojuegoAsignado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideojuegoAsignadoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideojuegoAsignadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideojuegoAsignados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideojuegoAsignados
     * const videojuegoAsignados = await prisma.videojuegoAsignado.findMany()
     * 
     * // Get first 10 VideojuegoAsignados
     * const videojuegoAsignados = await prisma.videojuegoAsignado.findMany({ take: 10 })
     * 
     * // Only select the `id_videojuego`
     * const videojuegoAsignadoWithId_videojuegoOnly = await prisma.videojuegoAsignado.findMany({ select: { id_videojuego: true } })
     * 
     */
    findMany<T extends VideojuegoAsignadoFindManyArgs>(args?: SelectSubset<T, VideojuegoAsignadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideojuegoAsignado.
     * @param {VideojuegoAsignadoCreateArgs} args - Arguments to create a VideojuegoAsignado.
     * @example
     * // Create one VideojuegoAsignado
     * const VideojuegoAsignado = await prisma.videojuegoAsignado.create({
     *   data: {
     *     // ... data to create a VideojuegoAsignado
     *   }
     * })
     * 
     */
    create<T extends VideojuegoAsignadoCreateArgs>(args: SelectSubset<T, VideojuegoAsignadoCreateArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideojuegoAsignados.
     * @param {VideojuegoAsignadoCreateManyArgs} args - Arguments to create many VideojuegoAsignados.
     * @example
     * // Create many VideojuegoAsignados
     * const videojuegoAsignado = await prisma.videojuegoAsignado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideojuegoAsignadoCreateManyArgs>(args?: SelectSubset<T, VideojuegoAsignadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideojuegoAsignados and returns the data saved in the database.
     * @param {VideojuegoAsignadoCreateManyAndReturnArgs} args - Arguments to create many VideojuegoAsignados.
     * @example
     * // Create many VideojuegoAsignados
     * const videojuegoAsignado = await prisma.videojuegoAsignado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideojuegoAsignados and only return the `id_videojuego`
     * const videojuegoAsignadoWithId_videojuegoOnly = await prisma.videojuegoAsignado.createManyAndReturn({
     *   select: { id_videojuego: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideojuegoAsignadoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideojuegoAsignadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideojuegoAsignado.
     * @param {VideojuegoAsignadoDeleteArgs} args - Arguments to delete one VideojuegoAsignado.
     * @example
     * // Delete one VideojuegoAsignado
     * const VideojuegoAsignado = await prisma.videojuegoAsignado.delete({
     *   where: {
     *     // ... filter to delete one VideojuegoAsignado
     *   }
     * })
     * 
     */
    delete<T extends VideojuegoAsignadoDeleteArgs>(args: SelectSubset<T, VideojuegoAsignadoDeleteArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideojuegoAsignado.
     * @param {VideojuegoAsignadoUpdateArgs} args - Arguments to update one VideojuegoAsignado.
     * @example
     * // Update one VideojuegoAsignado
     * const videojuegoAsignado = await prisma.videojuegoAsignado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideojuegoAsignadoUpdateArgs>(args: SelectSubset<T, VideojuegoAsignadoUpdateArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideojuegoAsignados.
     * @param {VideojuegoAsignadoDeleteManyArgs} args - Arguments to filter VideojuegoAsignados to delete.
     * @example
     * // Delete a few VideojuegoAsignados
     * const { count } = await prisma.videojuegoAsignado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideojuegoAsignadoDeleteManyArgs>(args?: SelectSubset<T, VideojuegoAsignadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideojuegoAsignados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideojuegoAsignados
     * const videojuegoAsignado = await prisma.videojuegoAsignado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideojuegoAsignadoUpdateManyArgs>(args: SelectSubset<T, VideojuegoAsignadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideojuegoAsignados and returns the data updated in the database.
     * @param {VideojuegoAsignadoUpdateManyAndReturnArgs} args - Arguments to update many VideojuegoAsignados.
     * @example
     * // Update many VideojuegoAsignados
     * const videojuegoAsignado = await prisma.videojuegoAsignado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideojuegoAsignados and only return the `id_videojuego`
     * const videojuegoAsignadoWithId_videojuegoOnly = await prisma.videojuegoAsignado.updateManyAndReturn({
     *   select: { id_videojuego: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideojuegoAsignadoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideojuegoAsignadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideojuegoAsignado.
     * @param {VideojuegoAsignadoUpsertArgs} args - Arguments to update or create a VideojuegoAsignado.
     * @example
     * // Update or create a VideojuegoAsignado
     * const videojuegoAsignado = await prisma.videojuegoAsignado.upsert({
     *   create: {
     *     // ... data to create a VideojuegoAsignado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideojuegoAsignado we want to update
     *   }
     * })
     */
    upsert<T extends VideojuegoAsignadoUpsertArgs>(args: SelectSubset<T, VideojuegoAsignadoUpsertArgs<ExtArgs>>): Prisma__VideojuegoAsignadoClient<$Result.GetResult<Prisma.$VideojuegoAsignadoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideojuegoAsignados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoCountArgs} args - Arguments to filter VideojuegoAsignados to count.
     * @example
     * // Count the number of VideojuegoAsignados
     * const count = await prisma.videojuegoAsignado.count({
     *   where: {
     *     // ... the filter for the VideojuegoAsignados we want to count
     *   }
     * })
    **/
    count<T extends VideojuegoAsignadoCountArgs>(
      args?: Subset<T, VideojuegoAsignadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideojuegoAsignadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideojuegoAsignado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideojuegoAsignadoAggregateArgs>(args: Subset<T, VideojuegoAsignadoAggregateArgs>): Prisma.PrismaPromise<GetVideojuegoAsignadoAggregateType<T>>

    /**
     * Group by VideojuegoAsignado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideojuegoAsignadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideojuegoAsignadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideojuegoAsignadoGroupByArgs['orderBy'] }
        : { orderBy?: VideojuegoAsignadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideojuegoAsignadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideojuegoAsignadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideojuegoAsignado model
   */
  readonly fields: VideojuegoAsignadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideojuegoAsignado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideojuegoAsignadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Jurado<T extends JuradoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JuradoDefaultArgs<ExtArgs>>): Prisma__JuradoClient<$Result.GetResult<Prisma.$JuradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Videojuego<T extends VideojuegoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideojuegoDefaultArgs<ExtArgs>>): Prisma__VideojuegoClient<$Result.GetResult<Prisma.$VideojuegoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideojuegoAsignado model
   */
  interface VideojuegoAsignadoFieldRefs {
    readonly id_videojuego: FieldRef<"VideojuegoAsignado", 'Int'>
    readonly id_jurado: FieldRef<"VideojuegoAsignado", 'Int'>
    readonly create_at: FieldRef<"VideojuegoAsignado", 'DateTime'>
    readonly deleted: FieldRef<"VideojuegoAsignado", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * VideojuegoAsignado findUnique
   */
  export type VideojuegoAsignadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * Filter, which VideojuegoAsignado to fetch.
     */
    where: VideojuegoAsignadoWhereUniqueInput
  }

  /**
   * VideojuegoAsignado findUniqueOrThrow
   */
  export type VideojuegoAsignadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * Filter, which VideojuegoAsignado to fetch.
     */
    where: VideojuegoAsignadoWhereUniqueInput
  }

  /**
   * VideojuegoAsignado findFirst
   */
  export type VideojuegoAsignadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * Filter, which VideojuegoAsignado to fetch.
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideojuegoAsignados to fetch.
     */
    orderBy?: VideojuegoAsignadoOrderByWithRelationInput | VideojuegoAsignadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideojuegoAsignados.
     */
    cursor?: VideojuegoAsignadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideojuegoAsignados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideojuegoAsignados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideojuegoAsignados.
     */
    distinct?: VideojuegoAsignadoScalarFieldEnum | VideojuegoAsignadoScalarFieldEnum[]
  }

  /**
   * VideojuegoAsignado findFirstOrThrow
   */
  export type VideojuegoAsignadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * Filter, which VideojuegoAsignado to fetch.
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideojuegoAsignados to fetch.
     */
    orderBy?: VideojuegoAsignadoOrderByWithRelationInput | VideojuegoAsignadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideojuegoAsignados.
     */
    cursor?: VideojuegoAsignadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideojuegoAsignados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideojuegoAsignados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideojuegoAsignados.
     */
    distinct?: VideojuegoAsignadoScalarFieldEnum | VideojuegoAsignadoScalarFieldEnum[]
  }

  /**
   * VideojuegoAsignado findMany
   */
  export type VideojuegoAsignadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * Filter, which VideojuegoAsignados to fetch.
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideojuegoAsignados to fetch.
     */
    orderBy?: VideojuegoAsignadoOrderByWithRelationInput | VideojuegoAsignadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideojuegoAsignados.
     */
    cursor?: VideojuegoAsignadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideojuegoAsignados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideojuegoAsignados.
     */
    skip?: number
    distinct?: VideojuegoAsignadoScalarFieldEnum | VideojuegoAsignadoScalarFieldEnum[]
  }

  /**
   * VideojuegoAsignado create
   */
  export type VideojuegoAsignadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * The data needed to create a VideojuegoAsignado.
     */
    data: XOR<VideojuegoAsignadoCreateInput, VideojuegoAsignadoUncheckedCreateInput>
  }

  /**
   * VideojuegoAsignado createMany
   */
  export type VideojuegoAsignadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideojuegoAsignados.
     */
    data: VideojuegoAsignadoCreateManyInput | VideojuegoAsignadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideojuegoAsignado createManyAndReturn
   */
  export type VideojuegoAsignadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * The data used to create many VideojuegoAsignados.
     */
    data: VideojuegoAsignadoCreateManyInput | VideojuegoAsignadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideojuegoAsignado update
   */
  export type VideojuegoAsignadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * The data needed to update a VideojuegoAsignado.
     */
    data: XOR<VideojuegoAsignadoUpdateInput, VideojuegoAsignadoUncheckedUpdateInput>
    /**
     * Choose, which VideojuegoAsignado to update.
     */
    where: VideojuegoAsignadoWhereUniqueInput
  }

  /**
   * VideojuegoAsignado updateMany
   */
  export type VideojuegoAsignadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideojuegoAsignados.
     */
    data: XOR<VideojuegoAsignadoUpdateManyMutationInput, VideojuegoAsignadoUncheckedUpdateManyInput>
    /**
     * Filter which VideojuegoAsignados to update
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * Limit how many VideojuegoAsignados to update.
     */
    limit?: number
  }

  /**
   * VideojuegoAsignado updateManyAndReturn
   */
  export type VideojuegoAsignadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * The data used to update VideojuegoAsignados.
     */
    data: XOR<VideojuegoAsignadoUpdateManyMutationInput, VideojuegoAsignadoUncheckedUpdateManyInput>
    /**
     * Filter which VideojuegoAsignados to update
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * Limit how many VideojuegoAsignados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideojuegoAsignado upsert
   */
  export type VideojuegoAsignadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * The filter to search for the VideojuegoAsignado to update in case it exists.
     */
    where: VideojuegoAsignadoWhereUniqueInput
    /**
     * In case the VideojuegoAsignado found by the `where` argument doesn't exist, create a new VideojuegoAsignado with this data.
     */
    create: XOR<VideojuegoAsignadoCreateInput, VideojuegoAsignadoUncheckedCreateInput>
    /**
     * In case the VideojuegoAsignado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideojuegoAsignadoUpdateInput, VideojuegoAsignadoUncheckedUpdateInput>
  }

  /**
   * VideojuegoAsignado delete
   */
  export type VideojuegoAsignadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
    /**
     * Filter which VideojuegoAsignado to delete.
     */
    where: VideojuegoAsignadoWhereUniqueInput
  }

  /**
   * VideojuegoAsignado deleteMany
   */
  export type VideojuegoAsignadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideojuegoAsignados to delete
     */
    where?: VideojuegoAsignadoWhereInput
    /**
     * Limit how many VideojuegoAsignados to delete.
     */
    limit?: number
  }

  /**
   * VideojuegoAsignado without action
   */
  export type VideojuegoAsignadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideojuegoAsignado
     */
    select?: VideojuegoAsignadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideojuegoAsignado
     */
    omit?: VideojuegoAsignadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideojuegoAsignadoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CriterioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type CriterioScalarFieldEnum = (typeof CriterioScalarFieldEnum)[keyof typeof CriterioScalarFieldEnum]


  export const EndpointScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    metodo: 'metodo',
    num_parametros: 'num_parametros',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type EndpointScalarFieldEnum = (typeof EndpointScalarFieldEnum)[keyof typeof EndpointScalarFieldEnum]


  export const EquipoScalarFieldEnum: {
    id: 'id',
    nombre_equipo: 'nombre_equipo',
    url_logo: 'url_logo',
    estado: 'estado',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type EquipoScalarFieldEnum = (typeof EquipoScalarFieldEnum)[keyof typeof EquipoScalarFieldEnum]


  export const EstudianteScalarFieldEnum: {
    id: 'id',
    equipo_id: 'equipo_id',
    id_user: 'id_user',
    github: 'github',
    confirmado: 'confirmado',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type EstudianteScalarFieldEnum = (typeof EstudianteScalarFieldEnum)[keyof typeof EstudianteScalarFieldEnum]


  export const EstudianteNRCScalarFieldEnum: {
    id_nrc: 'id_nrc',
    id_estudiante: 'id_estudiante',
    create_at: 'create_at',
    deleted: 'deleted'
  };

  export type EstudianteNRCScalarFieldEnum = (typeof EstudianteNRCScalarFieldEnum)[keyof typeof EstudianteNRCScalarFieldEnum]


  export const EvaluacionScalarFieldEnum: {
    id: 'id',
    jurado_id: 'jurado_id',
    videojuego_id: 'videojuego_id',
    comentarios: 'comentarios',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type EvaluacionScalarFieldEnum = (typeof EvaluacionScalarFieldEnum)[keyof typeof EvaluacionScalarFieldEnum]


  export const JuradoScalarFieldEnum: {
    id: 'id',
    id_user: 'id_user',
    estado: 'estado',
    token_confirmacion: 'token_confirmacion',
    ultima_conexion: 'ultima_conexion',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type JuradoScalarFieldEnum = (typeof JuradoScalarFieldEnum)[keyof typeof JuradoScalarFieldEnum]


  export const MateriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    codigo: 'codigo',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type MateriaScalarFieldEnum = (typeof MateriaScalarFieldEnum)[keyof typeof MateriaScalarFieldEnum]


  export const NRCScalarFieldEnum: {
    codigo_nrc: 'codigo_nrc',
    materia_id: 'materia_id',
    profesor_id: 'profesor_id',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type NRCScalarFieldEnum = (typeof NRCScalarFieldEnum)[keyof typeof NRCScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const RolEndpointScalarFieldEnum: {
    id_rol: 'id_rol',
    id_endpoint: 'id_endpoint',
    create_at: 'create_at',
    deleted: 'deleted'
  };

  export type RolEndpointScalarFieldEnum = (typeof RolEndpointScalarFieldEnum)[keyof typeof RolEndpointScalarFieldEnum]


  export const RolUsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    id_rol: 'id_rol',
    create_at: 'create_at',
    deleted: 'deleted'
  };

  export type RolUsuarioScalarFieldEnum = (typeof RolUsuarioScalarFieldEnum)[keyof typeof RolUsuarioScalarFieldEnum]


  export const RubricaScalarFieldEnum: {
    id_evaluacion: 'id_evaluacion',
    id_criterio: 'id_criterio',
    valoracion: 'valoracion',
    create_at: 'create_at',
    deleted: 'deleted'
  };

  export type RubricaScalarFieldEnum = (typeof RubricaScalarFieldEnum)[keyof typeof RubricaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre_completo: 'nombre_completo',
    email: 'email',
    hash_contrasena: 'hash_contrasena',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const VideojuegoScalarFieldEnum: {
    id: 'id',
    equipo_id: 'equipo_id',
    nombre_videojuego: 'nombre_videojuego',
    descripcion: 'descripcion',
    create_at: 'create_at',
    update_at: 'update_at',
    deleted: 'deleted'
  };

  export type VideojuegoScalarFieldEnum = (typeof VideojuegoScalarFieldEnum)[keyof typeof VideojuegoScalarFieldEnum]


  export const VideojuegoAsignadoScalarFieldEnum: {
    id_videojuego: 'id_videojuego',
    id_jurado: 'id_jurado',
    create_at: 'create_at',
    deleted: 'deleted'
  };

  export type VideojuegoAsignadoScalarFieldEnum = (typeof VideojuegoAsignadoScalarFieldEnum)[keyof typeof VideojuegoAsignadoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Tipo'
   */
  export type EnumTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo'>
    


  /**
   * Reference to a field of type 'Tipo[]'
   */
  export type ListEnumTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo[]'>
    


  /**
   * Reference to a field of type 'Estado'
   */
  export type EnumEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Estado'>
    


  /**
   * Reference to a field of type 'Estado[]'
   */
  export type ListEnumEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Estado[]'>
    


  /**
   * Reference to a field of type 'EstadoJurado'
   */
  export type EnumEstadoJuradoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoJurado'>
    


  /**
   * Reference to a field of type 'EstadoJurado[]'
   */
  export type ListEnumEstadoJuradoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoJurado[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CriterioWhereInput = {
    AND?: CriterioWhereInput | CriterioWhereInput[]
    OR?: CriterioWhereInput[]
    NOT?: CriterioWhereInput | CriterioWhereInput[]
    id?: IntFilter<"Criterio"> | number
    nombre?: StringFilter<"Criterio"> | string
    descripcion?: StringFilter<"Criterio"> | string
    create_at?: DateTimeFilter<"Criterio"> | Date | string
    update_at?: DateTimeFilter<"Criterio"> | Date | string
    deleted?: BoolFilter<"Criterio"> | boolean
    Rubrica?: RubricaListRelationFilter
  }

  export type CriterioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Rubrica?: RubricaOrderByRelationAggregateInput
  }

  export type CriterioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CriterioWhereInput | CriterioWhereInput[]
    OR?: CriterioWhereInput[]
    NOT?: CriterioWhereInput | CriterioWhereInput[]
    nombre?: StringFilter<"Criterio"> | string
    descripcion?: StringFilter<"Criterio"> | string
    create_at?: DateTimeFilter<"Criterio"> | Date | string
    update_at?: DateTimeFilter<"Criterio"> | Date | string
    deleted?: BoolFilter<"Criterio"> | boolean
    Rubrica?: RubricaListRelationFilter
  }, "id">

  export type CriterioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: CriterioCountOrderByAggregateInput
    _avg?: CriterioAvgOrderByAggregateInput
    _max?: CriterioMaxOrderByAggregateInput
    _min?: CriterioMinOrderByAggregateInput
    _sum?: CriterioSumOrderByAggregateInput
  }

  export type CriterioScalarWhereWithAggregatesInput = {
    AND?: CriterioScalarWhereWithAggregatesInput | CriterioScalarWhereWithAggregatesInput[]
    OR?: CriterioScalarWhereWithAggregatesInput[]
    NOT?: CriterioScalarWhereWithAggregatesInput | CriterioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Criterio"> | number
    nombre?: StringWithAggregatesFilter<"Criterio"> | string
    descripcion?: StringWithAggregatesFilter<"Criterio"> | string
    create_at?: DateTimeWithAggregatesFilter<"Criterio"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Criterio"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Criterio"> | boolean
  }

  export type EndpointWhereInput = {
    AND?: EndpointWhereInput | EndpointWhereInput[]
    OR?: EndpointWhereInput[]
    NOT?: EndpointWhereInput | EndpointWhereInput[]
    id?: IntFilter<"Endpoint"> | number
    nombre?: StringNullableFilter<"Endpoint"> | string | null
    metodo?: EnumTipoFilter<"Endpoint"> | $Enums.Tipo
    num_parametros?: IntFilter<"Endpoint"> | number
    create_at?: DateTimeFilter<"Endpoint"> | Date | string
    update_at?: DateTimeFilter<"Endpoint"> | Date | string
    deleted?: BoolFilter<"Endpoint"> | boolean
    RolEndpoint?: RolEndpointListRelationFilter
  }

  export type EndpointOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    metodo?: SortOrder
    num_parametros?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    RolEndpoint?: RolEndpointOrderByRelationAggregateInput
  }

  export type EndpointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EndpointWhereInput | EndpointWhereInput[]
    OR?: EndpointWhereInput[]
    NOT?: EndpointWhereInput | EndpointWhereInput[]
    nombre?: StringNullableFilter<"Endpoint"> | string | null
    metodo?: EnumTipoFilter<"Endpoint"> | $Enums.Tipo
    num_parametros?: IntFilter<"Endpoint"> | number
    create_at?: DateTimeFilter<"Endpoint"> | Date | string
    update_at?: DateTimeFilter<"Endpoint"> | Date | string
    deleted?: BoolFilter<"Endpoint"> | boolean
    RolEndpoint?: RolEndpointListRelationFilter
  }, "id">

  export type EndpointOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    metodo?: SortOrder
    num_parametros?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: EndpointCountOrderByAggregateInput
    _avg?: EndpointAvgOrderByAggregateInput
    _max?: EndpointMaxOrderByAggregateInput
    _min?: EndpointMinOrderByAggregateInput
    _sum?: EndpointSumOrderByAggregateInput
  }

  export type EndpointScalarWhereWithAggregatesInput = {
    AND?: EndpointScalarWhereWithAggregatesInput | EndpointScalarWhereWithAggregatesInput[]
    OR?: EndpointScalarWhereWithAggregatesInput[]
    NOT?: EndpointScalarWhereWithAggregatesInput | EndpointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Endpoint"> | number
    nombre?: StringNullableWithAggregatesFilter<"Endpoint"> | string | null
    metodo?: EnumTipoWithAggregatesFilter<"Endpoint"> | $Enums.Tipo
    num_parametros?: IntWithAggregatesFilter<"Endpoint"> | number
    create_at?: DateTimeWithAggregatesFilter<"Endpoint"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Endpoint"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Endpoint"> | boolean
  }

  export type EquipoWhereInput = {
    AND?: EquipoWhereInput | EquipoWhereInput[]
    OR?: EquipoWhereInput[]
    NOT?: EquipoWhereInput | EquipoWhereInput[]
    id?: IntFilter<"Equipo"> | number
    nombre_equipo?: StringFilter<"Equipo"> | string
    url_logo?: StringFilter<"Equipo"> | string
    estado?: EnumEstadoFilter<"Equipo"> | $Enums.Estado
    create_at?: DateTimeFilter<"Equipo"> | Date | string
    update_at?: DateTimeFilter<"Equipo"> | Date | string
    deleted?: BoolFilter<"Equipo"> | boolean
    Estudiante?: EstudianteListRelationFilter
    Videojuego?: VideojuegoListRelationFilter
  }

  export type EquipoOrderByWithRelationInput = {
    id?: SortOrder
    nombre_equipo?: SortOrder
    url_logo?: SortOrder
    estado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Estudiante?: EstudianteOrderByRelationAggregateInput
    Videojuego?: VideojuegoOrderByRelationAggregateInput
  }

  export type EquipoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre_equipo?: string
    AND?: EquipoWhereInput | EquipoWhereInput[]
    OR?: EquipoWhereInput[]
    NOT?: EquipoWhereInput | EquipoWhereInput[]
    url_logo?: StringFilter<"Equipo"> | string
    estado?: EnumEstadoFilter<"Equipo"> | $Enums.Estado
    create_at?: DateTimeFilter<"Equipo"> | Date | string
    update_at?: DateTimeFilter<"Equipo"> | Date | string
    deleted?: BoolFilter<"Equipo"> | boolean
    Estudiante?: EstudianteListRelationFilter
    Videojuego?: VideojuegoListRelationFilter
  }, "id" | "nombre_equipo">

  export type EquipoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_equipo?: SortOrder
    url_logo?: SortOrder
    estado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: EquipoCountOrderByAggregateInput
    _avg?: EquipoAvgOrderByAggregateInput
    _max?: EquipoMaxOrderByAggregateInput
    _min?: EquipoMinOrderByAggregateInput
    _sum?: EquipoSumOrderByAggregateInput
  }

  export type EquipoScalarWhereWithAggregatesInput = {
    AND?: EquipoScalarWhereWithAggregatesInput | EquipoScalarWhereWithAggregatesInput[]
    OR?: EquipoScalarWhereWithAggregatesInput[]
    NOT?: EquipoScalarWhereWithAggregatesInput | EquipoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Equipo"> | number
    nombre_equipo?: StringWithAggregatesFilter<"Equipo"> | string
    url_logo?: StringWithAggregatesFilter<"Equipo"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Equipo"> | $Enums.Estado
    create_at?: DateTimeWithAggregatesFilter<"Equipo"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Equipo"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Equipo"> | boolean
  }

  export type EstudianteWhereInput = {
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    id?: IntFilter<"Estudiante"> | number
    equipo_id?: IntFilter<"Estudiante"> | number
    id_user?: IntFilter<"Estudiante"> | number
    github?: StringFilter<"Estudiante"> | string
    confirmado?: BoolFilter<"Estudiante"> | boolean
    create_at?: DateTimeFilter<"Estudiante"> | Date | string
    update_at?: DateTimeFilter<"Estudiante"> | Date | string
    deleted?: BoolFilter<"Estudiante"> | boolean
    Equipo?: XOR<EquipoScalarRelationFilter, EquipoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    EstudianteNRC?: EstudianteNRCListRelationFilter
  }

  export type EstudianteOrderByWithRelationInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
    github?: SortOrder
    confirmado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Equipo?: EquipoOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    EstudianteNRC?: EstudianteNRCOrderByRelationAggregateInput
  }

  export type EstudianteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_user?: number
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    equipo_id?: IntFilter<"Estudiante"> | number
    github?: StringFilter<"Estudiante"> | string
    confirmado?: BoolFilter<"Estudiante"> | boolean
    create_at?: DateTimeFilter<"Estudiante"> | Date | string
    update_at?: DateTimeFilter<"Estudiante"> | Date | string
    deleted?: BoolFilter<"Estudiante"> | boolean
    Equipo?: XOR<EquipoScalarRelationFilter, EquipoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    EstudianteNRC?: EstudianteNRCListRelationFilter
  }, "id" | "id_user">

  export type EstudianteOrderByWithAggregationInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
    github?: SortOrder
    confirmado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: EstudianteCountOrderByAggregateInput
    _avg?: EstudianteAvgOrderByAggregateInput
    _max?: EstudianteMaxOrderByAggregateInput
    _min?: EstudianteMinOrderByAggregateInput
    _sum?: EstudianteSumOrderByAggregateInput
  }

  export type EstudianteScalarWhereWithAggregatesInput = {
    AND?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    OR?: EstudianteScalarWhereWithAggregatesInput[]
    NOT?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Estudiante"> | number
    equipo_id?: IntWithAggregatesFilter<"Estudiante"> | number
    id_user?: IntWithAggregatesFilter<"Estudiante"> | number
    github?: StringWithAggregatesFilter<"Estudiante"> | string
    confirmado?: BoolWithAggregatesFilter<"Estudiante"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Estudiante"> | boolean
  }

  export type EstudianteNRCWhereInput = {
    AND?: EstudianteNRCWhereInput | EstudianteNRCWhereInput[]
    OR?: EstudianteNRCWhereInput[]
    NOT?: EstudianteNRCWhereInput | EstudianteNRCWhereInput[]
    id_nrc?: IntFilter<"EstudianteNRC"> | number
    id_estudiante?: IntFilter<"EstudianteNRC"> | number
    create_at?: DateTimeFilter<"EstudianteNRC"> | Date | string
    deleted?: BoolFilter<"EstudianteNRC"> | boolean
    Estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    NRC?: XOR<NRCScalarRelationFilter, NRCWhereInput>
  }

  export type EstudianteNRCOrderByWithRelationInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    Estudiante?: EstudianteOrderByWithRelationInput
    NRC?: NRCOrderByWithRelationInput
  }

  export type EstudianteNRCWhereUniqueInput = Prisma.AtLeast<{
    id_nrc_id_estudiante?: EstudianteNRCId_nrcId_estudianteCompoundUniqueInput
    AND?: EstudianteNRCWhereInput | EstudianteNRCWhereInput[]
    OR?: EstudianteNRCWhereInput[]
    NOT?: EstudianteNRCWhereInput | EstudianteNRCWhereInput[]
    id_nrc?: IntFilter<"EstudianteNRC"> | number
    id_estudiante?: IntFilter<"EstudianteNRC"> | number
    create_at?: DateTimeFilter<"EstudianteNRC"> | Date | string
    deleted?: BoolFilter<"EstudianteNRC"> | boolean
    Estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    NRC?: XOR<NRCScalarRelationFilter, NRCWhereInput>
  }, "id_nrc_id_estudiante">

  export type EstudianteNRCOrderByWithAggregationInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    _count?: EstudianteNRCCountOrderByAggregateInput
    _avg?: EstudianteNRCAvgOrderByAggregateInput
    _max?: EstudianteNRCMaxOrderByAggregateInput
    _min?: EstudianteNRCMinOrderByAggregateInput
    _sum?: EstudianteNRCSumOrderByAggregateInput
  }

  export type EstudianteNRCScalarWhereWithAggregatesInput = {
    AND?: EstudianteNRCScalarWhereWithAggregatesInput | EstudianteNRCScalarWhereWithAggregatesInput[]
    OR?: EstudianteNRCScalarWhereWithAggregatesInput[]
    NOT?: EstudianteNRCScalarWhereWithAggregatesInput | EstudianteNRCScalarWhereWithAggregatesInput[]
    id_nrc?: IntWithAggregatesFilter<"EstudianteNRC"> | number
    id_estudiante?: IntWithAggregatesFilter<"EstudianteNRC"> | number
    create_at?: DateTimeWithAggregatesFilter<"EstudianteNRC"> | Date | string
    deleted?: BoolWithAggregatesFilter<"EstudianteNRC"> | boolean
  }

  export type EvaluacionWhereInput = {
    AND?: EvaluacionWhereInput | EvaluacionWhereInput[]
    OR?: EvaluacionWhereInput[]
    NOT?: EvaluacionWhereInput | EvaluacionWhereInput[]
    id?: IntFilter<"Evaluacion"> | number
    jurado_id?: IntFilter<"Evaluacion"> | number
    videojuego_id?: IntFilter<"Evaluacion"> | number
    comentarios?: StringFilter<"Evaluacion"> | string
    create_at?: DateTimeFilter<"Evaluacion"> | Date | string
    update_at?: DateTimeFilter<"Evaluacion"> | Date | string
    deleted?: BoolFilter<"Evaluacion"> | boolean
    Jurado?: XOR<JuradoScalarRelationFilter, JuradoWhereInput>
    Videojuego?: XOR<VideojuegoScalarRelationFilter, VideojuegoWhereInput>
    Rubrica?: RubricaListRelationFilter
  }

  export type EvaluacionOrderByWithRelationInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
    comentarios?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Jurado?: JuradoOrderByWithRelationInput
    Videojuego?: VideojuegoOrderByWithRelationInput
    Rubrica?: RubricaOrderByRelationAggregateInput
  }

  export type EvaluacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    jurado_id_videojuego_id?: EvaluacionJurado_idVideojuego_idCompoundUniqueInput
    AND?: EvaluacionWhereInput | EvaluacionWhereInput[]
    OR?: EvaluacionWhereInput[]
    NOT?: EvaluacionWhereInput | EvaluacionWhereInput[]
    jurado_id?: IntFilter<"Evaluacion"> | number
    videojuego_id?: IntFilter<"Evaluacion"> | number
    comentarios?: StringFilter<"Evaluacion"> | string
    create_at?: DateTimeFilter<"Evaluacion"> | Date | string
    update_at?: DateTimeFilter<"Evaluacion"> | Date | string
    deleted?: BoolFilter<"Evaluacion"> | boolean
    Jurado?: XOR<JuradoScalarRelationFilter, JuradoWhereInput>
    Videojuego?: XOR<VideojuegoScalarRelationFilter, VideojuegoWhereInput>
    Rubrica?: RubricaListRelationFilter
  }, "id" | "jurado_id_videojuego_id">

  export type EvaluacionOrderByWithAggregationInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
    comentarios?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: EvaluacionCountOrderByAggregateInput
    _avg?: EvaluacionAvgOrderByAggregateInput
    _max?: EvaluacionMaxOrderByAggregateInput
    _min?: EvaluacionMinOrderByAggregateInput
    _sum?: EvaluacionSumOrderByAggregateInput
  }

  export type EvaluacionScalarWhereWithAggregatesInput = {
    AND?: EvaluacionScalarWhereWithAggregatesInput | EvaluacionScalarWhereWithAggregatesInput[]
    OR?: EvaluacionScalarWhereWithAggregatesInput[]
    NOT?: EvaluacionScalarWhereWithAggregatesInput | EvaluacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evaluacion"> | number
    jurado_id?: IntWithAggregatesFilter<"Evaluacion"> | number
    videojuego_id?: IntWithAggregatesFilter<"Evaluacion"> | number
    comentarios?: StringWithAggregatesFilter<"Evaluacion"> | string
    create_at?: DateTimeWithAggregatesFilter<"Evaluacion"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Evaluacion"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Evaluacion"> | boolean
  }

  export type JuradoWhereInput = {
    AND?: JuradoWhereInput | JuradoWhereInput[]
    OR?: JuradoWhereInput[]
    NOT?: JuradoWhereInput | JuradoWhereInput[]
    id?: IntFilter<"Jurado"> | number
    id_user?: IntFilter<"Jurado"> | number
    estado?: EnumEstadoJuradoFilter<"Jurado"> | $Enums.EstadoJurado
    token_confirmacion?: StringFilter<"Jurado"> | string
    ultima_conexion?: DateTimeFilter<"Jurado"> | Date | string
    create_at?: DateTimeFilter<"Jurado"> | Date | string
    update_at?: DateTimeFilter<"Jurado"> | Date | string
    deleted?: BoolFilter<"Jurado"> | boolean
    Evaluacion?: EvaluacionListRelationFilter
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    VideojuegoAsignado?: VideojuegoAsignadoListRelationFilter
  }

  export type JuradoOrderByWithRelationInput = {
    id?: SortOrder
    id_user?: SortOrder
    estado?: SortOrder
    token_confirmacion?: SortOrder
    ultima_conexion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Evaluacion?: EvaluacionOrderByRelationAggregateInput
    Usuario?: UsuarioOrderByWithRelationInput
    VideojuegoAsignado?: VideojuegoAsignadoOrderByRelationAggregateInput
  }

  export type JuradoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_user?: number
    AND?: JuradoWhereInput | JuradoWhereInput[]
    OR?: JuradoWhereInput[]
    NOT?: JuradoWhereInput | JuradoWhereInput[]
    estado?: EnumEstadoJuradoFilter<"Jurado"> | $Enums.EstadoJurado
    token_confirmacion?: StringFilter<"Jurado"> | string
    ultima_conexion?: DateTimeFilter<"Jurado"> | Date | string
    create_at?: DateTimeFilter<"Jurado"> | Date | string
    update_at?: DateTimeFilter<"Jurado"> | Date | string
    deleted?: BoolFilter<"Jurado"> | boolean
    Evaluacion?: EvaluacionListRelationFilter
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    VideojuegoAsignado?: VideojuegoAsignadoListRelationFilter
  }, "id" | "id_user">

  export type JuradoOrderByWithAggregationInput = {
    id?: SortOrder
    id_user?: SortOrder
    estado?: SortOrder
    token_confirmacion?: SortOrder
    ultima_conexion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: JuradoCountOrderByAggregateInput
    _avg?: JuradoAvgOrderByAggregateInput
    _max?: JuradoMaxOrderByAggregateInput
    _min?: JuradoMinOrderByAggregateInput
    _sum?: JuradoSumOrderByAggregateInput
  }

  export type JuradoScalarWhereWithAggregatesInput = {
    AND?: JuradoScalarWhereWithAggregatesInput | JuradoScalarWhereWithAggregatesInput[]
    OR?: JuradoScalarWhereWithAggregatesInput[]
    NOT?: JuradoScalarWhereWithAggregatesInput | JuradoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Jurado"> | number
    id_user?: IntWithAggregatesFilter<"Jurado"> | number
    estado?: EnumEstadoJuradoWithAggregatesFilter<"Jurado"> | $Enums.EstadoJurado
    token_confirmacion?: StringWithAggregatesFilter<"Jurado"> | string
    ultima_conexion?: DateTimeWithAggregatesFilter<"Jurado"> | Date | string
    create_at?: DateTimeWithAggregatesFilter<"Jurado"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Jurado"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Jurado"> | boolean
  }

  export type MateriaWhereInput = {
    AND?: MateriaWhereInput | MateriaWhereInput[]
    OR?: MateriaWhereInput[]
    NOT?: MateriaWhereInput | MateriaWhereInput[]
    id?: IntFilter<"Materia"> | number
    nombre?: StringFilter<"Materia"> | string
    codigo?: StringFilter<"Materia"> | string
    create_at?: DateTimeFilter<"Materia"> | Date | string
    update_at?: DateTimeFilter<"Materia"> | Date | string
    deleted?: BoolFilter<"Materia"> | boolean
    NRC?: NRCListRelationFilter
  }

  export type MateriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    NRC?: NRCOrderByRelationAggregateInput
  }

  export type MateriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo?: string
    AND?: MateriaWhereInput | MateriaWhereInput[]
    OR?: MateriaWhereInput[]
    NOT?: MateriaWhereInput | MateriaWhereInput[]
    nombre?: StringFilter<"Materia"> | string
    create_at?: DateTimeFilter<"Materia"> | Date | string
    update_at?: DateTimeFilter<"Materia"> | Date | string
    deleted?: BoolFilter<"Materia"> | boolean
    NRC?: NRCListRelationFilter
  }, "id" | "codigo">

  export type MateriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: MateriaCountOrderByAggregateInput
    _avg?: MateriaAvgOrderByAggregateInput
    _max?: MateriaMaxOrderByAggregateInput
    _min?: MateriaMinOrderByAggregateInput
    _sum?: MateriaSumOrderByAggregateInput
  }

  export type MateriaScalarWhereWithAggregatesInput = {
    AND?: MateriaScalarWhereWithAggregatesInput | MateriaScalarWhereWithAggregatesInput[]
    OR?: MateriaScalarWhereWithAggregatesInput[]
    NOT?: MateriaScalarWhereWithAggregatesInput | MateriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Materia"> | number
    nombre?: StringWithAggregatesFilter<"Materia"> | string
    codigo?: StringWithAggregatesFilter<"Materia"> | string
    create_at?: DateTimeWithAggregatesFilter<"Materia"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Materia"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Materia"> | boolean
  }

  export type NRCWhereInput = {
    AND?: NRCWhereInput | NRCWhereInput[]
    OR?: NRCWhereInput[]
    NOT?: NRCWhereInput | NRCWhereInput[]
    codigo_nrc?: IntFilter<"NRC"> | number
    materia_id?: IntFilter<"NRC"> | number
    profesor_id?: IntFilter<"NRC"> | number
    create_at?: DateTimeFilter<"NRC"> | Date | string
    update_at?: DateTimeFilter<"NRC"> | Date | string
    deleted?: BoolFilter<"NRC"> | boolean
    EstudianteNRC?: EstudianteNRCListRelationFilter
    Materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type NRCOrderByWithRelationInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    EstudianteNRC?: EstudianteNRCOrderByRelationAggregateInput
    Materia?: MateriaOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type NRCWhereUniqueInput = Prisma.AtLeast<{
    codigo_nrc?: number
    AND?: NRCWhereInput | NRCWhereInput[]
    OR?: NRCWhereInput[]
    NOT?: NRCWhereInput | NRCWhereInput[]
    materia_id?: IntFilter<"NRC"> | number
    profesor_id?: IntFilter<"NRC"> | number
    create_at?: DateTimeFilter<"NRC"> | Date | string
    update_at?: DateTimeFilter<"NRC"> | Date | string
    deleted?: BoolFilter<"NRC"> | boolean
    EstudianteNRC?: EstudianteNRCListRelationFilter
    Materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "codigo_nrc">

  export type NRCOrderByWithAggregationInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: NRCCountOrderByAggregateInput
    _avg?: NRCAvgOrderByAggregateInput
    _max?: NRCMaxOrderByAggregateInput
    _min?: NRCMinOrderByAggregateInput
    _sum?: NRCSumOrderByAggregateInput
  }

  export type NRCScalarWhereWithAggregatesInput = {
    AND?: NRCScalarWhereWithAggregatesInput | NRCScalarWhereWithAggregatesInput[]
    OR?: NRCScalarWhereWithAggregatesInput[]
    NOT?: NRCScalarWhereWithAggregatesInput | NRCScalarWhereWithAggregatesInput[]
    codigo_nrc?: IntWithAggregatesFilter<"NRC"> | number
    materia_id?: IntWithAggregatesFilter<"NRC"> | number
    profesor_id?: IntWithAggregatesFilter<"NRC"> | number
    create_at?: DateTimeWithAggregatesFilter<"NRC"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"NRC"> | Date | string
    deleted?: BoolWithAggregatesFilter<"NRC"> | boolean
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id?: IntFilter<"Rol"> | number
    nombre?: StringFilter<"Rol"> | string
    create_at?: DateTimeFilter<"Rol"> | Date | string
    update_at?: DateTimeFilter<"Rol"> | Date | string
    deleted?: BoolFilter<"Rol"> | boolean
    RolEndpoint?: RolEndpointListRelationFilter
    RolUsuario?: RolUsuarioListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    RolEndpoint?: RolEndpointOrderByRelationAggregateInput
    RolUsuario?: RolUsuarioOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    nombre?: StringFilter<"Rol"> | string
    create_at?: DateTimeFilter<"Rol"> | Date | string
    update_at?: DateTimeFilter<"Rol"> | Date | string
    deleted?: BoolFilter<"Rol"> | boolean
    RolEndpoint?: RolEndpointListRelationFilter
    RolUsuario?: RolUsuarioListRelationFilter
  }, "id">

  export type RolOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: RolCountOrderByAggregateInput
    _avg?: RolAvgOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
    _sum?: RolSumOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rol"> | number
    nombre?: StringWithAggregatesFilter<"Rol"> | string
    create_at?: DateTimeWithAggregatesFilter<"Rol"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Rol"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Rol"> | boolean
  }

  export type RolEndpointWhereInput = {
    AND?: RolEndpointWhereInput | RolEndpointWhereInput[]
    OR?: RolEndpointWhereInput[]
    NOT?: RolEndpointWhereInput | RolEndpointWhereInput[]
    id_rol?: IntFilter<"RolEndpoint"> | number
    id_endpoint?: IntFilter<"RolEndpoint"> | number
    create_at?: DateTimeFilter<"RolEndpoint"> | Date | string
    deleted?: BoolFilter<"RolEndpoint"> | boolean
    Endpoint?: XOR<EndpointScalarRelationFilter, EndpointWhereInput>
    Rol?: XOR<RolScalarRelationFilter, RolWhereInput>
  }

  export type RolEndpointOrderByWithRelationInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    Endpoint?: EndpointOrderByWithRelationInput
    Rol?: RolOrderByWithRelationInput
  }

  export type RolEndpointWhereUniqueInput = Prisma.AtLeast<{
    id_endpoint_id_rol?: RolEndpointId_endpointId_rolCompoundUniqueInput
    AND?: RolEndpointWhereInput | RolEndpointWhereInput[]
    OR?: RolEndpointWhereInput[]
    NOT?: RolEndpointWhereInput | RolEndpointWhereInput[]
    id_rol?: IntFilter<"RolEndpoint"> | number
    id_endpoint?: IntFilter<"RolEndpoint"> | number
    create_at?: DateTimeFilter<"RolEndpoint"> | Date | string
    deleted?: BoolFilter<"RolEndpoint"> | boolean
    Endpoint?: XOR<EndpointScalarRelationFilter, EndpointWhereInput>
    Rol?: XOR<RolScalarRelationFilter, RolWhereInput>
  }, "id_endpoint_id_rol">

  export type RolEndpointOrderByWithAggregationInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    _count?: RolEndpointCountOrderByAggregateInput
    _avg?: RolEndpointAvgOrderByAggregateInput
    _max?: RolEndpointMaxOrderByAggregateInput
    _min?: RolEndpointMinOrderByAggregateInput
    _sum?: RolEndpointSumOrderByAggregateInput
  }

  export type RolEndpointScalarWhereWithAggregatesInput = {
    AND?: RolEndpointScalarWhereWithAggregatesInput | RolEndpointScalarWhereWithAggregatesInput[]
    OR?: RolEndpointScalarWhereWithAggregatesInput[]
    NOT?: RolEndpointScalarWhereWithAggregatesInput | RolEndpointScalarWhereWithAggregatesInput[]
    id_rol?: IntWithAggregatesFilter<"RolEndpoint"> | number
    id_endpoint?: IntWithAggregatesFilter<"RolEndpoint"> | number
    create_at?: DateTimeWithAggregatesFilter<"RolEndpoint"> | Date | string
    deleted?: BoolWithAggregatesFilter<"RolEndpoint"> | boolean
  }

  export type RolUsuarioWhereInput = {
    AND?: RolUsuarioWhereInput | RolUsuarioWhereInput[]
    OR?: RolUsuarioWhereInput[]
    NOT?: RolUsuarioWhereInput | RolUsuarioWhereInput[]
    id_usuario?: IntFilter<"RolUsuario"> | number
    id_rol?: IntFilter<"RolUsuario"> | number
    create_at?: DateTimeFilter<"RolUsuario"> | Date | string
    deleted?: BoolFilter<"RolUsuario"> | boolean
    Rol?: XOR<RolScalarRelationFilter, RolWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type RolUsuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    Rol?: RolOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type RolUsuarioWhereUniqueInput = Prisma.AtLeast<{
    id_rol_id_usuario?: RolUsuarioId_rolId_usuarioCompoundUniqueInput
    AND?: RolUsuarioWhereInput | RolUsuarioWhereInput[]
    OR?: RolUsuarioWhereInput[]
    NOT?: RolUsuarioWhereInput | RolUsuarioWhereInput[]
    id_usuario?: IntFilter<"RolUsuario"> | number
    id_rol?: IntFilter<"RolUsuario"> | number
    create_at?: DateTimeFilter<"RolUsuario"> | Date | string
    deleted?: BoolFilter<"RolUsuario"> | boolean
    Rol?: XOR<RolScalarRelationFilter, RolWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id_rol_id_usuario">

  export type RolUsuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    _count?: RolUsuarioCountOrderByAggregateInput
    _avg?: RolUsuarioAvgOrderByAggregateInput
    _max?: RolUsuarioMaxOrderByAggregateInput
    _min?: RolUsuarioMinOrderByAggregateInput
    _sum?: RolUsuarioSumOrderByAggregateInput
  }

  export type RolUsuarioScalarWhereWithAggregatesInput = {
    AND?: RolUsuarioScalarWhereWithAggregatesInput | RolUsuarioScalarWhereWithAggregatesInput[]
    OR?: RolUsuarioScalarWhereWithAggregatesInput[]
    NOT?: RolUsuarioScalarWhereWithAggregatesInput | RolUsuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"RolUsuario"> | number
    id_rol?: IntWithAggregatesFilter<"RolUsuario"> | number
    create_at?: DateTimeWithAggregatesFilter<"RolUsuario"> | Date | string
    deleted?: BoolWithAggregatesFilter<"RolUsuario"> | boolean
  }

  export type RubricaWhereInput = {
    AND?: RubricaWhereInput | RubricaWhereInput[]
    OR?: RubricaWhereInput[]
    NOT?: RubricaWhereInput | RubricaWhereInput[]
    id_evaluacion?: IntFilter<"Rubrica"> | number
    id_criterio?: IntFilter<"Rubrica"> | number
    valoracion?: IntFilter<"Rubrica"> | number
    create_at?: DateTimeFilter<"Rubrica"> | Date | string
    deleted?: BoolFilter<"Rubrica"> | boolean
    Criterio?: XOR<CriterioScalarRelationFilter, CriterioWhereInput>
    Evaluacion?: XOR<EvaluacionScalarRelationFilter, EvaluacionWhereInput>
  }

  export type RubricaOrderByWithRelationInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    Criterio?: CriterioOrderByWithRelationInput
    Evaluacion?: EvaluacionOrderByWithRelationInput
  }

  export type RubricaWhereUniqueInput = Prisma.AtLeast<{
    id_criterio_id_evaluacion?: RubricaId_criterioId_evaluacionCompoundUniqueInput
    AND?: RubricaWhereInput | RubricaWhereInput[]
    OR?: RubricaWhereInput[]
    NOT?: RubricaWhereInput | RubricaWhereInput[]
    id_evaluacion?: IntFilter<"Rubrica"> | number
    id_criterio?: IntFilter<"Rubrica"> | number
    valoracion?: IntFilter<"Rubrica"> | number
    create_at?: DateTimeFilter<"Rubrica"> | Date | string
    deleted?: BoolFilter<"Rubrica"> | boolean
    Criterio?: XOR<CriterioScalarRelationFilter, CriterioWhereInput>
    Evaluacion?: XOR<EvaluacionScalarRelationFilter, EvaluacionWhereInput>
  }, "id_criterio_id_evaluacion">

  export type RubricaOrderByWithAggregationInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    _count?: RubricaCountOrderByAggregateInput
    _avg?: RubricaAvgOrderByAggregateInput
    _max?: RubricaMaxOrderByAggregateInput
    _min?: RubricaMinOrderByAggregateInput
    _sum?: RubricaSumOrderByAggregateInput
  }

  export type RubricaScalarWhereWithAggregatesInput = {
    AND?: RubricaScalarWhereWithAggregatesInput | RubricaScalarWhereWithAggregatesInput[]
    OR?: RubricaScalarWhereWithAggregatesInput[]
    NOT?: RubricaScalarWhereWithAggregatesInput | RubricaScalarWhereWithAggregatesInput[]
    id_evaluacion?: IntWithAggregatesFilter<"Rubrica"> | number
    id_criterio?: IntWithAggregatesFilter<"Rubrica"> | number
    valoracion?: IntWithAggregatesFilter<"Rubrica"> | number
    create_at?: DateTimeWithAggregatesFilter<"Rubrica"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Rubrica"> | boolean
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre_completo?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    hash_contrasena?: StringFilter<"Usuario"> | string
    create_at?: DateTimeFilter<"Usuario"> | Date | string
    update_at?: DateTimeFilter<"Usuario"> | Date | string
    deleted?: BoolFilter<"Usuario"> | boolean
    Estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
    Jurado?: XOR<JuradoNullableScalarRelationFilter, JuradoWhereInput> | null
    NRC?: NRCListRelationFilter
    RolUsuario?: RolUsuarioListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    email?: SortOrder
    hash_contrasena?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Estudiante?: EstudianteOrderByWithRelationInput
    Jurado?: JuradoOrderByWithRelationInput
    NRC?: NRCOrderByRelationAggregateInput
    RolUsuario?: RolUsuarioOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre_completo?: StringFilter<"Usuario"> | string
    hash_contrasena?: StringFilter<"Usuario"> | string
    create_at?: DateTimeFilter<"Usuario"> | Date | string
    update_at?: DateTimeFilter<"Usuario"> | Date | string
    deleted?: BoolFilter<"Usuario"> | boolean
    Estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
    Jurado?: XOR<JuradoNullableScalarRelationFilter, JuradoWhereInput> | null
    NRC?: NRCListRelationFilter
    RolUsuario?: RolUsuarioListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    email?: SortOrder
    hash_contrasena?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre_completo?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    hash_contrasena?: StringWithAggregatesFilter<"Usuario"> | string
    create_at?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Usuario"> | boolean
  }

  export type VideojuegoWhereInput = {
    AND?: VideojuegoWhereInput | VideojuegoWhereInput[]
    OR?: VideojuegoWhereInput[]
    NOT?: VideojuegoWhereInput | VideojuegoWhereInput[]
    id?: IntFilter<"Videojuego"> | number
    equipo_id?: IntFilter<"Videojuego"> | number
    nombre_videojuego?: StringFilter<"Videojuego"> | string
    descripcion?: StringFilter<"Videojuego"> | string
    create_at?: DateTimeFilter<"Videojuego"> | Date | string
    update_at?: DateTimeFilter<"Videojuego"> | Date | string
    deleted?: BoolFilter<"Videojuego"> | boolean
    Evaluacion?: EvaluacionListRelationFilter
    Equipo?: XOR<EquipoScalarRelationFilter, EquipoWhereInput>
    VideojuegoAsignado?: VideojuegoAsignadoListRelationFilter
  }

  export type VideojuegoOrderByWithRelationInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    nombre_videojuego?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    Evaluacion?: EvaluacionOrderByRelationAggregateInput
    Equipo?: EquipoOrderByWithRelationInput
    VideojuegoAsignado?: VideojuegoAsignadoOrderByRelationAggregateInput
  }

  export type VideojuegoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VideojuegoWhereInput | VideojuegoWhereInput[]
    OR?: VideojuegoWhereInput[]
    NOT?: VideojuegoWhereInput | VideojuegoWhereInput[]
    equipo_id?: IntFilter<"Videojuego"> | number
    nombre_videojuego?: StringFilter<"Videojuego"> | string
    descripcion?: StringFilter<"Videojuego"> | string
    create_at?: DateTimeFilter<"Videojuego"> | Date | string
    update_at?: DateTimeFilter<"Videojuego"> | Date | string
    deleted?: BoolFilter<"Videojuego"> | boolean
    Evaluacion?: EvaluacionListRelationFilter
    Equipo?: XOR<EquipoScalarRelationFilter, EquipoWhereInput>
    VideojuegoAsignado?: VideojuegoAsignadoListRelationFilter
  }, "id">

  export type VideojuegoOrderByWithAggregationInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    nombre_videojuego?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
    _count?: VideojuegoCountOrderByAggregateInput
    _avg?: VideojuegoAvgOrderByAggregateInput
    _max?: VideojuegoMaxOrderByAggregateInput
    _min?: VideojuegoMinOrderByAggregateInput
    _sum?: VideojuegoSumOrderByAggregateInput
  }

  export type VideojuegoScalarWhereWithAggregatesInput = {
    AND?: VideojuegoScalarWhereWithAggregatesInput | VideojuegoScalarWhereWithAggregatesInput[]
    OR?: VideojuegoScalarWhereWithAggregatesInput[]
    NOT?: VideojuegoScalarWhereWithAggregatesInput | VideojuegoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Videojuego"> | number
    equipo_id?: IntWithAggregatesFilter<"Videojuego"> | number
    nombre_videojuego?: StringWithAggregatesFilter<"Videojuego"> | string
    descripcion?: StringWithAggregatesFilter<"Videojuego"> | string
    create_at?: DateTimeWithAggregatesFilter<"Videojuego"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"Videojuego"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Videojuego"> | boolean
  }

  export type VideojuegoAsignadoWhereInput = {
    AND?: VideojuegoAsignadoWhereInput | VideojuegoAsignadoWhereInput[]
    OR?: VideojuegoAsignadoWhereInput[]
    NOT?: VideojuegoAsignadoWhereInput | VideojuegoAsignadoWhereInput[]
    id_videojuego?: IntFilter<"VideojuegoAsignado"> | number
    id_jurado?: IntFilter<"VideojuegoAsignado"> | number
    create_at?: DateTimeFilter<"VideojuegoAsignado"> | Date | string
    deleted?: BoolFilter<"VideojuegoAsignado"> | boolean
    Jurado?: XOR<JuradoScalarRelationFilter, JuradoWhereInput>
    Videojuego?: XOR<VideojuegoScalarRelationFilter, VideojuegoWhereInput>
  }

  export type VideojuegoAsignadoOrderByWithRelationInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    Jurado?: JuradoOrderByWithRelationInput
    Videojuego?: VideojuegoOrderByWithRelationInput
  }

  export type VideojuegoAsignadoWhereUniqueInput = Prisma.AtLeast<{
    id_videojuego_id_jurado?: VideojuegoAsignadoId_videojuegoId_juradoCompoundUniqueInput
    AND?: VideojuegoAsignadoWhereInput | VideojuegoAsignadoWhereInput[]
    OR?: VideojuegoAsignadoWhereInput[]
    NOT?: VideojuegoAsignadoWhereInput | VideojuegoAsignadoWhereInput[]
    id_videojuego?: IntFilter<"VideojuegoAsignado"> | number
    id_jurado?: IntFilter<"VideojuegoAsignado"> | number
    create_at?: DateTimeFilter<"VideojuegoAsignado"> | Date | string
    deleted?: BoolFilter<"VideojuegoAsignado"> | boolean
    Jurado?: XOR<JuradoScalarRelationFilter, JuradoWhereInput>
    Videojuego?: XOR<VideojuegoScalarRelationFilter, VideojuegoWhereInput>
  }, "id_videojuego_id_jurado">

  export type VideojuegoAsignadoOrderByWithAggregationInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
    _count?: VideojuegoAsignadoCountOrderByAggregateInput
    _avg?: VideojuegoAsignadoAvgOrderByAggregateInput
    _max?: VideojuegoAsignadoMaxOrderByAggregateInput
    _min?: VideojuegoAsignadoMinOrderByAggregateInput
    _sum?: VideojuegoAsignadoSumOrderByAggregateInput
  }

  export type VideojuegoAsignadoScalarWhereWithAggregatesInput = {
    AND?: VideojuegoAsignadoScalarWhereWithAggregatesInput | VideojuegoAsignadoScalarWhereWithAggregatesInput[]
    OR?: VideojuegoAsignadoScalarWhereWithAggregatesInput[]
    NOT?: VideojuegoAsignadoScalarWhereWithAggregatesInput | VideojuegoAsignadoScalarWhereWithAggregatesInput[]
    id_videojuego?: IntWithAggregatesFilter<"VideojuegoAsignado"> | number
    id_jurado?: IntWithAggregatesFilter<"VideojuegoAsignado"> | number
    create_at?: DateTimeWithAggregatesFilter<"VideojuegoAsignado"> | Date | string
    deleted?: BoolWithAggregatesFilter<"VideojuegoAsignado"> | boolean
  }

  export type CriterioCreateInput = {
    nombre: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Rubrica?: RubricaCreateNestedManyWithoutCriterioInput
  }

  export type CriterioUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Rubrica?: RubricaUncheckedCreateNestedManyWithoutCriterioInput
  }

  export type CriterioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rubrica?: RubricaUpdateManyWithoutCriterioNestedInput
  }

  export type CriterioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rubrica?: RubricaUncheckedUpdateManyWithoutCriterioNestedInput
  }

  export type CriterioCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type CriterioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CriterioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EndpointCreateInput = {
    nombre?: string | null
    metodo: $Enums.Tipo
    num_parametros: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolEndpoint?: RolEndpointCreateNestedManyWithoutEndpointInput
  }

  export type EndpointUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    metodo: $Enums.Tipo
    num_parametros: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolEndpoint?: RolEndpointUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type EndpointUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    metodo?: EnumTipoFieldUpdateOperationsInput | $Enums.Tipo
    num_parametros?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolEndpoint?: RolEndpointUpdateManyWithoutEndpointNestedInput
  }

  export type EndpointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    metodo?: EnumTipoFieldUpdateOperationsInput | $Enums.Tipo
    num_parametros?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolEndpoint?: RolEndpointUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type EndpointCreateManyInput = {
    id?: number
    nombre?: string | null
    metodo: $Enums.Tipo
    num_parametros: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EndpointUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    metodo?: EnumTipoFieldUpdateOperationsInput | $Enums.Tipo
    num_parametros?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EndpointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    metodo?: EnumTipoFieldUpdateOperationsInput | $Enums.Tipo
    num_parametros?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipoCreateInput = {
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteCreateNestedManyWithoutEquipoInput
    Videojuego?: VideojuegoCreateNestedManyWithoutEquipoInput
  }

  export type EquipoUncheckedCreateInput = {
    id?: number
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteUncheckedCreateNestedManyWithoutEquipoInput
    Videojuego?: VideojuegoUncheckedCreateNestedManyWithoutEquipoInput
  }

  export type EquipoUpdateInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateManyWithoutEquipoNestedInput
    Videojuego?: VideojuegoUpdateManyWithoutEquipoNestedInput
  }

  export type EquipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUncheckedUpdateManyWithoutEquipoNestedInput
    Videojuego?: VideojuegoUncheckedUpdateManyWithoutEquipoNestedInput
  }

  export type EquipoCreateManyInput = {
    id?: number
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EquipoUpdateManyMutationInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteCreateInput = {
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Equipo: EquipoCreateNestedOneWithoutEstudianteInput
    Usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    EstudianteNRC?: EstudianteNRCCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateInput = {
    id?: number
    equipo_id: number
    id_user: number
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUpdateInput = {
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Equipo?: EquipoUpdateOneRequiredWithoutEstudianteNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    EstudianteNRC?: EstudianteNRCUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteCreateManyInput = {
    id?: number
    equipo_id: number
    id_user: number
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteUpdateManyMutationInput = {
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCCreateInput = {
    create_at?: Date | string
    deleted?: boolean
    Estudiante: EstudianteCreateNestedOneWithoutEstudianteNRCInput
    NRC: NRCCreateNestedOneWithoutEstudianteNRCInput
  }

  export type EstudianteNRCUncheckedCreateInput = {
    id_nrc: number
    id_estudiante: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteNRCUpdateInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateOneRequiredWithoutEstudianteNRCNestedInput
    NRC?: NRCUpdateOneRequiredWithoutEstudianteNRCNestedInput
  }

  export type EstudianteNRCUncheckedUpdateInput = {
    id_nrc?: IntFieldUpdateOperationsInput | number
    id_estudiante?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCCreateManyInput = {
    id_nrc: number
    id_estudiante: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteNRCUpdateManyMutationInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCUncheckedUpdateManyInput = {
    id_nrc?: IntFieldUpdateOperationsInput | number
    id_estudiante?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EvaluacionCreateInput = {
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Jurado: JuradoCreateNestedOneWithoutEvaluacionInput
    Videojuego: VideojuegoCreateNestedOneWithoutEvaluacionInput
    Rubrica?: RubricaCreateNestedManyWithoutEvaluacionInput
  }

  export type EvaluacionUncheckedCreateInput = {
    id?: number
    jurado_id: number
    videojuego_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Rubrica?: RubricaUncheckedCreateNestedManyWithoutEvaluacionInput
  }

  export type EvaluacionUpdateInput = {
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUpdateOneRequiredWithoutEvaluacionNestedInput
    Videojuego?: VideojuegoUpdateOneRequiredWithoutEvaluacionNestedInput
    Rubrica?: RubricaUpdateManyWithoutEvaluacionNestedInput
  }

  export type EvaluacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jurado_id?: IntFieldUpdateOperationsInput | number
    videojuego_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rubrica?: RubricaUncheckedUpdateManyWithoutEvaluacionNestedInput
  }

  export type EvaluacionCreateManyInput = {
    id?: number
    jurado_id: number
    videojuego_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EvaluacionUpdateManyMutationInput = {
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EvaluacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jurado_id?: IntFieldUpdateOperationsInput | number
    videojuego_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JuradoCreateInput = {
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionCreateNestedManyWithoutJuradoInput
    Usuario: UsuarioCreateNestedOneWithoutJuradoInput
    VideojuegoAsignado?: VideojuegoAsignadoCreateNestedManyWithoutJuradoInput
  }

  export type JuradoUncheckedCreateInput = {
    id?: number
    id_user: number
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionUncheckedCreateNestedManyWithoutJuradoInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedCreateNestedManyWithoutJuradoInput
  }

  export type JuradoUpdateInput = {
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateManyWithoutJuradoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutJuradoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUpdateManyWithoutJuradoNestedInput
  }

  export type JuradoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUncheckedUpdateManyWithoutJuradoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedUpdateManyWithoutJuradoNestedInput
  }

  export type JuradoCreateManyInput = {
    id?: number
    id_user: number
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type JuradoUpdateManyMutationInput = {
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JuradoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MateriaCreateInput = {
    nombre: string
    codigo: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    NRC?: NRCCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateInput = {
    id?: number
    nombre: string
    codigo: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    NRC?: NRCUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    NRC?: NRCUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    NRC?: NRCUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaCreateManyInput = {
    id?: number
    nombre: string
    codigo: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type MateriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MateriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NRCCreateInput = {
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCCreateNestedManyWithoutNRCInput
    Materia: MateriaCreateNestedOneWithoutNRCInput
    Usuario: UsuarioCreateNestedOneWithoutNRCInput
  }

  export type NRCUncheckedCreateInput = {
    codigo_nrc?: number
    materia_id: number
    profesor_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCUncheckedCreateNestedManyWithoutNRCInput
  }

  export type NRCUpdateInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUpdateManyWithoutNRCNestedInput
    Materia?: MateriaUpdateOneRequiredWithoutNRCNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutNRCNestedInput
  }

  export type NRCUncheckedUpdateInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    materia_id?: IntFieldUpdateOperationsInput | number
    profesor_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUncheckedUpdateManyWithoutNRCNestedInput
  }

  export type NRCCreateManyInput = {
    codigo_nrc?: number
    materia_id: number
    profesor_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type NRCUpdateManyMutationInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NRCUncheckedUpdateManyInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    materia_id?: IntFieldUpdateOperationsInput | number
    profesor_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolCreateInput = {
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolEndpoint?: RolEndpointCreateNestedManyWithoutRolInput
    RolUsuario?: RolUsuarioCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateInput = {
    id?: number
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolEndpoint?: RolEndpointUncheckedCreateNestedManyWithoutRolInput
    RolUsuario?: RolUsuarioUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolEndpoint?: RolEndpointUpdateManyWithoutRolNestedInput
    RolUsuario?: RolUsuarioUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolEndpoint?: RolEndpointUncheckedUpdateManyWithoutRolNestedInput
    RolUsuario?: RolUsuarioUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateManyInput = {
    id?: number
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type RolUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointCreateInput = {
    create_at?: Date | string
    deleted?: boolean
    Endpoint: EndpointCreateNestedOneWithoutRolEndpointInput
    Rol: RolCreateNestedOneWithoutRolEndpointInput
  }

  export type RolEndpointUncheckedCreateInput = {
    id_rol: number
    id_endpoint: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolEndpointUpdateInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Endpoint?: EndpointUpdateOneRequiredWithoutRolEndpointNestedInput
    Rol?: RolUpdateOneRequiredWithoutRolEndpointNestedInput
  }

  export type RolEndpointUncheckedUpdateInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    id_endpoint?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointCreateManyInput = {
    id_rol: number
    id_endpoint: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolEndpointUpdateManyMutationInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointUncheckedUpdateManyInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    id_endpoint?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioCreateInput = {
    create_at?: Date | string
    deleted?: boolean
    Rol: RolCreateNestedOneWithoutRolUsuarioInput
    Usuario: UsuarioCreateNestedOneWithoutRolUsuarioInput
  }

  export type RolUsuarioUncheckedCreateInput = {
    id_usuario: number
    id_rol: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolUsuarioUpdateInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rol?: RolUpdateOneRequiredWithoutRolUsuarioNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRolUsuarioNestedInput
  }

  export type RolUsuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioCreateManyInput = {
    id_usuario: number
    id_rol: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolUsuarioUpdateManyMutationInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RubricaCreateInput = {
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
    Criterio: CriterioCreateNestedOneWithoutRubricaInput
    Evaluacion: EvaluacionCreateNestedOneWithoutRubricaInput
  }

  export type RubricaUncheckedCreateInput = {
    id_evaluacion: number
    id_criterio: number
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RubricaUpdateInput = {
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Criterio?: CriterioUpdateOneRequiredWithoutRubricaNestedInput
    Evaluacion?: EvaluacionUpdateOneRequiredWithoutRubricaNestedInput
  }

  export type RubricaUncheckedUpdateInput = {
    id_evaluacion?: IntFieldUpdateOperationsInput | number
    id_criterio?: IntFieldUpdateOperationsInput | number
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RubricaCreateManyInput = {
    id_evaluacion: number
    id_criterio: number
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RubricaUpdateManyMutationInput = {
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RubricaUncheckedUpdateManyInput = {
    id_evaluacion?: IntFieldUpdateOperationsInput | number
    id_criterio?: IntFieldUpdateOperationsInput | number
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioCreateInput = {
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    Jurado?: JuradoCreateNestedOneWithoutUsuarioInput
    NRC?: NRCCreateNestedManyWithoutUsuarioInput
    RolUsuario?: RolUsuarioCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    Jurado?: JuradoUncheckedCreateNestedOneWithoutUsuarioInput
    NRC?: NRCUncheckedCreateNestedManyWithoutUsuarioInput
    RolUsuario?: RolUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    Jurado?: JuradoUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUpdateManyWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    Jurado?: JuradoUncheckedUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUncheckedUpdateManyWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoCreateInput = {
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionCreateNestedManyWithoutVideojuegoInput
    Equipo: EquipoCreateNestedOneWithoutVideojuegoInput
    VideojuegoAsignado?: VideojuegoAsignadoCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoUncheckedCreateInput = {
    id?: number
    equipo_id: number
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionUncheckedCreateNestedManyWithoutVideojuegoInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoUpdateInput = {
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateManyWithoutVideojuegoNestedInput
    Equipo?: EquipoUpdateOneRequiredWithoutVideojuegoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUpdateManyWithoutVideojuegoNestedInput
  }

  export type VideojuegoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUncheckedUpdateManyWithoutVideojuegoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedUpdateManyWithoutVideojuegoNestedInput
  }

  export type VideojuegoCreateManyInput = {
    id?: number
    equipo_id: number
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoUpdateManyMutationInput = {
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoCreateInput = {
    create_at?: Date | string
    deleted?: boolean
    Jurado: JuradoCreateNestedOneWithoutVideojuegoAsignadoInput
    Videojuego: VideojuegoCreateNestedOneWithoutVideojuegoAsignadoInput
  }

  export type VideojuegoAsignadoUncheckedCreateInput = {
    id_videojuego: number
    id_jurado: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoAsignadoUpdateInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUpdateOneRequiredWithoutVideojuegoAsignadoNestedInput
    Videojuego?: VideojuegoUpdateOneRequiredWithoutVideojuegoAsignadoNestedInput
  }

  export type VideojuegoAsignadoUncheckedUpdateInput = {
    id_videojuego?: IntFieldUpdateOperationsInput | number
    id_jurado?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoCreateManyInput = {
    id_videojuego: number
    id_jurado: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoAsignadoUpdateManyMutationInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoUncheckedUpdateManyInput = {
    id_videojuego?: IntFieldUpdateOperationsInput | number
    id_jurado?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RubricaListRelationFilter = {
    every?: RubricaWhereInput
    some?: RubricaWhereInput
    none?: RubricaWhereInput
  }

  export type RubricaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CriterioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type CriterioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CriterioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type CriterioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type CriterioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTipoFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo | EnumTipoFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoFilter<$PrismaModel> | $Enums.Tipo
  }

  export type RolEndpointListRelationFilter = {
    every?: RolEndpointWhereInput
    some?: RolEndpointWhereInput
    none?: RolEndpointWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolEndpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EndpointCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    metodo?: SortOrder
    num_parametros?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EndpointAvgOrderByAggregateInput = {
    id?: SortOrder
    num_parametros?: SortOrder
  }

  export type EndpointMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    metodo?: SortOrder
    num_parametros?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EndpointMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    metodo?: SortOrder
    num_parametros?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EndpointSumOrderByAggregateInput = {
    id?: SortOrder
    num_parametros?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo | EnumTipoFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoWithAggregatesFilter<$PrismaModel> | $Enums.Tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoFilter<$PrismaModel>
    _max?: NestedEnumTipoFilter<$PrismaModel>
  }

  export type EnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type EstudianteListRelationFilter = {
    every?: EstudianteWhereInput
    some?: EstudianteWhereInput
    none?: EstudianteWhereInput
  }

  export type VideojuegoListRelationFilter = {
    every?: VideojuegoWhereInput
    some?: VideojuegoWhereInput
    none?: VideojuegoWhereInput
  }

  export type EstudianteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideojuegoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_equipo?: SortOrder
    url_logo?: SortOrder
    estado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EquipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_equipo?: SortOrder
    url_logo?: SortOrder
    estado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EquipoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_equipo?: SortOrder
    url_logo?: SortOrder
    estado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EquipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type EquipoScalarRelationFilter = {
    is?: EquipoWhereInput
    isNot?: EquipoWhereInput
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type EstudianteNRCListRelationFilter = {
    every?: EstudianteNRCWhereInput
    some?: EstudianteNRCWhereInput
    none?: EstudianteNRCWhereInput
  }

  export type EstudianteNRCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstudianteCountOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
    github?: SortOrder
    confirmado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EstudianteAvgOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
  }

  export type EstudianteMaxOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
    github?: SortOrder
    confirmado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EstudianteMinOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
    github?: SortOrder
    confirmado?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EstudianteSumOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    id_user?: SortOrder
  }

  export type EstudianteScalarRelationFilter = {
    is?: EstudianteWhereInput
    isNot?: EstudianteWhereInput
  }

  export type NRCScalarRelationFilter = {
    is?: NRCWhereInput
    isNot?: NRCWhereInput
  }

  export type EstudianteNRCId_nrcId_estudianteCompoundUniqueInput = {
    id_nrc: number
    id_estudiante: number
  }

  export type EstudianteNRCCountOrderByAggregateInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type EstudianteNRCAvgOrderByAggregateInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
  }

  export type EstudianteNRCMaxOrderByAggregateInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type EstudianteNRCMinOrderByAggregateInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type EstudianteNRCSumOrderByAggregateInput = {
    id_nrc?: SortOrder
    id_estudiante?: SortOrder
  }

  export type JuradoScalarRelationFilter = {
    is?: JuradoWhereInput
    isNot?: JuradoWhereInput
  }

  export type VideojuegoScalarRelationFilter = {
    is?: VideojuegoWhereInput
    isNot?: VideojuegoWhereInput
  }

  export type EvaluacionJurado_idVideojuego_idCompoundUniqueInput = {
    jurado_id: number
    videojuego_id: number
  }

  export type EvaluacionCountOrderByAggregateInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
    comentarios?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EvaluacionAvgOrderByAggregateInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
  }

  export type EvaluacionMaxOrderByAggregateInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
    comentarios?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EvaluacionMinOrderByAggregateInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
    comentarios?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type EvaluacionSumOrderByAggregateInput = {
    id?: SortOrder
    jurado_id?: SortOrder
    videojuego_id?: SortOrder
  }

  export type EnumEstadoJuradoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoJurado | EnumEstadoJuradoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoJuradoFilter<$PrismaModel> | $Enums.EstadoJurado
  }

  export type EvaluacionListRelationFilter = {
    every?: EvaluacionWhereInput
    some?: EvaluacionWhereInput
    none?: EvaluacionWhereInput
  }

  export type VideojuegoAsignadoListRelationFilter = {
    every?: VideojuegoAsignadoWhereInput
    some?: VideojuegoAsignadoWhereInput
    none?: VideojuegoAsignadoWhereInput
  }

  export type EvaluacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideojuegoAsignadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JuradoCountOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    estado?: SortOrder
    token_confirmacion?: SortOrder
    ultima_conexion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type JuradoAvgOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
  }

  export type JuradoMaxOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    estado?: SortOrder
    token_confirmacion?: SortOrder
    ultima_conexion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type JuradoMinOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    estado?: SortOrder
    token_confirmacion?: SortOrder
    ultima_conexion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type JuradoSumOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
  }

  export type EnumEstadoJuradoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoJurado | EnumEstadoJuradoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoJuradoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoJurado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoJuradoFilter<$PrismaModel>
    _max?: NestedEnumEstadoJuradoFilter<$PrismaModel>
  }

  export type NRCListRelationFilter = {
    every?: NRCWhereInput
    some?: NRCWhereInput
    none?: NRCWhereInput
  }

  export type NRCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MateriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type MateriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MateriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type MateriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type MateriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MateriaScalarRelationFilter = {
    is?: MateriaWhereInput
    isNot?: MateriaWhereInput
  }

  export type NRCCountOrderByAggregateInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type NRCAvgOrderByAggregateInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
  }

  export type NRCMaxOrderByAggregateInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type NRCMinOrderByAggregateInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type NRCSumOrderByAggregateInput = {
    codigo_nrc?: SortOrder
    materia_id?: SortOrder
    profesor_id?: SortOrder
  }

  export type RolUsuarioListRelationFilter = {
    every?: RolUsuarioWhereInput
    some?: RolUsuarioWhereInput
    none?: RolUsuarioWhereInput
  }

  export type RolUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EndpointScalarRelationFilter = {
    is?: EndpointWhereInput
    isNot?: EndpointWhereInput
  }

  export type RolScalarRelationFilter = {
    is?: RolWhereInput
    isNot?: RolWhereInput
  }

  export type RolEndpointId_endpointId_rolCompoundUniqueInput = {
    id_endpoint: number
    id_rol: number
  }

  export type RolEndpointCountOrderByAggregateInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolEndpointAvgOrderByAggregateInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
  }

  export type RolEndpointMaxOrderByAggregateInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolEndpointMinOrderByAggregateInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolEndpointSumOrderByAggregateInput = {
    id_rol?: SortOrder
    id_endpoint?: SortOrder
  }

  export type RolUsuarioId_rolId_usuarioCompoundUniqueInput = {
    id_rol: number
    id_usuario: number
  }

  export type RolUsuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolUsuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
  }

  export type RolUsuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolUsuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RolUsuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
  }

  export type CriterioScalarRelationFilter = {
    is?: CriterioWhereInput
    isNot?: CriterioWhereInput
  }

  export type EvaluacionScalarRelationFilter = {
    is?: EvaluacionWhereInput
    isNot?: EvaluacionWhereInput
  }

  export type RubricaId_criterioId_evaluacionCompoundUniqueInput = {
    id_criterio: number
    id_evaluacion: number
  }

  export type RubricaCountOrderByAggregateInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RubricaAvgOrderByAggregateInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
  }

  export type RubricaMaxOrderByAggregateInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RubricaMinOrderByAggregateInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type RubricaSumOrderByAggregateInput = {
    id_evaluacion?: SortOrder
    id_criterio?: SortOrder
    valoracion?: SortOrder
  }

  export type EstudianteNullableScalarRelationFilter = {
    is?: EstudianteWhereInput | null
    isNot?: EstudianteWhereInput | null
  }

  export type JuradoNullableScalarRelationFilter = {
    is?: JuradoWhereInput | null
    isNot?: JuradoWhereInput | null
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    email?: SortOrder
    hash_contrasena?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    email?: SortOrder
    hash_contrasena?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    email?: SortOrder
    hash_contrasena?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VideojuegoCountOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    nombre_videojuego?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type VideojuegoAvgOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
  }

  export type VideojuegoMaxOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    nombre_videojuego?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type VideojuegoMinOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
    nombre_videojuego?: SortOrder
    descripcion?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    deleted?: SortOrder
  }

  export type VideojuegoSumOrderByAggregateInput = {
    id?: SortOrder
    equipo_id?: SortOrder
  }

  export type VideojuegoAsignadoId_videojuegoId_juradoCompoundUniqueInput = {
    id_videojuego: number
    id_jurado: number
  }

  export type VideojuegoAsignadoCountOrderByAggregateInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type VideojuegoAsignadoAvgOrderByAggregateInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
  }

  export type VideojuegoAsignadoMaxOrderByAggregateInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type VideojuegoAsignadoMinOrderByAggregateInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
    create_at?: SortOrder
    deleted?: SortOrder
  }

  export type VideojuegoAsignadoSumOrderByAggregateInput = {
    id_videojuego?: SortOrder
    id_jurado?: SortOrder
  }

  export type RubricaCreateNestedManyWithoutCriterioInput = {
    create?: XOR<RubricaCreateWithoutCriterioInput, RubricaUncheckedCreateWithoutCriterioInput> | RubricaCreateWithoutCriterioInput[] | RubricaUncheckedCreateWithoutCriterioInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutCriterioInput | RubricaCreateOrConnectWithoutCriterioInput[]
    createMany?: RubricaCreateManyCriterioInputEnvelope
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
  }

  export type RubricaUncheckedCreateNestedManyWithoutCriterioInput = {
    create?: XOR<RubricaCreateWithoutCriterioInput, RubricaUncheckedCreateWithoutCriterioInput> | RubricaCreateWithoutCriterioInput[] | RubricaUncheckedCreateWithoutCriterioInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutCriterioInput | RubricaCreateOrConnectWithoutCriterioInput[]
    createMany?: RubricaCreateManyCriterioInputEnvelope
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RubricaUpdateManyWithoutCriterioNestedInput = {
    create?: XOR<RubricaCreateWithoutCriterioInput, RubricaUncheckedCreateWithoutCriterioInput> | RubricaCreateWithoutCriterioInput[] | RubricaUncheckedCreateWithoutCriterioInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutCriterioInput | RubricaCreateOrConnectWithoutCriterioInput[]
    upsert?: RubricaUpsertWithWhereUniqueWithoutCriterioInput | RubricaUpsertWithWhereUniqueWithoutCriterioInput[]
    createMany?: RubricaCreateManyCriterioInputEnvelope
    set?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    disconnect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    delete?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    update?: RubricaUpdateWithWhereUniqueWithoutCriterioInput | RubricaUpdateWithWhereUniqueWithoutCriterioInput[]
    updateMany?: RubricaUpdateManyWithWhereWithoutCriterioInput | RubricaUpdateManyWithWhereWithoutCriterioInput[]
    deleteMany?: RubricaScalarWhereInput | RubricaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RubricaUncheckedUpdateManyWithoutCriterioNestedInput = {
    create?: XOR<RubricaCreateWithoutCriterioInput, RubricaUncheckedCreateWithoutCriterioInput> | RubricaCreateWithoutCriterioInput[] | RubricaUncheckedCreateWithoutCriterioInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutCriterioInput | RubricaCreateOrConnectWithoutCriterioInput[]
    upsert?: RubricaUpsertWithWhereUniqueWithoutCriterioInput | RubricaUpsertWithWhereUniqueWithoutCriterioInput[]
    createMany?: RubricaCreateManyCriterioInputEnvelope
    set?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    disconnect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    delete?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    update?: RubricaUpdateWithWhereUniqueWithoutCriterioInput | RubricaUpdateWithWhereUniqueWithoutCriterioInput[]
    updateMany?: RubricaUpdateManyWithWhereWithoutCriterioInput | RubricaUpdateManyWithWhereWithoutCriterioInput[]
    deleteMany?: RubricaScalarWhereInput | RubricaScalarWhereInput[]
  }

  export type RolEndpointCreateNestedManyWithoutEndpointInput = {
    create?: XOR<RolEndpointCreateWithoutEndpointInput, RolEndpointUncheckedCreateWithoutEndpointInput> | RolEndpointCreateWithoutEndpointInput[] | RolEndpointUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutEndpointInput | RolEndpointCreateOrConnectWithoutEndpointInput[]
    createMany?: RolEndpointCreateManyEndpointInputEnvelope
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
  }

  export type RolEndpointUncheckedCreateNestedManyWithoutEndpointInput = {
    create?: XOR<RolEndpointCreateWithoutEndpointInput, RolEndpointUncheckedCreateWithoutEndpointInput> | RolEndpointCreateWithoutEndpointInput[] | RolEndpointUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutEndpointInput | RolEndpointCreateOrConnectWithoutEndpointInput[]
    createMany?: RolEndpointCreateManyEndpointInputEnvelope
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumTipoFieldUpdateOperationsInput = {
    set?: $Enums.Tipo
  }

  export type RolEndpointUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<RolEndpointCreateWithoutEndpointInput, RolEndpointUncheckedCreateWithoutEndpointInput> | RolEndpointCreateWithoutEndpointInput[] | RolEndpointUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutEndpointInput | RolEndpointCreateOrConnectWithoutEndpointInput[]
    upsert?: RolEndpointUpsertWithWhereUniqueWithoutEndpointInput | RolEndpointUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: RolEndpointCreateManyEndpointInputEnvelope
    set?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    disconnect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    delete?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    update?: RolEndpointUpdateWithWhereUniqueWithoutEndpointInput | RolEndpointUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: RolEndpointUpdateManyWithWhereWithoutEndpointInput | RolEndpointUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: RolEndpointScalarWhereInput | RolEndpointScalarWhereInput[]
  }

  export type RolEndpointUncheckedUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<RolEndpointCreateWithoutEndpointInput, RolEndpointUncheckedCreateWithoutEndpointInput> | RolEndpointCreateWithoutEndpointInput[] | RolEndpointUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutEndpointInput | RolEndpointCreateOrConnectWithoutEndpointInput[]
    upsert?: RolEndpointUpsertWithWhereUniqueWithoutEndpointInput | RolEndpointUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: RolEndpointCreateManyEndpointInputEnvelope
    set?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    disconnect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    delete?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    update?: RolEndpointUpdateWithWhereUniqueWithoutEndpointInput | RolEndpointUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: RolEndpointUpdateManyWithWhereWithoutEndpointInput | RolEndpointUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: RolEndpointScalarWhereInput | RolEndpointScalarWhereInput[]
  }

  export type EstudianteCreateNestedManyWithoutEquipoInput = {
    create?: XOR<EstudianteCreateWithoutEquipoInput, EstudianteUncheckedCreateWithoutEquipoInput> | EstudianteCreateWithoutEquipoInput[] | EstudianteUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutEquipoInput | EstudianteCreateOrConnectWithoutEquipoInput[]
    createMany?: EstudianteCreateManyEquipoInputEnvelope
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
  }

  export type VideojuegoCreateNestedManyWithoutEquipoInput = {
    create?: XOR<VideojuegoCreateWithoutEquipoInput, VideojuegoUncheckedCreateWithoutEquipoInput> | VideojuegoCreateWithoutEquipoInput[] | VideojuegoUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: VideojuegoCreateOrConnectWithoutEquipoInput | VideojuegoCreateOrConnectWithoutEquipoInput[]
    createMany?: VideojuegoCreateManyEquipoInputEnvelope
    connect?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
  }

  export type EstudianteUncheckedCreateNestedManyWithoutEquipoInput = {
    create?: XOR<EstudianteCreateWithoutEquipoInput, EstudianteUncheckedCreateWithoutEquipoInput> | EstudianteCreateWithoutEquipoInput[] | EstudianteUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutEquipoInput | EstudianteCreateOrConnectWithoutEquipoInput[]
    createMany?: EstudianteCreateManyEquipoInputEnvelope
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
  }

  export type VideojuegoUncheckedCreateNestedManyWithoutEquipoInput = {
    create?: XOR<VideojuegoCreateWithoutEquipoInput, VideojuegoUncheckedCreateWithoutEquipoInput> | VideojuegoCreateWithoutEquipoInput[] | VideojuegoUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: VideojuegoCreateOrConnectWithoutEquipoInput | VideojuegoCreateOrConnectWithoutEquipoInput[]
    createMany?: VideojuegoCreateManyEquipoInputEnvelope
    connect?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
  }

  export type EnumEstadoFieldUpdateOperationsInput = {
    set?: $Enums.Estado
  }

  export type EstudianteUpdateManyWithoutEquipoNestedInput = {
    create?: XOR<EstudianteCreateWithoutEquipoInput, EstudianteUncheckedCreateWithoutEquipoInput> | EstudianteCreateWithoutEquipoInput[] | EstudianteUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutEquipoInput | EstudianteCreateOrConnectWithoutEquipoInput[]
    upsert?: EstudianteUpsertWithWhereUniqueWithoutEquipoInput | EstudianteUpsertWithWhereUniqueWithoutEquipoInput[]
    createMany?: EstudianteCreateManyEquipoInputEnvelope
    set?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    disconnect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    delete?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    update?: EstudianteUpdateWithWhereUniqueWithoutEquipoInput | EstudianteUpdateWithWhereUniqueWithoutEquipoInput[]
    updateMany?: EstudianteUpdateManyWithWhereWithoutEquipoInput | EstudianteUpdateManyWithWhereWithoutEquipoInput[]
    deleteMany?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
  }

  export type VideojuegoUpdateManyWithoutEquipoNestedInput = {
    create?: XOR<VideojuegoCreateWithoutEquipoInput, VideojuegoUncheckedCreateWithoutEquipoInput> | VideojuegoCreateWithoutEquipoInput[] | VideojuegoUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: VideojuegoCreateOrConnectWithoutEquipoInput | VideojuegoCreateOrConnectWithoutEquipoInput[]
    upsert?: VideojuegoUpsertWithWhereUniqueWithoutEquipoInput | VideojuegoUpsertWithWhereUniqueWithoutEquipoInput[]
    createMany?: VideojuegoCreateManyEquipoInputEnvelope
    set?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    disconnect?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    delete?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    connect?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    update?: VideojuegoUpdateWithWhereUniqueWithoutEquipoInput | VideojuegoUpdateWithWhereUniqueWithoutEquipoInput[]
    updateMany?: VideojuegoUpdateManyWithWhereWithoutEquipoInput | VideojuegoUpdateManyWithWhereWithoutEquipoInput[]
    deleteMany?: VideojuegoScalarWhereInput | VideojuegoScalarWhereInput[]
  }

  export type EstudianteUncheckedUpdateManyWithoutEquipoNestedInput = {
    create?: XOR<EstudianteCreateWithoutEquipoInput, EstudianteUncheckedCreateWithoutEquipoInput> | EstudianteCreateWithoutEquipoInput[] | EstudianteUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutEquipoInput | EstudianteCreateOrConnectWithoutEquipoInput[]
    upsert?: EstudianteUpsertWithWhereUniqueWithoutEquipoInput | EstudianteUpsertWithWhereUniqueWithoutEquipoInput[]
    createMany?: EstudianteCreateManyEquipoInputEnvelope
    set?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    disconnect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    delete?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    update?: EstudianteUpdateWithWhereUniqueWithoutEquipoInput | EstudianteUpdateWithWhereUniqueWithoutEquipoInput[]
    updateMany?: EstudianteUpdateManyWithWhereWithoutEquipoInput | EstudianteUpdateManyWithWhereWithoutEquipoInput[]
    deleteMany?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
  }

  export type VideojuegoUncheckedUpdateManyWithoutEquipoNestedInput = {
    create?: XOR<VideojuegoCreateWithoutEquipoInput, VideojuegoUncheckedCreateWithoutEquipoInput> | VideojuegoCreateWithoutEquipoInput[] | VideojuegoUncheckedCreateWithoutEquipoInput[]
    connectOrCreate?: VideojuegoCreateOrConnectWithoutEquipoInput | VideojuegoCreateOrConnectWithoutEquipoInput[]
    upsert?: VideojuegoUpsertWithWhereUniqueWithoutEquipoInput | VideojuegoUpsertWithWhereUniqueWithoutEquipoInput[]
    createMany?: VideojuegoCreateManyEquipoInputEnvelope
    set?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    disconnect?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    delete?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    connect?: VideojuegoWhereUniqueInput | VideojuegoWhereUniqueInput[]
    update?: VideojuegoUpdateWithWhereUniqueWithoutEquipoInput | VideojuegoUpdateWithWhereUniqueWithoutEquipoInput[]
    updateMany?: VideojuegoUpdateManyWithWhereWithoutEquipoInput | VideojuegoUpdateManyWithWhereWithoutEquipoInput[]
    deleteMany?: VideojuegoScalarWhereInput | VideojuegoScalarWhereInput[]
  }

  export type EquipoCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<EquipoCreateWithoutEstudianteInput, EquipoUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: EquipoCreateOrConnectWithoutEstudianteInput
    connect?: EquipoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEstudianteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EstudianteNRCCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<EstudianteNRCCreateWithoutEstudianteInput, EstudianteNRCUncheckedCreateWithoutEstudianteInput> | EstudianteNRCCreateWithoutEstudianteInput[] | EstudianteNRCUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutEstudianteInput | EstudianteNRCCreateOrConnectWithoutEstudianteInput[]
    createMany?: EstudianteNRCCreateManyEstudianteInputEnvelope
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
  }

  export type EstudianteNRCUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<EstudianteNRCCreateWithoutEstudianteInput, EstudianteNRCUncheckedCreateWithoutEstudianteInput> | EstudianteNRCCreateWithoutEstudianteInput[] | EstudianteNRCUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutEstudianteInput | EstudianteNRCCreateOrConnectWithoutEstudianteInput[]
    createMany?: EstudianteNRCCreateManyEstudianteInputEnvelope
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
  }

  export type EquipoUpdateOneRequiredWithoutEstudianteNestedInput = {
    create?: XOR<EquipoCreateWithoutEstudianteInput, EquipoUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: EquipoCreateOrConnectWithoutEstudianteInput
    upsert?: EquipoUpsertWithoutEstudianteInput
    connect?: EquipoWhereUniqueInput
    update?: XOR<XOR<EquipoUpdateToOneWithWhereWithoutEstudianteInput, EquipoUpdateWithoutEstudianteInput>, EquipoUncheckedUpdateWithoutEstudianteInput>
  }

  export type UsuarioUpdateOneRequiredWithoutEstudianteNestedInput = {
    create?: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEstudianteInput
    upsert?: UsuarioUpsertWithoutEstudianteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEstudianteInput, UsuarioUpdateWithoutEstudianteInput>, UsuarioUncheckedUpdateWithoutEstudianteInput>
  }

  export type EstudianteNRCUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<EstudianteNRCCreateWithoutEstudianteInput, EstudianteNRCUncheckedCreateWithoutEstudianteInput> | EstudianteNRCCreateWithoutEstudianteInput[] | EstudianteNRCUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutEstudianteInput | EstudianteNRCCreateOrConnectWithoutEstudianteInput[]
    upsert?: EstudianteNRCUpsertWithWhereUniqueWithoutEstudianteInput | EstudianteNRCUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: EstudianteNRCCreateManyEstudianteInputEnvelope
    set?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    disconnect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    delete?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    update?: EstudianteNRCUpdateWithWhereUniqueWithoutEstudianteInput | EstudianteNRCUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: EstudianteNRCUpdateManyWithWhereWithoutEstudianteInput | EstudianteNRCUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: EstudianteNRCScalarWhereInput | EstudianteNRCScalarWhereInput[]
  }

  export type EstudianteNRCUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<EstudianteNRCCreateWithoutEstudianteInput, EstudianteNRCUncheckedCreateWithoutEstudianteInput> | EstudianteNRCCreateWithoutEstudianteInput[] | EstudianteNRCUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutEstudianteInput | EstudianteNRCCreateOrConnectWithoutEstudianteInput[]
    upsert?: EstudianteNRCUpsertWithWhereUniqueWithoutEstudianteInput | EstudianteNRCUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: EstudianteNRCCreateManyEstudianteInputEnvelope
    set?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    disconnect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    delete?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    update?: EstudianteNRCUpdateWithWhereUniqueWithoutEstudianteInput | EstudianteNRCUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: EstudianteNRCUpdateManyWithWhereWithoutEstudianteInput | EstudianteNRCUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: EstudianteNRCScalarWhereInput | EstudianteNRCScalarWhereInput[]
  }

  export type EstudianteCreateNestedOneWithoutEstudianteNRCInput = {
    create?: XOR<EstudianteCreateWithoutEstudianteNRCInput, EstudianteUncheckedCreateWithoutEstudianteNRCInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutEstudianteNRCInput
    connect?: EstudianteWhereUniqueInput
  }

  export type NRCCreateNestedOneWithoutEstudianteNRCInput = {
    create?: XOR<NRCCreateWithoutEstudianteNRCInput, NRCUncheckedCreateWithoutEstudianteNRCInput>
    connectOrCreate?: NRCCreateOrConnectWithoutEstudianteNRCInput
    connect?: NRCWhereUniqueInput
  }

  export type EstudianteUpdateOneRequiredWithoutEstudianteNRCNestedInput = {
    create?: XOR<EstudianteCreateWithoutEstudianteNRCInput, EstudianteUncheckedCreateWithoutEstudianteNRCInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutEstudianteNRCInput
    upsert?: EstudianteUpsertWithoutEstudianteNRCInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutEstudianteNRCInput, EstudianteUpdateWithoutEstudianteNRCInput>, EstudianteUncheckedUpdateWithoutEstudianteNRCInput>
  }

  export type NRCUpdateOneRequiredWithoutEstudianteNRCNestedInput = {
    create?: XOR<NRCCreateWithoutEstudianteNRCInput, NRCUncheckedCreateWithoutEstudianteNRCInput>
    connectOrCreate?: NRCCreateOrConnectWithoutEstudianteNRCInput
    upsert?: NRCUpsertWithoutEstudianteNRCInput
    connect?: NRCWhereUniqueInput
    update?: XOR<XOR<NRCUpdateToOneWithWhereWithoutEstudianteNRCInput, NRCUpdateWithoutEstudianteNRCInput>, NRCUncheckedUpdateWithoutEstudianteNRCInput>
  }

  export type JuradoCreateNestedOneWithoutEvaluacionInput = {
    create?: XOR<JuradoCreateWithoutEvaluacionInput, JuradoUncheckedCreateWithoutEvaluacionInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutEvaluacionInput
    connect?: JuradoWhereUniqueInput
  }

  export type VideojuegoCreateNestedOneWithoutEvaluacionInput = {
    create?: XOR<VideojuegoCreateWithoutEvaluacionInput, VideojuegoUncheckedCreateWithoutEvaluacionInput>
    connectOrCreate?: VideojuegoCreateOrConnectWithoutEvaluacionInput
    connect?: VideojuegoWhereUniqueInput
  }

  export type RubricaCreateNestedManyWithoutEvaluacionInput = {
    create?: XOR<RubricaCreateWithoutEvaluacionInput, RubricaUncheckedCreateWithoutEvaluacionInput> | RubricaCreateWithoutEvaluacionInput[] | RubricaUncheckedCreateWithoutEvaluacionInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutEvaluacionInput | RubricaCreateOrConnectWithoutEvaluacionInput[]
    createMany?: RubricaCreateManyEvaluacionInputEnvelope
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
  }

  export type RubricaUncheckedCreateNestedManyWithoutEvaluacionInput = {
    create?: XOR<RubricaCreateWithoutEvaluacionInput, RubricaUncheckedCreateWithoutEvaluacionInput> | RubricaCreateWithoutEvaluacionInput[] | RubricaUncheckedCreateWithoutEvaluacionInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutEvaluacionInput | RubricaCreateOrConnectWithoutEvaluacionInput[]
    createMany?: RubricaCreateManyEvaluacionInputEnvelope
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
  }

  export type JuradoUpdateOneRequiredWithoutEvaluacionNestedInput = {
    create?: XOR<JuradoCreateWithoutEvaluacionInput, JuradoUncheckedCreateWithoutEvaluacionInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutEvaluacionInput
    upsert?: JuradoUpsertWithoutEvaluacionInput
    connect?: JuradoWhereUniqueInput
    update?: XOR<XOR<JuradoUpdateToOneWithWhereWithoutEvaluacionInput, JuradoUpdateWithoutEvaluacionInput>, JuradoUncheckedUpdateWithoutEvaluacionInput>
  }

  export type VideojuegoUpdateOneRequiredWithoutEvaluacionNestedInput = {
    create?: XOR<VideojuegoCreateWithoutEvaluacionInput, VideojuegoUncheckedCreateWithoutEvaluacionInput>
    connectOrCreate?: VideojuegoCreateOrConnectWithoutEvaluacionInput
    upsert?: VideojuegoUpsertWithoutEvaluacionInput
    connect?: VideojuegoWhereUniqueInput
    update?: XOR<XOR<VideojuegoUpdateToOneWithWhereWithoutEvaluacionInput, VideojuegoUpdateWithoutEvaluacionInput>, VideojuegoUncheckedUpdateWithoutEvaluacionInput>
  }

  export type RubricaUpdateManyWithoutEvaluacionNestedInput = {
    create?: XOR<RubricaCreateWithoutEvaluacionInput, RubricaUncheckedCreateWithoutEvaluacionInput> | RubricaCreateWithoutEvaluacionInput[] | RubricaUncheckedCreateWithoutEvaluacionInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutEvaluacionInput | RubricaCreateOrConnectWithoutEvaluacionInput[]
    upsert?: RubricaUpsertWithWhereUniqueWithoutEvaluacionInput | RubricaUpsertWithWhereUniqueWithoutEvaluacionInput[]
    createMany?: RubricaCreateManyEvaluacionInputEnvelope
    set?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    disconnect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    delete?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    update?: RubricaUpdateWithWhereUniqueWithoutEvaluacionInput | RubricaUpdateWithWhereUniqueWithoutEvaluacionInput[]
    updateMany?: RubricaUpdateManyWithWhereWithoutEvaluacionInput | RubricaUpdateManyWithWhereWithoutEvaluacionInput[]
    deleteMany?: RubricaScalarWhereInput | RubricaScalarWhereInput[]
  }

  export type RubricaUncheckedUpdateManyWithoutEvaluacionNestedInput = {
    create?: XOR<RubricaCreateWithoutEvaluacionInput, RubricaUncheckedCreateWithoutEvaluacionInput> | RubricaCreateWithoutEvaluacionInput[] | RubricaUncheckedCreateWithoutEvaluacionInput[]
    connectOrCreate?: RubricaCreateOrConnectWithoutEvaluacionInput | RubricaCreateOrConnectWithoutEvaluacionInput[]
    upsert?: RubricaUpsertWithWhereUniqueWithoutEvaluacionInput | RubricaUpsertWithWhereUniqueWithoutEvaluacionInput[]
    createMany?: RubricaCreateManyEvaluacionInputEnvelope
    set?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    disconnect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    delete?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    connect?: RubricaWhereUniqueInput | RubricaWhereUniqueInput[]
    update?: RubricaUpdateWithWhereUniqueWithoutEvaluacionInput | RubricaUpdateWithWhereUniqueWithoutEvaluacionInput[]
    updateMany?: RubricaUpdateManyWithWhereWithoutEvaluacionInput | RubricaUpdateManyWithWhereWithoutEvaluacionInput[]
    deleteMany?: RubricaScalarWhereInput | RubricaScalarWhereInput[]
  }

  export type EvaluacionCreateNestedManyWithoutJuradoInput = {
    create?: XOR<EvaluacionCreateWithoutJuradoInput, EvaluacionUncheckedCreateWithoutJuradoInput> | EvaluacionCreateWithoutJuradoInput[] | EvaluacionUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutJuradoInput | EvaluacionCreateOrConnectWithoutJuradoInput[]
    createMany?: EvaluacionCreateManyJuradoInputEnvelope
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
  }

  export type UsuarioCreateNestedOneWithoutJuradoInput = {
    create?: XOR<UsuarioCreateWithoutJuradoInput, UsuarioUncheckedCreateWithoutJuradoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutJuradoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type VideojuegoAsignadoCreateNestedManyWithoutJuradoInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutJuradoInput, VideojuegoAsignadoUncheckedCreateWithoutJuradoInput> | VideojuegoAsignadoCreateWithoutJuradoInput[] | VideojuegoAsignadoUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutJuradoInput | VideojuegoAsignadoCreateOrConnectWithoutJuradoInput[]
    createMany?: VideojuegoAsignadoCreateManyJuradoInputEnvelope
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
  }

  export type EvaluacionUncheckedCreateNestedManyWithoutJuradoInput = {
    create?: XOR<EvaluacionCreateWithoutJuradoInput, EvaluacionUncheckedCreateWithoutJuradoInput> | EvaluacionCreateWithoutJuradoInput[] | EvaluacionUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutJuradoInput | EvaluacionCreateOrConnectWithoutJuradoInput[]
    createMany?: EvaluacionCreateManyJuradoInputEnvelope
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
  }

  export type VideojuegoAsignadoUncheckedCreateNestedManyWithoutJuradoInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutJuradoInput, VideojuegoAsignadoUncheckedCreateWithoutJuradoInput> | VideojuegoAsignadoCreateWithoutJuradoInput[] | VideojuegoAsignadoUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutJuradoInput | VideojuegoAsignadoCreateOrConnectWithoutJuradoInput[]
    createMany?: VideojuegoAsignadoCreateManyJuradoInputEnvelope
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
  }

  export type EnumEstadoJuradoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoJurado
  }

  export type EvaluacionUpdateManyWithoutJuradoNestedInput = {
    create?: XOR<EvaluacionCreateWithoutJuradoInput, EvaluacionUncheckedCreateWithoutJuradoInput> | EvaluacionCreateWithoutJuradoInput[] | EvaluacionUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutJuradoInput | EvaluacionCreateOrConnectWithoutJuradoInput[]
    upsert?: EvaluacionUpsertWithWhereUniqueWithoutJuradoInput | EvaluacionUpsertWithWhereUniqueWithoutJuradoInput[]
    createMany?: EvaluacionCreateManyJuradoInputEnvelope
    set?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    disconnect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    delete?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    update?: EvaluacionUpdateWithWhereUniqueWithoutJuradoInput | EvaluacionUpdateWithWhereUniqueWithoutJuradoInput[]
    updateMany?: EvaluacionUpdateManyWithWhereWithoutJuradoInput | EvaluacionUpdateManyWithWhereWithoutJuradoInput[]
    deleteMany?: EvaluacionScalarWhereInput | EvaluacionScalarWhereInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutJuradoNestedInput = {
    create?: XOR<UsuarioCreateWithoutJuradoInput, UsuarioUncheckedCreateWithoutJuradoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutJuradoInput
    upsert?: UsuarioUpsertWithoutJuradoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutJuradoInput, UsuarioUpdateWithoutJuradoInput>, UsuarioUncheckedUpdateWithoutJuradoInput>
  }

  export type VideojuegoAsignadoUpdateManyWithoutJuradoNestedInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutJuradoInput, VideojuegoAsignadoUncheckedCreateWithoutJuradoInput> | VideojuegoAsignadoCreateWithoutJuradoInput[] | VideojuegoAsignadoUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutJuradoInput | VideojuegoAsignadoCreateOrConnectWithoutJuradoInput[]
    upsert?: VideojuegoAsignadoUpsertWithWhereUniqueWithoutJuradoInput | VideojuegoAsignadoUpsertWithWhereUniqueWithoutJuradoInput[]
    createMany?: VideojuegoAsignadoCreateManyJuradoInputEnvelope
    set?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    disconnect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    delete?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    update?: VideojuegoAsignadoUpdateWithWhereUniqueWithoutJuradoInput | VideojuegoAsignadoUpdateWithWhereUniqueWithoutJuradoInput[]
    updateMany?: VideojuegoAsignadoUpdateManyWithWhereWithoutJuradoInput | VideojuegoAsignadoUpdateManyWithWhereWithoutJuradoInput[]
    deleteMany?: VideojuegoAsignadoScalarWhereInput | VideojuegoAsignadoScalarWhereInput[]
  }

  export type EvaluacionUncheckedUpdateManyWithoutJuradoNestedInput = {
    create?: XOR<EvaluacionCreateWithoutJuradoInput, EvaluacionUncheckedCreateWithoutJuradoInput> | EvaluacionCreateWithoutJuradoInput[] | EvaluacionUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutJuradoInput | EvaluacionCreateOrConnectWithoutJuradoInput[]
    upsert?: EvaluacionUpsertWithWhereUniqueWithoutJuradoInput | EvaluacionUpsertWithWhereUniqueWithoutJuradoInput[]
    createMany?: EvaluacionCreateManyJuradoInputEnvelope
    set?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    disconnect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    delete?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    update?: EvaluacionUpdateWithWhereUniqueWithoutJuradoInput | EvaluacionUpdateWithWhereUniqueWithoutJuradoInput[]
    updateMany?: EvaluacionUpdateManyWithWhereWithoutJuradoInput | EvaluacionUpdateManyWithWhereWithoutJuradoInput[]
    deleteMany?: EvaluacionScalarWhereInput | EvaluacionScalarWhereInput[]
  }

  export type VideojuegoAsignadoUncheckedUpdateManyWithoutJuradoNestedInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutJuradoInput, VideojuegoAsignadoUncheckedCreateWithoutJuradoInput> | VideojuegoAsignadoCreateWithoutJuradoInput[] | VideojuegoAsignadoUncheckedCreateWithoutJuradoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutJuradoInput | VideojuegoAsignadoCreateOrConnectWithoutJuradoInput[]
    upsert?: VideojuegoAsignadoUpsertWithWhereUniqueWithoutJuradoInput | VideojuegoAsignadoUpsertWithWhereUniqueWithoutJuradoInput[]
    createMany?: VideojuegoAsignadoCreateManyJuradoInputEnvelope
    set?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    disconnect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    delete?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    update?: VideojuegoAsignadoUpdateWithWhereUniqueWithoutJuradoInput | VideojuegoAsignadoUpdateWithWhereUniqueWithoutJuradoInput[]
    updateMany?: VideojuegoAsignadoUpdateManyWithWhereWithoutJuradoInput | VideojuegoAsignadoUpdateManyWithWhereWithoutJuradoInput[]
    deleteMany?: VideojuegoAsignadoScalarWhereInput | VideojuegoAsignadoScalarWhereInput[]
  }

  export type NRCCreateNestedManyWithoutMateriaInput = {
    create?: XOR<NRCCreateWithoutMateriaInput, NRCUncheckedCreateWithoutMateriaInput> | NRCCreateWithoutMateriaInput[] | NRCUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutMateriaInput | NRCCreateOrConnectWithoutMateriaInput[]
    createMany?: NRCCreateManyMateriaInputEnvelope
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
  }

  export type NRCUncheckedCreateNestedManyWithoutMateriaInput = {
    create?: XOR<NRCCreateWithoutMateriaInput, NRCUncheckedCreateWithoutMateriaInput> | NRCCreateWithoutMateriaInput[] | NRCUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutMateriaInput | NRCCreateOrConnectWithoutMateriaInput[]
    createMany?: NRCCreateManyMateriaInputEnvelope
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
  }

  export type NRCUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<NRCCreateWithoutMateriaInput, NRCUncheckedCreateWithoutMateriaInput> | NRCCreateWithoutMateriaInput[] | NRCUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutMateriaInput | NRCCreateOrConnectWithoutMateriaInput[]
    upsert?: NRCUpsertWithWhereUniqueWithoutMateriaInput | NRCUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: NRCCreateManyMateriaInputEnvelope
    set?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    disconnect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    delete?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    update?: NRCUpdateWithWhereUniqueWithoutMateriaInput | NRCUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: NRCUpdateManyWithWhereWithoutMateriaInput | NRCUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: NRCScalarWhereInput | NRCScalarWhereInput[]
  }

  export type NRCUncheckedUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<NRCCreateWithoutMateriaInput, NRCUncheckedCreateWithoutMateriaInput> | NRCCreateWithoutMateriaInput[] | NRCUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutMateriaInput | NRCCreateOrConnectWithoutMateriaInput[]
    upsert?: NRCUpsertWithWhereUniqueWithoutMateriaInput | NRCUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: NRCCreateManyMateriaInputEnvelope
    set?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    disconnect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    delete?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    update?: NRCUpdateWithWhereUniqueWithoutMateriaInput | NRCUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: NRCUpdateManyWithWhereWithoutMateriaInput | NRCUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: NRCScalarWhereInput | NRCScalarWhereInput[]
  }

  export type EstudianteNRCCreateNestedManyWithoutNRCInput = {
    create?: XOR<EstudianteNRCCreateWithoutNRCInput, EstudianteNRCUncheckedCreateWithoutNRCInput> | EstudianteNRCCreateWithoutNRCInput[] | EstudianteNRCUncheckedCreateWithoutNRCInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutNRCInput | EstudianteNRCCreateOrConnectWithoutNRCInput[]
    createMany?: EstudianteNRCCreateManyNRCInputEnvelope
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
  }

  export type MateriaCreateNestedOneWithoutNRCInput = {
    create?: XOR<MateriaCreateWithoutNRCInput, MateriaUncheckedCreateWithoutNRCInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutNRCInput
    connect?: MateriaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutNRCInput = {
    create?: XOR<UsuarioCreateWithoutNRCInput, UsuarioUncheckedCreateWithoutNRCInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNRCInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EstudianteNRCUncheckedCreateNestedManyWithoutNRCInput = {
    create?: XOR<EstudianteNRCCreateWithoutNRCInput, EstudianteNRCUncheckedCreateWithoutNRCInput> | EstudianteNRCCreateWithoutNRCInput[] | EstudianteNRCUncheckedCreateWithoutNRCInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutNRCInput | EstudianteNRCCreateOrConnectWithoutNRCInput[]
    createMany?: EstudianteNRCCreateManyNRCInputEnvelope
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
  }

  export type EstudianteNRCUpdateManyWithoutNRCNestedInput = {
    create?: XOR<EstudianteNRCCreateWithoutNRCInput, EstudianteNRCUncheckedCreateWithoutNRCInput> | EstudianteNRCCreateWithoutNRCInput[] | EstudianteNRCUncheckedCreateWithoutNRCInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutNRCInput | EstudianteNRCCreateOrConnectWithoutNRCInput[]
    upsert?: EstudianteNRCUpsertWithWhereUniqueWithoutNRCInput | EstudianteNRCUpsertWithWhereUniqueWithoutNRCInput[]
    createMany?: EstudianteNRCCreateManyNRCInputEnvelope
    set?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    disconnect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    delete?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    update?: EstudianteNRCUpdateWithWhereUniqueWithoutNRCInput | EstudianteNRCUpdateWithWhereUniqueWithoutNRCInput[]
    updateMany?: EstudianteNRCUpdateManyWithWhereWithoutNRCInput | EstudianteNRCUpdateManyWithWhereWithoutNRCInput[]
    deleteMany?: EstudianteNRCScalarWhereInput | EstudianteNRCScalarWhereInput[]
  }

  export type MateriaUpdateOneRequiredWithoutNRCNestedInput = {
    create?: XOR<MateriaCreateWithoutNRCInput, MateriaUncheckedCreateWithoutNRCInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutNRCInput
    upsert?: MateriaUpsertWithoutNRCInput
    connect?: MateriaWhereUniqueInput
    update?: XOR<XOR<MateriaUpdateToOneWithWhereWithoutNRCInput, MateriaUpdateWithoutNRCInput>, MateriaUncheckedUpdateWithoutNRCInput>
  }

  export type UsuarioUpdateOneRequiredWithoutNRCNestedInput = {
    create?: XOR<UsuarioCreateWithoutNRCInput, UsuarioUncheckedCreateWithoutNRCInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNRCInput
    upsert?: UsuarioUpsertWithoutNRCInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutNRCInput, UsuarioUpdateWithoutNRCInput>, UsuarioUncheckedUpdateWithoutNRCInput>
  }

  export type EstudianteNRCUncheckedUpdateManyWithoutNRCNestedInput = {
    create?: XOR<EstudianteNRCCreateWithoutNRCInput, EstudianteNRCUncheckedCreateWithoutNRCInput> | EstudianteNRCCreateWithoutNRCInput[] | EstudianteNRCUncheckedCreateWithoutNRCInput[]
    connectOrCreate?: EstudianteNRCCreateOrConnectWithoutNRCInput | EstudianteNRCCreateOrConnectWithoutNRCInput[]
    upsert?: EstudianteNRCUpsertWithWhereUniqueWithoutNRCInput | EstudianteNRCUpsertWithWhereUniqueWithoutNRCInput[]
    createMany?: EstudianteNRCCreateManyNRCInputEnvelope
    set?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    disconnect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    delete?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    connect?: EstudianteNRCWhereUniqueInput | EstudianteNRCWhereUniqueInput[]
    update?: EstudianteNRCUpdateWithWhereUniqueWithoutNRCInput | EstudianteNRCUpdateWithWhereUniqueWithoutNRCInput[]
    updateMany?: EstudianteNRCUpdateManyWithWhereWithoutNRCInput | EstudianteNRCUpdateManyWithWhereWithoutNRCInput[]
    deleteMany?: EstudianteNRCScalarWhereInput | EstudianteNRCScalarWhereInput[]
  }

  export type RolEndpointCreateNestedManyWithoutRolInput = {
    create?: XOR<RolEndpointCreateWithoutRolInput, RolEndpointUncheckedCreateWithoutRolInput> | RolEndpointCreateWithoutRolInput[] | RolEndpointUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutRolInput | RolEndpointCreateOrConnectWithoutRolInput[]
    createMany?: RolEndpointCreateManyRolInputEnvelope
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
  }

  export type RolUsuarioCreateNestedManyWithoutRolInput = {
    create?: XOR<RolUsuarioCreateWithoutRolInput, RolUsuarioUncheckedCreateWithoutRolInput> | RolUsuarioCreateWithoutRolInput[] | RolUsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutRolInput | RolUsuarioCreateOrConnectWithoutRolInput[]
    createMany?: RolUsuarioCreateManyRolInputEnvelope
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
  }

  export type RolEndpointUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<RolEndpointCreateWithoutRolInput, RolEndpointUncheckedCreateWithoutRolInput> | RolEndpointCreateWithoutRolInput[] | RolEndpointUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutRolInput | RolEndpointCreateOrConnectWithoutRolInput[]
    createMany?: RolEndpointCreateManyRolInputEnvelope
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
  }

  export type RolUsuarioUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<RolUsuarioCreateWithoutRolInput, RolUsuarioUncheckedCreateWithoutRolInput> | RolUsuarioCreateWithoutRolInput[] | RolUsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutRolInput | RolUsuarioCreateOrConnectWithoutRolInput[]
    createMany?: RolUsuarioCreateManyRolInputEnvelope
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
  }

  export type RolEndpointUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolEndpointCreateWithoutRolInput, RolEndpointUncheckedCreateWithoutRolInput> | RolEndpointCreateWithoutRolInput[] | RolEndpointUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutRolInput | RolEndpointCreateOrConnectWithoutRolInput[]
    upsert?: RolEndpointUpsertWithWhereUniqueWithoutRolInput | RolEndpointUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolEndpointCreateManyRolInputEnvelope
    set?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    disconnect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    delete?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    update?: RolEndpointUpdateWithWhereUniqueWithoutRolInput | RolEndpointUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolEndpointUpdateManyWithWhereWithoutRolInput | RolEndpointUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolEndpointScalarWhereInput | RolEndpointScalarWhereInput[]
  }

  export type RolUsuarioUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolUsuarioCreateWithoutRolInput, RolUsuarioUncheckedCreateWithoutRolInput> | RolUsuarioCreateWithoutRolInput[] | RolUsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutRolInput | RolUsuarioCreateOrConnectWithoutRolInput[]
    upsert?: RolUsuarioUpsertWithWhereUniqueWithoutRolInput | RolUsuarioUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolUsuarioCreateManyRolInputEnvelope
    set?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    disconnect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    delete?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    update?: RolUsuarioUpdateWithWhereUniqueWithoutRolInput | RolUsuarioUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolUsuarioUpdateManyWithWhereWithoutRolInput | RolUsuarioUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolUsuarioScalarWhereInput | RolUsuarioScalarWhereInput[]
  }

  export type RolEndpointUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolEndpointCreateWithoutRolInput, RolEndpointUncheckedCreateWithoutRolInput> | RolEndpointCreateWithoutRolInput[] | RolEndpointUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolEndpointCreateOrConnectWithoutRolInput | RolEndpointCreateOrConnectWithoutRolInput[]
    upsert?: RolEndpointUpsertWithWhereUniqueWithoutRolInput | RolEndpointUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolEndpointCreateManyRolInputEnvelope
    set?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    disconnect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    delete?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    connect?: RolEndpointWhereUniqueInput | RolEndpointWhereUniqueInput[]
    update?: RolEndpointUpdateWithWhereUniqueWithoutRolInput | RolEndpointUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolEndpointUpdateManyWithWhereWithoutRolInput | RolEndpointUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolEndpointScalarWhereInput | RolEndpointScalarWhereInput[]
  }

  export type RolUsuarioUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolUsuarioCreateWithoutRolInput, RolUsuarioUncheckedCreateWithoutRolInput> | RolUsuarioCreateWithoutRolInput[] | RolUsuarioUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutRolInput | RolUsuarioCreateOrConnectWithoutRolInput[]
    upsert?: RolUsuarioUpsertWithWhereUniqueWithoutRolInput | RolUsuarioUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolUsuarioCreateManyRolInputEnvelope
    set?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    disconnect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    delete?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    update?: RolUsuarioUpdateWithWhereUniqueWithoutRolInput | RolUsuarioUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolUsuarioUpdateManyWithWhereWithoutRolInput | RolUsuarioUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolUsuarioScalarWhereInput | RolUsuarioScalarWhereInput[]
  }

  export type EndpointCreateNestedOneWithoutRolEndpointInput = {
    create?: XOR<EndpointCreateWithoutRolEndpointInput, EndpointUncheckedCreateWithoutRolEndpointInput>
    connectOrCreate?: EndpointCreateOrConnectWithoutRolEndpointInput
    connect?: EndpointWhereUniqueInput
  }

  export type RolCreateNestedOneWithoutRolEndpointInput = {
    create?: XOR<RolCreateWithoutRolEndpointInput, RolUncheckedCreateWithoutRolEndpointInput>
    connectOrCreate?: RolCreateOrConnectWithoutRolEndpointInput
    connect?: RolWhereUniqueInput
  }

  export type EndpointUpdateOneRequiredWithoutRolEndpointNestedInput = {
    create?: XOR<EndpointCreateWithoutRolEndpointInput, EndpointUncheckedCreateWithoutRolEndpointInput>
    connectOrCreate?: EndpointCreateOrConnectWithoutRolEndpointInput
    upsert?: EndpointUpsertWithoutRolEndpointInput
    connect?: EndpointWhereUniqueInput
    update?: XOR<XOR<EndpointUpdateToOneWithWhereWithoutRolEndpointInput, EndpointUpdateWithoutRolEndpointInput>, EndpointUncheckedUpdateWithoutRolEndpointInput>
  }

  export type RolUpdateOneRequiredWithoutRolEndpointNestedInput = {
    create?: XOR<RolCreateWithoutRolEndpointInput, RolUncheckedCreateWithoutRolEndpointInput>
    connectOrCreate?: RolCreateOrConnectWithoutRolEndpointInput
    upsert?: RolUpsertWithoutRolEndpointInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutRolEndpointInput, RolUpdateWithoutRolEndpointInput>, RolUncheckedUpdateWithoutRolEndpointInput>
  }

  export type RolCreateNestedOneWithoutRolUsuarioInput = {
    create?: XOR<RolCreateWithoutRolUsuarioInput, RolUncheckedCreateWithoutRolUsuarioInput>
    connectOrCreate?: RolCreateOrConnectWithoutRolUsuarioInput
    connect?: RolWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutRolUsuarioInput = {
    create?: XOR<UsuarioCreateWithoutRolUsuarioInput, UsuarioUncheckedCreateWithoutRolUsuarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolUsuarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RolUpdateOneRequiredWithoutRolUsuarioNestedInput = {
    create?: XOR<RolCreateWithoutRolUsuarioInput, RolUncheckedCreateWithoutRolUsuarioInput>
    connectOrCreate?: RolCreateOrConnectWithoutRolUsuarioInput
    upsert?: RolUpsertWithoutRolUsuarioInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutRolUsuarioInput, RolUpdateWithoutRolUsuarioInput>, RolUncheckedUpdateWithoutRolUsuarioInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRolUsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutRolUsuarioInput, UsuarioUncheckedCreateWithoutRolUsuarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolUsuarioInput
    upsert?: UsuarioUpsertWithoutRolUsuarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRolUsuarioInput, UsuarioUpdateWithoutRolUsuarioInput>, UsuarioUncheckedUpdateWithoutRolUsuarioInput>
  }

  export type CriterioCreateNestedOneWithoutRubricaInput = {
    create?: XOR<CriterioCreateWithoutRubricaInput, CriterioUncheckedCreateWithoutRubricaInput>
    connectOrCreate?: CriterioCreateOrConnectWithoutRubricaInput
    connect?: CriterioWhereUniqueInput
  }

  export type EvaluacionCreateNestedOneWithoutRubricaInput = {
    create?: XOR<EvaluacionCreateWithoutRubricaInput, EvaluacionUncheckedCreateWithoutRubricaInput>
    connectOrCreate?: EvaluacionCreateOrConnectWithoutRubricaInput
    connect?: EvaluacionWhereUniqueInput
  }

  export type CriterioUpdateOneRequiredWithoutRubricaNestedInput = {
    create?: XOR<CriterioCreateWithoutRubricaInput, CriterioUncheckedCreateWithoutRubricaInput>
    connectOrCreate?: CriterioCreateOrConnectWithoutRubricaInput
    upsert?: CriterioUpsertWithoutRubricaInput
    connect?: CriterioWhereUniqueInput
    update?: XOR<XOR<CriterioUpdateToOneWithWhereWithoutRubricaInput, CriterioUpdateWithoutRubricaInput>, CriterioUncheckedUpdateWithoutRubricaInput>
  }

  export type EvaluacionUpdateOneRequiredWithoutRubricaNestedInput = {
    create?: XOR<EvaluacionCreateWithoutRubricaInput, EvaluacionUncheckedCreateWithoutRubricaInput>
    connectOrCreate?: EvaluacionCreateOrConnectWithoutRubricaInput
    upsert?: EvaluacionUpsertWithoutRubricaInput
    connect?: EvaluacionWhereUniqueInput
    update?: XOR<XOR<EvaluacionUpdateToOneWithWhereWithoutRubricaInput, EvaluacionUpdateWithoutRubricaInput>, EvaluacionUncheckedUpdateWithoutRubricaInput>
  }

  export type EstudianteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    connect?: EstudianteWhereUniqueInput
  }

  export type JuradoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<JuradoCreateWithoutUsuarioInput, JuradoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutUsuarioInput
    connect?: JuradoWhereUniqueInput
  }

  export type NRCCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NRCCreateWithoutUsuarioInput, NRCUncheckedCreateWithoutUsuarioInput> | NRCCreateWithoutUsuarioInput[] | NRCUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutUsuarioInput | NRCCreateOrConnectWithoutUsuarioInput[]
    createMany?: NRCCreateManyUsuarioInputEnvelope
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
  }

  export type RolUsuarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RolUsuarioCreateWithoutUsuarioInput, RolUsuarioUncheckedCreateWithoutUsuarioInput> | RolUsuarioCreateWithoutUsuarioInput[] | RolUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutUsuarioInput | RolUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: RolUsuarioCreateManyUsuarioInputEnvelope
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
  }

  export type EstudianteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    connect?: EstudianteWhereUniqueInput
  }

  export type JuradoUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<JuradoCreateWithoutUsuarioInput, JuradoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutUsuarioInput
    connect?: JuradoWhereUniqueInput
  }

  export type NRCUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NRCCreateWithoutUsuarioInput, NRCUncheckedCreateWithoutUsuarioInput> | NRCCreateWithoutUsuarioInput[] | NRCUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutUsuarioInput | NRCCreateOrConnectWithoutUsuarioInput[]
    createMany?: NRCCreateManyUsuarioInputEnvelope
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
  }

  export type RolUsuarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RolUsuarioCreateWithoutUsuarioInput, RolUsuarioUncheckedCreateWithoutUsuarioInput> | RolUsuarioCreateWithoutUsuarioInput[] | RolUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutUsuarioInput | RolUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: RolUsuarioCreateManyUsuarioInputEnvelope
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
  }

  export type EstudianteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    upsert?: EstudianteUpsertWithoutUsuarioInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutUsuarioInput, EstudianteUpdateWithoutUsuarioInput>, EstudianteUncheckedUpdateWithoutUsuarioInput>
  }

  export type JuradoUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<JuradoCreateWithoutUsuarioInput, JuradoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutUsuarioInput
    upsert?: JuradoUpsertWithoutUsuarioInput
    disconnect?: JuradoWhereInput | boolean
    delete?: JuradoWhereInput | boolean
    connect?: JuradoWhereUniqueInput
    update?: XOR<XOR<JuradoUpdateToOneWithWhereWithoutUsuarioInput, JuradoUpdateWithoutUsuarioInput>, JuradoUncheckedUpdateWithoutUsuarioInput>
  }

  export type NRCUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NRCCreateWithoutUsuarioInput, NRCUncheckedCreateWithoutUsuarioInput> | NRCCreateWithoutUsuarioInput[] | NRCUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutUsuarioInput | NRCCreateOrConnectWithoutUsuarioInput[]
    upsert?: NRCUpsertWithWhereUniqueWithoutUsuarioInput | NRCUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NRCCreateManyUsuarioInputEnvelope
    set?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    disconnect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    delete?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    update?: NRCUpdateWithWhereUniqueWithoutUsuarioInput | NRCUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NRCUpdateManyWithWhereWithoutUsuarioInput | NRCUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NRCScalarWhereInput | NRCScalarWhereInput[]
  }

  export type RolUsuarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RolUsuarioCreateWithoutUsuarioInput, RolUsuarioUncheckedCreateWithoutUsuarioInput> | RolUsuarioCreateWithoutUsuarioInput[] | RolUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutUsuarioInput | RolUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: RolUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | RolUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RolUsuarioCreateManyUsuarioInputEnvelope
    set?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    disconnect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    delete?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    update?: RolUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | RolUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RolUsuarioUpdateManyWithWhereWithoutUsuarioInput | RolUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RolUsuarioScalarWhereInput | RolUsuarioScalarWhereInput[]
  }

  export type EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    upsert?: EstudianteUpsertWithoutUsuarioInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutUsuarioInput, EstudianteUpdateWithoutUsuarioInput>, EstudianteUncheckedUpdateWithoutUsuarioInput>
  }

  export type JuradoUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<JuradoCreateWithoutUsuarioInput, JuradoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutUsuarioInput
    upsert?: JuradoUpsertWithoutUsuarioInput
    disconnect?: JuradoWhereInput | boolean
    delete?: JuradoWhereInput | boolean
    connect?: JuradoWhereUniqueInput
    update?: XOR<XOR<JuradoUpdateToOneWithWhereWithoutUsuarioInput, JuradoUpdateWithoutUsuarioInput>, JuradoUncheckedUpdateWithoutUsuarioInput>
  }

  export type NRCUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NRCCreateWithoutUsuarioInput, NRCUncheckedCreateWithoutUsuarioInput> | NRCCreateWithoutUsuarioInput[] | NRCUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NRCCreateOrConnectWithoutUsuarioInput | NRCCreateOrConnectWithoutUsuarioInput[]
    upsert?: NRCUpsertWithWhereUniqueWithoutUsuarioInput | NRCUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NRCCreateManyUsuarioInputEnvelope
    set?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    disconnect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    delete?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    connect?: NRCWhereUniqueInput | NRCWhereUniqueInput[]
    update?: NRCUpdateWithWhereUniqueWithoutUsuarioInput | NRCUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NRCUpdateManyWithWhereWithoutUsuarioInput | NRCUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NRCScalarWhereInput | NRCScalarWhereInput[]
  }

  export type RolUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RolUsuarioCreateWithoutUsuarioInput, RolUsuarioUncheckedCreateWithoutUsuarioInput> | RolUsuarioCreateWithoutUsuarioInput[] | RolUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RolUsuarioCreateOrConnectWithoutUsuarioInput | RolUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: RolUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | RolUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RolUsuarioCreateManyUsuarioInputEnvelope
    set?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    disconnect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    delete?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    connect?: RolUsuarioWhereUniqueInput | RolUsuarioWhereUniqueInput[]
    update?: RolUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | RolUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RolUsuarioUpdateManyWithWhereWithoutUsuarioInput | RolUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RolUsuarioScalarWhereInput | RolUsuarioScalarWhereInput[]
  }

  export type EvaluacionCreateNestedManyWithoutVideojuegoInput = {
    create?: XOR<EvaluacionCreateWithoutVideojuegoInput, EvaluacionUncheckedCreateWithoutVideojuegoInput> | EvaluacionCreateWithoutVideojuegoInput[] | EvaluacionUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutVideojuegoInput | EvaluacionCreateOrConnectWithoutVideojuegoInput[]
    createMany?: EvaluacionCreateManyVideojuegoInputEnvelope
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
  }

  export type EquipoCreateNestedOneWithoutVideojuegoInput = {
    create?: XOR<EquipoCreateWithoutVideojuegoInput, EquipoUncheckedCreateWithoutVideojuegoInput>
    connectOrCreate?: EquipoCreateOrConnectWithoutVideojuegoInput
    connect?: EquipoWhereUniqueInput
  }

  export type VideojuegoAsignadoCreateNestedManyWithoutVideojuegoInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput> | VideojuegoAsignadoCreateWithoutVideojuegoInput[] | VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput | VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput[]
    createMany?: VideojuegoAsignadoCreateManyVideojuegoInputEnvelope
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
  }

  export type EvaluacionUncheckedCreateNestedManyWithoutVideojuegoInput = {
    create?: XOR<EvaluacionCreateWithoutVideojuegoInput, EvaluacionUncheckedCreateWithoutVideojuegoInput> | EvaluacionCreateWithoutVideojuegoInput[] | EvaluacionUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutVideojuegoInput | EvaluacionCreateOrConnectWithoutVideojuegoInput[]
    createMany?: EvaluacionCreateManyVideojuegoInputEnvelope
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
  }

  export type VideojuegoAsignadoUncheckedCreateNestedManyWithoutVideojuegoInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput> | VideojuegoAsignadoCreateWithoutVideojuegoInput[] | VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput | VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput[]
    createMany?: VideojuegoAsignadoCreateManyVideojuegoInputEnvelope
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
  }

  export type EvaluacionUpdateManyWithoutVideojuegoNestedInput = {
    create?: XOR<EvaluacionCreateWithoutVideojuegoInput, EvaluacionUncheckedCreateWithoutVideojuegoInput> | EvaluacionCreateWithoutVideojuegoInput[] | EvaluacionUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutVideojuegoInput | EvaluacionCreateOrConnectWithoutVideojuegoInput[]
    upsert?: EvaluacionUpsertWithWhereUniqueWithoutVideojuegoInput | EvaluacionUpsertWithWhereUniqueWithoutVideojuegoInput[]
    createMany?: EvaluacionCreateManyVideojuegoInputEnvelope
    set?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    disconnect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    delete?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    update?: EvaluacionUpdateWithWhereUniqueWithoutVideojuegoInput | EvaluacionUpdateWithWhereUniqueWithoutVideojuegoInput[]
    updateMany?: EvaluacionUpdateManyWithWhereWithoutVideojuegoInput | EvaluacionUpdateManyWithWhereWithoutVideojuegoInput[]
    deleteMany?: EvaluacionScalarWhereInput | EvaluacionScalarWhereInput[]
  }

  export type EquipoUpdateOneRequiredWithoutVideojuegoNestedInput = {
    create?: XOR<EquipoCreateWithoutVideojuegoInput, EquipoUncheckedCreateWithoutVideojuegoInput>
    connectOrCreate?: EquipoCreateOrConnectWithoutVideojuegoInput
    upsert?: EquipoUpsertWithoutVideojuegoInput
    connect?: EquipoWhereUniqueInput
    update?: XOR<XOR<EquipoUpdateToOneWithWhereWithoutVideojuegoInput, EquipoUpdateWithoutVideojuegoInput>, EquipoUncheckedUpdateWithoutVideojuegoInput>
  }

  export type VideojuegoAsignadoUpdateManyWithoutVideojuegoNestedInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput> | VideojuegoAsignadoCreateWithoutVideojuegoInput[] | VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput | VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput[]
    upsert?: VideojuegoAsignadoUpsertWithWhereUniqueWithoutVideojuegoInput | VideojuegoAsignadoUpsertWithWhereUniqueWithoutVideojuegoInput[]
    createMany?: VideojuegoAsignadoCreateManyVideojuegoInputEnvelope
    set?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    disconnect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    delete?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    update?: VideojuegoAsignadoUpdateWithWhereUniqueWithoutVideojuegoInput | VideojuegoAsignadoUpdateWithWhereUniqueWithoutVideojuegoInput[]
    updateMany?: VideojuegoAsignadoUpdateManyWithWhereWithoutVideojuegoInput | VideojuegoAsignadoUpdateManyWithWhereWithoutVideojuegoInput[]
    deleteMany?: VideojuegoAsignadoScalarWhereInput | VideojuegoAsignadoScalarWhereInput[]
  }

  export type EvaluacionUncheckedUpdateManyWithoutVideojuegoNestedInput = {
    create?: XOR<EvaluacionCreateWithoutVideojuegoInput, EvaluacionUncheckedCreateWithoutVideojuegoInput> | EvaluacionCreateWithoutVideojuegoInput[] | EvaluacionUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: EvaluacionCreateOrConnectWithoutVideojuegoInput | EvaluacionCreateOrConnectWithoutVideojuegoInput[]
    upsert?: EvaluacionUpsertWithWhereUniqueWithoutVideojuegoInput | EvaluacionUpsertWithWhereUniqueWithoutVideojuegoInput[]
    createMany?: EvaluacionCreateManyVideojuegoInputEnvelope
    set?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    disconnect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    delete?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    connect?: EvaluacionWhereUniqueInput | EvaluacionWhereUniqueInput[]
    update?: EvaluacionUpdateWithWhereUniqueWithoutVideojuegoInput | EvaluacionUpdateWithWhereUniqueWithoutVideojuegoInput[]
    updateMany?: EvaluacionUpdateManyWithWhereWithoutVideojuegoInput | EvaluacionUpdateManyWithWhereWithoutVideojuegoInput[]
    deleteMany?: EvaluacionScalarWhereInput | EvaluacionScalarWhereInput[]
  }

  export type VideojuegoAsignadoUncheckedUpdateManyWithoutVideojuegoNestedInput = {
    create?: XOR<VideojuegoAsignadoCreateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput> | VideojuegoAsignadoCreateWithoutVideojuegoInput[] | VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput[]
    connectOrCreate?: VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput | VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput[]
    upsert?: VideojuegoAsignadoUpsertWithWhereUniqueWithoutVideojuegoInput | VideojuegoAsignadoUpsertWithWhereUniqueWithoutVideojuegoInput[]
    createMany?: VideojuegoAsignadoCreateManyVideojuegoInputEnvelope
    set?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    disconnect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    delete?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    connect?: VideojuegoAsignadoWhereUniqueInput | VideojuegoAsignadoWhereUniqueInput[]
    update?: VideojuegoAsignadoUpdateWithWhereUniqueWithoutVideojuegoInput | VideojuegoAsignadoUpdateWithWhereUniqueWithoutVideojuegoInput[]
    updateMany?: VideojuegoAsignadoUpdateManyWithWhereWithoutVideojuegoInput | VideojuegoAsignadoUpdateManyWithWhereWithoutVideojuegoInput[]
    deleteMany?: VideojuegoAsignadoScalarWhereInput | VideojuegoAsignadoScalarWhereInput[]
  }

  export type JuradoCreateNestedOneWithoutVideojuegoAsignadoInput = {
    create?: XOR<JuradoCreateWithoutVideojuegoAsignadoInput, JuradoUncheckedCreateWithoutVideojuegoAsignadoInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutVideojuegoAsignadoInput
    connect?: JuradoWhereUniqueInput
  }

  export type VideojuegoCreateNestedOneWithoutVideojuegoAsignadoInput = {
    create?: XOR<VideojuegoCreateWithoutVideojuegoAsignadoInput, VideojuegoUncheckedCreateWithoutVideojuegoAsignadoInput>
    connectOrCreate?: VideojuegoCreateOrConnectWithoutVideojuegoAsignadoInput
    connect?: VideojuegoWhereUniqueInput
  }

  export type JuradoUpdateOneRequiredWithoutVideojuegoAsignadoNestedInput = {
    create?: XOR<JuradoCreateWithoutVideojuegoAsignadoInput, JuradoUncheckedCreateWithoutVideojuegoAsignadoInput>
    connectOrCreate?: JuradoCreateOrConnectWithoutVideojuegoAsignadoInput
    upsert?: JuradoUpsertWithoutVideojuegoAsignadoInput
    connect?: JuradoWhereUniqueInput
    update?: XOR<XOR<JuradoUpdateToOneWithWhereWithoutVideojuegoAsignadoInput, JuradoUpdateWithoutVideojuegoAsignadoInput>, JuradoUncheckedUpdateWithoutVideojuegoAsignadoInput>
  }

  export type VideojuegoUpdateOneRequiredWithoutVideojuegoAsignadoNestedInput = {
    create?: XOR<VideojuegoCreateWithoutVideojuegoAsignadoInput, VideojuegoUncheckedCreateWithoutVideojuegoAsignadoInput>
    connectOrCreate?: VideojuegoCreateOrConnectWithoutVideojuegoAsignadoInput
    upsert?: VideojuegoUpsertWithoutVideojuegoAsignadoInput
    connect?: VideojuegoWhereUniqueInput
    update?: XOR<XOR<VideojuegoUpdateToOneWithWhereWithoutVideojuegoAsignadoInput, VideojuegoUpdateWithoutVideojuegoAsignadoInput>, VideojuegoUncheckedUpdateWithoutVideojuegoAsignadoInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTipoFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo | EnumTipoFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoFilter<$PrismaModel> | $Enums.Tipo
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo | EnumTipoFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo[] | ListEnumTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoWithAggregatesFilter<$PrismaModel> | $Enums.Tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoFilter<$PrismaModel>
    _max?: NestedEnumTipoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type NestedEnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Estado[] | ListEnumEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoJuradoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoJurado | EnumEstadoJuradoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoJuradoFilter<$PrismaModel> | $Enums.EstadoJurado
  }

  export type NestedEnumEstadoJuradoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoJurado | EnumEstadoJuradoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoJurado[] | ListEnumEstadoJuradoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoJuradoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoJurado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoJuradoFilter<$PrismaModel>
    _max?: NestedEnumEstadoJuradoFilter<$PrismaModel>
  }

  export type RubricaCreateWithoutCriterioInput = {
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
    Evaluacion: EvaluacionCreateNestedOneWithoutRubricaInput
  }

  export type RubricaUncheckedCreateWithoutCriterioInput = {
    id_evaluacion: number
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RubricaCreateOrConnectWithoutCriterioInput = {
    where: RubricaWhereUniqueInput
    create: XOR<RubricaCreateWithoutCriterioInput, RubricaUncheckedCreateWithoutCriterioInput>
  }

  export type RubricaCreateManyCriterioInputEnvelope = {
    data: RubricaCreateManyCriterioInput | RubricaCreateManyCriterioInput[]
    skipDuplicates?: boolean
  }

  export type RubricaUpsertWithWhereUniqueWithoutCriterioInput = {
    where: RubricaWhereUniqueInput
    update: XOR<RubricaUpdateWithoutCriterioInput, RubricaUncheckedUpdateWithoutCriterioInput>
    create: XOR<RubricaCreateWithoutCriterioInput, RubricaUncheckedCreateWithoutCriterioInput>
  }

  export type RubricaUpdateWithWhereUniqueWithoutCriterioInput = {
    where: RubricaWhereUniqueInput
    data: XOR<RubricaUpdateWithoutCriterioInput, RubricaUncheckedUpdateWithoutCriterioInput>
  }

  export type RubricaUpdateManyWithWhereWithoutCriterioInput = {
    where: RubricaScalarWhereInput
    data: XOR<RubricaUpdateManyMutationInput, RubricaUncheckedUpdateManyWithoutCriterioInput>
  }

  export type RubricaScalarWhereInput = {
    AND?: RubricaScalarWhereInput | RubricaScalarWhereInput[]
    OR?: RubricaScalarWhereInput[]
    NOT?: RubricaScalarWhereInput | RubricaScalarWhereInput[]
    id_evaluacion?: IntFilter<"Rubrica"> | number
    id_criterio?: IntFilter<"Rubrica"> | number
    valoracion?: IntFilter<"Rubrica"> | number
    create_at?: DateTimeFilter<"Rubrica"> | Date | string
    deleted?: BoolFilter<"Rubrica"> | boolean
  }

  export type RolEndpointCreateWithoutEndpointInput = {
    create_at?: Date | string
    deleted?: boolean
    Rol: RolCreateNestedOneWithoutRolEndpointInput
  }

  export type RolEndpointUncheckedCreateWithoutEndpointInput = {
    id_rol: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolEndpointCreateOrConnectWithoutEndpointInput = {
    where: RolEndpointWhereUniqueInput
    create: XOR<RolEndpointCreateWithoutEndpointInput, RolEndpointUncheckedCreateWithoutEndpointInput>
  }

  export type RolEndpointCreateManyEndpointInputEnvelope = {
    data: RolEndpointCreateManyEndpointInput | RolEndpointCreateManyEndpointInput[]
    skipDuplicates?: boolean
  }

  export type RolEndpointUpsertWithWhereUniqueWithoutEndpointInput = {
    where: RolEndpointWhereUniqueInput
    update: XOR<RolEndpointUpdateWithoutEndpointInput, RolEndpointUncheckedUpdateWithoutEndpointInput>
    create: XOR<RolEndpointCreateWithoutEndpointInput, RolEndpointUncheckedCreateWithoutEndpointInput>
  }

  export type RolEndpointUpdateWithWhereUniqueWithoutEndpointInput = {
    where: RolEndpointWhereUniqueInput
    data: XOR<RolEndpointUpdateWithoutEndpointInput, RolEndpointUncheckedUpdateWithoutEndpointInput>
  }

  export type RolEndpointUpdateManyWithWhereWithoutEndpointInput = {
    where: RolEndpointScalarWhereInput
    data: XOR<RolEndpointUpdateManyMutationInput, RolEndpointUncheckedUpdateManyWithoutEndpointInput>
  }

  export type RolEndpointScalarWhereInput = {
    AND?: RolEndpointScalarWhereInput | RolEndpointScalarWhereInput[]
    OR?: RolEndpointScalarWhereInput[]
    NOT?: RolEndpointScalarWhereInput | RolEndpointScalarWhereInput[]
    id_rol?: IntFilter<"RolEndpoint"> | number
    id_endpoint?: IntFilter<"RolEndpoint"> | number
    create_at?: DateTimeFilter<"RolEndpoint"> | Date | string
    deleted?: BoolFilter<"RolEndpoint"> | boolean
  }

  export type EstudianteCreateWithoutEquipoInput = {
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    EstudianteNRC?: EstudianteNRCCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutEquipoInput = {
    id?: number
    id_user: number
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutEquipoInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutEquipoInput, EstudianteUncheckedCreateWithoutEquipoInput>
  }

  export type EstudianteCreateManyEquipoInputEnvelope = {
    data: EstudianteCreateManyEquipoInput | EstudianteCreateManyEquipoInput[]
    skipDuplicates?: boolean
  }

  export type VideojuegoCreateWithoutEquipoInput = {
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionCreateNestedManyWithoutVideojuegoInput
    VideojuegoAsignado?: VideojuegoAsignadoCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoUncheckedCreateWithoutEquipoInput = {
    id?: number
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionUncheckedCreateNestedManyWithoutVideojuegoInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoCreateOrConnectWithoutEquipoInput = {
    where: VideojuegoWhereUniqueInput
    create: XOR<VideojuegoCreateWithoutEquipoInput, VideojuegoUncheckedCreateWithoutEquipoInput>
  }

  export type VideojuegoCreateManyEquipoInputEnvelope = {
    data: VideojuegoCreateManyEquipoInput | VideojuegoCreateManyEquipoInput[]
    skipDuplicates?: boolean
  }

  export type EstudianteUpsertWithWhereUniqueWithoutEquipoInput = {
    where: EstudianteWhereUniqueInput
    update: XOR<EstudianteUpdateWithoutEquipoInput, EstudianteUncheckedUpdateWithoutEquipoInput>
    create: XOR<EstudianteCreateWithoutEquipoInput, EstudianteUncheckedCreateWithoutEquipoInput>
  }

  export type EstudianteUpdateWithWhereUniqueWithoutEquipoInput = {
    where: EstudianteWhereUniqueInput
    data: XOR<EstudianteUpdateWithoutEquipoInput, EstudianteUncheckedUpdateWithoutEquipoInput>
  }

  export type EstudianteUpdateManyWithWhereWithoutEquipoInput = {
    where: EstudianteScalarWhereInput
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyWithoutEquipoInput>
  }

  export type EstudianteScalarWhereInput = {
    AND?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
    OR?: EstudianteScalarWhereInput[]
    NOT?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
    id?: IntFilter<"Estudiante"> | number
    equipo_id?: IntFilter<"Estudiante"> | number
    id_user?: IntFilter<"Estudiante"> | number
    github?: StringFilter<"Estudiante"> | string
    confirmado?: BoolFilter<"Estudiante"> | boolean
    create_at?: DateTimeFilter<"Estudiante"> | Date | string
    update_at?: DateTimeFilter<"Estudiante"> | Date | string
    deleted?: BoolFilter<"Estudiante"> | boolean
  }

  export type VideojuegoUpsertWithWhereUniqueWithoutEquipoInput = {
    where: VideojuegoWhereUniqueInput
    update: XOR<VideojuegoUpdateWithoutEquipoInput, VideojuegoUncheckedUpdateWithoutEquipoInput>
    create: XOR<VideojuegoCreateWithoutEquipoInput, VideojuegoUncheckedCreateWithoutEquipoInput>
  }

  export type VideojuegoUpdateWithWhereUniqueWithoutEquipoInput = {
    where: VideojuegoWhereUniqueInput
    data: XOR<VideojuegoUpdateWithoutEquipoInput, VideojuegoUncheckedUpdateWithoutEquipoInput>
  }

  export type VideojuegoUpdateManyWithWhereWithoutEquipoInput = {
    where: VideojuegoScalarWhereInput
    data: XOR<VideojuegoUpdateManyMutationInput, VideojuegoUncheckedUpdateManyWithoutEquipoInput>
  }

  export type VideojuegoScalarWhereInput = {
    AND?: VideojuegoScalarWhereInput | VideojuegoScalarWhereInput[]
    OR?: VideojuegoScalarWhereInput[]
    NOT?: VideojuegoScalarWhereInput | VideojuegoScalarWhereInput[]
    id?: IntFilter<"Videojuego"> | number
    equipo_id?: IntFilter<"Videojuego"> | number
    nombre_videojuego?: StringFilter<"Videojuego"> | string
    descripcion?: StringFilter<"Videojuego"> | string
    create_at?: DateTimeFilter<"Videojuego"> | Date | string
    update_at?: DateTimeFilter<"Videojuego"> | Date | string
    deleted?: BoolFilter<"Videojuego"> | boolean
  }

  export type EquipoCreateWithoutEstudianteInput = {
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Videojuego?: VideojuegoCreateNestedManyWithoutEquipoInput
  }

  export type EquipoUncheckedCreateWithoutEstudianteInput = {
    id?: number
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Videojuego?: VideojuegoUncheckedCreateNestedManyWithoutEquipoInput
  }

  export type EquipoCreateOrConnectWithoutEstudianteInput = {
    where: EquipoWhereUniqueInput
    create: XOR<EquipoCreateWithoutEstudianteInput, EquipoUncheckedCreateWithoutEstudianteInput>
  }

  export type UsuarioCreateWithoutEstudianteInput = {
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Jurado?: JuradoCreateNestedOneWithoutUsuarioInput
    NRC?: NRCCreateNestedManyWithoutUsuarioInput
    RolUsuario?: RolUsuarioCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEstudianteInput = {
    id?: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Jurado?: JuradoUncheckedCreateNestedOneWithoutUsuarioInput
    NRC?: NRCUncheckedCreateNestedManyWithoutUsuarioInput
    RolUsuario?: RolUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEstudianteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
  }

  export type EstudianteNRCCreateWithoutEstudianteInput = {
    create_at?: Date | string
    deleted?: boolean
    NRC: NRCCreateNestedOneWithoutEstudianteNRCInput
  }

  export type EstudianteNRCUncheckedCreateWithoutEstudianteInput = {
    id_nrc: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteNRCCreateOrConnectWithoutEstudianteInput = {
    where: EstudianteNRCWhereUniqueInput
    create: XOR<EstudianteNRCCreateWithoutEstudianteInput, EstudianteNRCUncheckedCreateWithoutEstudianteInput>
  }

  export type EstudianteNRCCreateManyEstudianteInputEnvelope = {
    data: EstudianteNRCCreateManyEstudianteInput | EstudianteNRCCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type EquipoUpsertWithoutEstudianteInput = {
    update: XOR<EquipoUpdateWithoutEstudianteInput, EquipoUncheckedUpdateWithoutEstudianteInput>
    create: XOR<EquipoCreateWithoutEstudianteInput, EquipoUncheckedCreateWithoutEstudianteInput>
    where?: EquipoWhereInput
  }

  export type EquipoUpdateToOneWithWhereWithoutEstudianteInput = {
    where?: EquipoWhereInput
    data: XOR<EquipoUpdateWithoutEstudianteInput, EquipoUncheckedUpdateWithoutEstudianteInput>
  }

  export type EquipoUpdateWithoutEstudianteInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Videojuego?: VideojuegoUpdateManyWithoutEquipoNestedInput
  }

  export type EquipoUncheckedUpdateWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Videojuego?: VideojuegoUncheckedUpdateManyWithoutEquipoNestedInput
  }

  export type UsuarioUpsertWithoutEstudianteInput = {
    update: XOR<UsuarioUpdateWithoutEstudianteInput, UsuarioUncheckedUpdateWithoutEstudianteInput>
    create: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEstudianteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEstudianteInput, UsuarioUncheckedUpdateWithoutEstudianteInput>
  }

  export type UsuarioUpdateWithoutEstudianteInput = {
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUpdateManyWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUncheckedUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUncheckedUpdateManyWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type EstudianteNRCUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: EstudianteNRCWhereUniqueInput
    update: XOR<EstudianteNRCUpdateWithoutEstudianteInput, EstudianteNRCUncheckedUpdateWithoutEstudianteInput>
    create: XOR<EstudianteNRCCreateWithoutEstudianteInput, EstudianteNRCUncheckedCreateWithoutEstudianteInput>
  }

  export type EstudianteNRCUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: EstudianteNRCWhereUniqueInput
    data: XOR<EstudianteNRCUpdateWithoutEstudianteInput, EstudianteNRCUncheckedUpdateWithoutEstudianteInput>
  }

  export type EstudianteNRCUpdateManyWithWhereWithoutEstudianteInput = {
    where: EstudianteNRCScalarWhereInput
    data: XOR<EstudianteNRCUpdateManyMutationInput, EstudianteNRCUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type EstudianteNRCScalarWhereInput = {
    AND?: EstudianteNRCScalarWhereInput | EstudianteNRCScalarWhereInput[]
    OR?: EstudianteNRCScalarWhereInput[]
    NOT?: EstudianteNRCScalarWhereInput | EstudianteNRCScalarWhereInput[]
    id_nrc?: IntFilter<"EstudianteNRC"> | number
    id_estudiante?: IntFilter<"EstudianteNRC"> | number
    create_at?: DateTimeFilter<"EstudianteNRC"> | Date | string
    deleted?: BoolFilter<"EstudianteNRC"> | boolean
  }

  export type EstudianteCreateWithoutEstudianteNRCInput = {
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Equipo: EquipoCreateNestedOneWithoutEstudianteInput
    Usuario: UsuarioCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutEstudianteNRCInput = {
    id?: number
    equipo_id: number
    id_user: number
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteCreateOrConnectWithoutEstudianteNRCInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutEstudianteNRCInput, EstudianteUncheckedCreateWithoutEstudianteNRCInput>
  }

  export type NRCCreateWithoutEstudianteNRCInput = {
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Materia: MateriaCreateNestedOneWithoutNRCInput
    Usuario: UsuarioCreateNestedOneWithoutNRCInput
  }

  export type NRCUncheckedCreateWithoutEstudianteNRCInput = {
    codigo_nrc?: number
    materia_id: number
    profesor_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type NRCCreateOrConnectWithoutEstudianteNRCInput = {
    where: NRCWhereUniqueInput
    create: XOR<NRCCreateWithoutEstudianteNRCInput, NRCUncheckedCreateWithoutEstudianteNRCInput>
  }

  export type EstudianteUpsertWithoutEstudianteNRCInput = {
    update: XOR<EstudianteUpdateWithoutEstudianteNRCInput, EstudianteUncheckedUpdateWithoutEstudianteNRCInput>
    create: XOR<EstudianteCreateWithoutEstudianteNRCInput, EstudianteUncheckedCreateWithoutEstudianteNRCInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutEstudianteNRCInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutEstudianteNRCInput, EstudianteUncheckedUpdateWithoutEstudianteNRCInput>
  }

  export type EstudianteUpdateWithoutEstudianteNRCInput = {
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Equipo?: EquipoUpdateOneRequiredWithoutEstudianteNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutEstudianteNRCInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NRCUpsertWithoutEstudianteNRCInput = {
    update: XOR<NRCUpdateWithoutEstudianteNRCInput, NRCUncheckedUpdateWithoutEstudianteNRCInput>
    create: XOR<NRCCreateWithoutEstudianteNRCInput, NRCUncheckedCreateWithoutEstudianteNRCInput>
    where?: NRCWhereInput
  }

  export type NRCUpdateToOneWithWhereWithoutEstudianteNRCInput = {
    where?: NRCWhereInput
    data: XOR<NRCUpdateWithoutEstudianteNRCInput, NRCUncheckedUpdateWithoutEstudianteNRCInput>
  }

  export type NRCUpdateWithoutEstudianteNRCInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Materia?: MateriaUpdateOneRequiredWithoutNRCNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutNRCNestedInput
  }

  export type NRCUncheckedUpdateWithoutEstudianteNRCInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    materia_id?: IntFieldUpdateOperationsInput | number
    profesor_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JuradoCreateWithoutEvaluacionInput = {
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Usuario: UsuarioCreateNestedOneWithoutJuradoInput
    VideojuegoAsignado?: VideojuegoAsignadoCreateNestedManyWithoutJuradoInput
  }

  export type JuradoUncheckedCreateWithoutEvaluacionInput = {
    id?: number
    id_user: number
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedCreateNestedManyWithoutJuradoInput
  }

  export type JuradoCreateOrConnectWithoutEvaluacionInput = {
    where: JuradoWhereUniqueInput
    create: XOR<JuradoCreateWithoutEvaluacionInput, JuradoUncheckedCreateWithoutEvaluacionInput>
  }

  export type VideojuegoCreateWithoutEvaluacionInput = {
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Equipo: EquipoCreateNestedOneWithoutVideojuegoInput
    VideojuegoAsignado?: VideojuegoAsignadoCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoUncheckedCreateWithoutEvaluacionInput = {
    id?: number
    equipo_id: number
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoCreateOrConnectWithoutEvaluacionInput = {
    where: VideojuegoWhereUniqueInput
    create: XOR<VideojuegoCreateWithoutEvaluacionInput, VideojuegoUncheckedCreateWithoutEvaluacionInput>
  }

  export type RubricaCreateWithoutEvaluacionInput = {
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
    Criterio: CriterioCreateNestedOneWithoutRubricaInput
  }

  export type RubricaUncheckedCreateWithoutEvaluacionInput = {
    id_criterio: number
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RubricaCreateOrConnectWithoutEvaluacionInput = {
    where: RubricaWhereUniqueInput
    create: XOR<RubricaCreateWithoutEvaluacionInput, RubricaUncheckedCreateWithoutEvaluacionInput>
  }

  export type RubricaCreateManyEvaluacionInputEnvelope = {
    data: RubricaCreateManyEvaluacionInput | RubricaCreateManyEvaluacionInput[]
    skipDuplicates?: boolean
  }

  export type JuradoUpsertWithoutEvaluacionInput = {
    update: XOR<JuradoUpdateWithoutEvaluacionInput, JuradoUncheckedUpdateWithoutEvaluacionInput>
    create: XOR<JuradoCreateWithoutEvaluacionInput, JuradoUncheckedCreateWithoutEvaluacionInput>
    where?: JuradoWhereInput
  }

  export type JuradoUpdateToOneWithWhereWithoutEvaluacionInput = {
    where?: JuradoWhereInput
    data: XOR<JuradoUpdateWithoutEvaluacionInput, JuradoUncheckedUpdateWithoutEvaluacionInput>
  }

  export type JuradoUpdateWithoutEvaluacionInput = {
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneRequiredWithoutJuradoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUpdateManyWithoutJuradoNestedInput
  }

  export type JuradoUncheckedUpdateWithoutEvaluacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedUpdateManyWithoutJuradoNestedInput
  }

  export type VideojuegoUpsertWithoutEvaluacionInput = {
    update: XOR<VideojuegoUpdateWithoutEvaluacionInput, VideojuegoUncheckedUpdateWithoutEvaluacionInput>
    create: XOR<VideojuegoCreateWithoutEvaluacionInput, VideojuegoUncheckedCreateWithoutEvaluacionInput>
    where?: VideojuegoWhereInput
  }

  export type VideojuegoUpdateToOneWithWhereWithoutEvaluacionInput = {
    where?: VideojuegoWhereInput
    data: XOR<VideojuegoUpdateWithoutEvaluacionInput, VideojuegoUncheckedUpdateWithoutEvaluacionInput>
  }

  export type VideojuegoUpdateWithoutEvaluacionInput = {
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Equipo?: EquipoUpdateOneRequiredWithoutVideojuegoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUpdateManyWithoutVideojuegoNestedInput
  }

  export type VideojuegoUncheckedUpdateWithoutEvaluacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedUpdateManyWithoutVideojuegoNestedInput
  }

  export type RubricaUpsertWithWhereUniqueWithoutEvaluacionInput = {
    where: RubricaWhereUniqueInput
    update: XOR<RubricaUpdateWithoutEvaluacionInput, RubricaUncheckedUpdateWithoutEvaluacionInput>
    create: XOR<RubricaCreateWithoutEvaluacionInput, RubricaUncheckedCreateWithoutEvaluacionInput>
  }

  export type RubricaUpdateWithWhereUniqueWithoutEvaluacionInput = {
    where: RubricaWhereUniqueInput
    data: XOR<RubricaUpdateWithoutEvaluacionInput, RubricaUncheckedUpdateWithoutEvaluacionInput>
  }

  export type RubricaUpdateManyWithWhereWithoutEvaluacionInput = {
    where: RubricaScalarWhereInput
    data: XOR<RubricaUpdateManyMutationInput, RubricaUncheckedUpdateManyWithoutEvaluacionInput>
  }

  export type EvaluacionCreateWithoutJuradoInput = {
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Videojuego: VideojuegoCreateNestedOneWithoutEvaluacionInput
    Rubrica?: RubricaCreateNestedManyWithoutEvaluacionInput
  }

  export type EvaluacionUncheckedCreateWithoutJuradoInput = {
    id?: number
    videojuego_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Rubrica?: RubricaUncheckedCreateNestedManyWithoutEvaluacionInput
  }

  export type EvaluacionCreateOrConnectWithoutJuradoInput = {
    where: EvaluacionWhereUniqueInput
    create: XOR<EvaluacionCreateWithoutJuradoInput, EvaluacionUncheckedCreateWithoutJuradoInput>
  }

  export type EvaluacionCreateManyJuradoInputEnvelope = {
    data: EvaluacionCreateManyJuradoInput | EvaluacionCreateManyJuradoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutJuradoInput = {
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    NRC?: NRCCreateNestedManyWithoutUsuarioInput
    RolUsuario?: RolUsuarioCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutJuradoInput = {
    id?: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    NRC?: NRCUncheckedCreateNestedManyWithoutUsuarioInput
    RolUsuario?: RolUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutJuradoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutJuradoInput, UsuarioUncheckedCreateWithoutJuradoInput>
  }

  export type VideojuegoAsignadoCreateWithoutJuradoInput = {
    create_at?: Date | string
    deleted?: boolean
    Videojuego: VideojuegoCreateNestedOneWithoutVideojuegoAsignadoInput
  }

  export type VideojuegoAsignadoUncheckedCreateWithoutJuradoInput = {
    id_videojuego: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoAsignadoCreateOrConnectWithoutJuradoInput = {
    where: VideojuegoAsignadoWhereUniqueInput
    create: XOR<VideojuegoAsignadoCreateWithoutJuradoInput, VideojuegoAsignadoUncheckedCreateWithoutJuradoInput>
  }

  export type VideojuegoAsignadoCreateManyJuradoInputEnvelope = {
    data: VideojuegoAsignadoCreateManyJuradoInput | VideojuegoAsignadoCreateManyJuradoInput[]
    skipDuplicates?: boolean
  }

  export type EvaluacionUpsertWithWhereUniqueWithoutJuradoInput = {
    where: EvaluacionWhereUniqueInput
    update: XOR<EvaluacionUpdateWithoutJuradoInput, EvaluacionUncheckedUpdateWithoutJuradoInput>
    create: XOR<EvaluacionCreateWithoutJuradoInput, EvaluacionUncheckedCreateWithoutJuradoInput>
  }

  export type EvaluacionUpdateWithWhereUniqueWithoutJuradoInput = {
    where: EvaluacionWhereUniqueInput
    data: XOR<EvaluacionUpdateWithoutJuradoInput, EvaluacionUncheckedUpdateWithoutJuradoInput>
  }

  export type EvaluacionUpdateManyWithWhereWithoutJuradoInput = {
    where: EvaluacionScalarWhereInput
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyWithoutJuradoInput>
  }

  export type EvaluacionScalarWhereInput = {
    AND?: EvaluacionScalarWhereInput | EvaluacionScalarWhereInput[]
    OR?: EvaluacionScalarWhereInput[]
    NOT?: EvaluacionScalarWhereInput | EvaluacionScalarWhereInput[]
    id?: IntFilter<"Evaluacion"> | number
    jurado_id?: IntFilter<"Evaluacion"> | number
    videojuego_id?: IntFilter<"Evaluacion"> | number
    comentarios?: StringFilter<"Evaluacion"> | string
    create_at?: DateTimeFilter<"Evaluacion"> | Date | string
    update_at?: DateTimeFilter<"Evaluacion"> | Date | string
    deleted?: BoolFilter<"Evaluacion"> | boolean
  }

  export type UsuarioUpsertWithoutJuradoInput = {
    update: XOR<UsuarioUpdateWithoutJuradoInput, UsuarioUncheckedUpdateWithoutJuradoInput>
    create: XOR<UsuarioCreateWithoutJuradoInput, UsuarioUncheckedCreateWithoutJuradoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutJuradoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutJuradoInput, UsuarioUncheckedUpdateWithoutJuradoInput>
  }

  export type UsuarioUpdateWithoutJuradoInput = {
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUpdateManyWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutJuradoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUncheckedUpdateManyWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type VideojuegoAsignadoUpsertWithWhereUniqueWithoutJuradoInput = {
    where: VideojuegoAsignadoWhereUniqueInput
    update: XOR<VideojuegoAsignadoUpdateWithoutJuradoInput, VideojuegoAsignadoUncheckedUpdateWithoutJuradoInput>
    create: XOR<VideojuegoAsignadoCreateWithoutJuradoInput, VideojuegoAsignadoUncheckedCreateWithoutJuradoInput>
  }

  export type VideojuegoAsignadoUpdateWithWhereUniqueWithoutJuradoInput = {
    where: VideojuegoAsignadoWhereUniqueInput
    data: XOR<VideojuegoAsignadoUpdateWithoutJuradoInput, VideojuegoAsignadoUncheckedUpdateWithoutJuradoInput>
  }

  export type VideojuegoAsignadoUpdateManyWithWhereWithoutJuradoInput = {
    where: VideojuegoAsignadoScalarWhereInput
    data: XOR<VideojuegoAsignadoUpdateManyMutationInput, VideojuegoAsignadoUncheckedUpdateManyWithoutJuradoInput>
  }

  export type VideojuegoAsignadoScalarWhereInput = {
    AND?: VideojuegoAsignadoScalarWhereInput | VideojuegoAsignadoScalarWhereInput[]
    OR?: VideojuegoAsignadoScalarWhereInput[]
    NOT?: VideojuegoAsignadoScalarWhereInput | VideojuegoAsignadoScalarWhereInput[]
    id_videojuego?: IntFilter<"VideojuegoAsignado"> | number
    id_jurado?: IntFilter<"VideojuegoAsignado"> | number
    create_at?: DateTimeFilter<"VideojuegoAsignado"> | Date | string
    deleted?: BoolFilter<"VideojuegoAsignado"> | boolean
  }

  export type NRCCreateWithoutMateriaInput = {
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCCreateNestedManyWithoutNRCInput
    Usuario: UsuarioCreateNestedOneWithoutNRCInput
  }

  export type NRCUncheckedCreateWithoutMateriaInput = {
    codigo_nrc?: number
    profesor_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCUncheckedCreateNestedManyWithoutNRCInput
  }

  export type NRCCreateOrConnectWithoutMateriaInput = {
    where: NRCWhereUniqueInput
    create: XOR<NRCCreateWithoutMateriaInput, NRCUncheckedCreateWithoutMateriaInput>
  }

  export type NRCCreateManyMateriaInputEnvelope = {
    data: NRCCreateManyMateriaInput | NRCCreateManyMateriaInput[]
    skipDuplicates?: boolean
  }

  export type NRCUpsertWithWhereUniqueWithoutMateriaInput = {
    where: NRCWhereUniqueInput
    update: XOR<NRCUpdateWithoutMateriaInput, NRCUncheckedUpdateWithoutMateriaInput>
    create: XOR<NRCCreateWithoutMateriaInput, NRCUncheckedCreateWithoutMateriaInput>
  }

  export type NRCUpdateWithWhereUniqueWithoutMateriaInput = {
    where: NRCWhereUniqueInput
    data: XOR<NRCUpdateWithoutMateriaInput, NRCUncheckedUpdateWithoutMateriaInput>
  }

  export type NRCUpdateManyWithWhereWithoutMateriaInput = {
    where: NRCScalarWhereInput
    data: XOR<NRCUpdateManyMutationInput, NRCUncheckedUpdateManyWithoutMateriaInput>
  }

  export type NRCScalarWhereInput = {
    AND?: NRCScalarWhereInput | NRCScalarWhereInput[]
    OR?: NRCScalarWhereInput[]
    NOT?: NRCScalarWhereInput | NRCScalarWhereInput[]
    codigo_nrc?: IntFilter<"NRC"> | number
    materia_id?: IntFilter<"NRC"> | number
    profesor_id?: IntFilter<"NRC"> | number
    create_at?: DateTimeFilter<"NRC"> | Date | string
    update_at?: DateTimeFilter<"NRC"> | Date | string
    deleted?: BoolFilter<"NRC"> | boolean
  }

  export type EstudianteNRCCreateWithoutNRCInput = {
    create_at?: Date | string
    deleted?: boolean
    Estudiante: EstudianteCreateNestedOneWithoutEstudianteNRCInput
  }

  export type EstudianteNRCUncheckedCreateWithoutNRCInput = {
    id_estudiante: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteNRCCreateOrConnectWithoutNRCInput = {
    where: EstudianteNRCWhereUniqueInput
    create: XOR<EstudianteNRCCreateWithoutNRCInput, EstudianteNRCUncheckedCreateWithoutNRCInput>
  }

  export type EstudianteNRCCreateManyNRCInputEnvelope = {
    data: EstudianteNRCCreateManyNRCInput | EstudianteNRCCreateManyNRCInput[]
    skipDuplicates?: boolean
  }

  export type MateriaCreateWithoutNRCInput = {
    nombre: string
    codigo: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type MateriaUncheckedCreateWithoutNRCInput = {
    id?: number
    nombre: string
    codigo: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type MateriaCreateOrConnectWithoutNRCInput = {
    where: MateriaWhereUniqueInput
    create: XOR<MateriaCreateWithoutNRCInput, MateriaUncheckedCreateWithoutNRCInput>
  }

  export type UsuarioCreateWithoutNRCInput = {
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    Jurado?: JuradoCreateNestedOneWithoutUsuarioInput
    RolUsuario?: RolUsuarioCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutNRCInput = {
    id?: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    Jurado?: JuradoUncheckedCreateNestedOneWithoutUsuarioInput
    RolUsuario?: RolUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutNRCInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutNRCInput, UsuarioUncheckedCreateWithoutNRCInput>
  }

  export type EstudianteNRCUpsertWithWhereUniqueWithoutNRCInput = {
    where: EstudianteNRCWhereUniqueInput
    update: XOR<EstudianteNRCUpdateWithoutNRCInput, EstudianteNRCUncheckedUpdateWithoutNRCInput>
    create: XOR<EstudianteNRCCreateWithoutNRCInput, EstudianteNRCUncheckedCreateWithoutNRCInput>
  }

  export type EstudianteNRCUpdateWithWhereUniqueWithoutNRCInput = {
    where: EstudianteNRCWhereUniqueInput
    data: XOR<EstudianteNRCUpdateWithoutNRCInput, EstudianteNRCUncheckedUpdateWithoutNRCInput>
  }

  export type EstudianteNRCUpdateManyWithWhereWithoutNRCInput = {
    where: EstudianteNRCScalarWhereInput
    data: XOR<EstudianteNRCUpdateManyMutationInput, EstudianteNRCUncheckedUpdateManyWithoutNRCInput>
  }

  export type MateriaUpsertWithoutNRCInput = {
    update: XOR<MateriaUpdateWithoutNRCInput, MateriaUncheckedUpdateWithoutNRCInput>
    create: XOR<MateriaCreateWithoutNRCInput, MateriaUncheckedCreateWithoutNRCInput>
    where?: MateriaWhereInput
  }

  export type MateriaUpdateToOneWithWhereWithoutNRCInput = {
    where?: MateriaWhereInput
    data: XOR<MateriaUpdateWithoutNRCInput, MateriaUncheckedUpdateWithoutNRCInput>
  }

  export type MateriaUpdateWithoutNRCInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MateriaUncheckedUpdateWithoutNRCInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUpsertWithoutNRCInput = {
    update: XOR<UsuarioUpdateWithoutNRCInput, UsuarioUncheckedUpdateWithoutNRCInput>
    create: XOR<UsuarioCreateWithoutNRCInput, UsuarioUncheckedCreateWithoutNRCInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutNRCInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutNRCInput, UsuarioUncheckedUpdateWithoutNRCInput>
  }

  export type UsuarioUpdateWithoutNRCInput = {
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    Jurado?: JuradoUpdateOneWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutNRCInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    Jurado?: JuradoUncheckedUpdateOneWithoutUsuarioNestedInput
    RolUsuario?: RolUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RolEndpointCreateWithoutRolInput = {
    create_at?: Date | string
    deleted?: boolean
    Endpoint: EndpointCreateNestedOneWithoutRolEndpointInput
  }

  export type RolEndpointUncheckedCreateWithoutRolInput = {
    id_endpoint: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolEndpointCreateOrConnectWithoutRolInput = {
    where: RolEndpointWhereUniqueInput
    create: XOR<RolEndpointCreateWithoutRolInput, RolEndpointUncheckedCreateWithoutRolInput>
  }

  export type RolEndpointCreateManyRolInputEnvelope = {
    data: RolEndpointCreateManyRolInput | RolEndpointCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type RolUsuarioCreateWithoutRolInput = {
    create_at?: Date | string
    deleted?: boolean
    Usuario: UsuarioCreateNestedOneWithoutRolUsuarioInput
  }

  export type RolUsuarioUncheckedCreateWithoutRolInput = {
    id_usuario: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolUsuarioCreateOrConnectWithoutRolInput = {
    where: RolUsuarioWhereUniqueInput
    create: XOR<RolUsuarioCreateWithoutRolInput, RolUsuarioUncheckedCreateWithoutRolInput>
  }

  export type RolUsuarioCreateManyRolInputEnvelope = {
    data: RolUsuarioCreateManyRolInput | RolUsuarioCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type RolEndpointUpsertWithWhereUniqueWithoutRolInput = {
    where: RolEndpointWhereUniqueInput
    update: XOR<RolEndpointUpdateWithoutRolInput, RolEndpointUncheckedUpdateWithoutRolInput>
    create: XOR<RolEndpointCreateWithoutRolInput, RolEndpointUncheckedCreateWithoutRolInput>
  }

  export type RolEndpointUpdateWithWhereUniqueWithoutRolInput = {
    where: RolEndpointWhereUniqueInput
    data: XOR<RolEndpointUpdateWithoutRolInput, RolEndpointUncheckedUpdateWithoutRolInput>
  }

  export type RolEndpointUpdateManyWithWhereWithoutRolInput = {
    where: RolEndpointScalarWhereInput
    data: XOR<RolEndpointUpdateManyMutationInput, RolEndpointUncheckedUpdateManyWithoutRolInput>
  }

  export type RolUsuarioUpsertWithWhereUniqueWithoutRolInput = {
    where: RolUsuarioWhereUniqueInput
    update: XOR<RolUsuarioUpdateWithoutRolInput, RolUsuarioUncheckedUpdateWithoutRolInput>
    create: XOR<RolUsuarioCreateWithoutRolInput, RolUsuarioUncheckedCreateWithoutRolInput>
  }

  export type RolUsuarioUpdateWithWhereUniqueWithoutRolInput = {
    where: RolUsuarioWhereUniqueInput
    data: XOR<RolUsuarioUpdateWithoutRolInput, RolUsuarioUncheckedUpdateWithoutRolInput>
  }

  export type RolUsuarioUpdateManyWithWhereWithoutRolInput = {
    where: RolUsuarioScalarWhereInput
    data: XOR<RolUsuarioUpdateManyMutationInput, RolUsuarioUncheckedUpdateManyWithoutRolInput>
  }

  export type RolUsuarioScalarWhereInput = {
    AND?: RolUsuarioScalarWhereInput | RolUsuarioScalarWhereInput[]
    OR?: RolUsuarioScalarWhereInput[]
    NOT?: RolUsuarioScalarWhereInput | RolUsuarioScalarWhereInput[]
    id_usuario?: IntFilter<"RolUsuario"> | number
    id_rol?: IntFilter<"RolUsuario"> | number
    create_at?: DateTimeFilter<"RolUsuario"> | Date | string
    deleted?: BoolFilter<"RolUsuario"> | boolean
  }

  export type EndpointCreateWithoutRolEndpointInput = {
    nombre?: string | null
    metodo: $Enums.Tipo
    num_parametros: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EndpointUncheckedCreateWithoutRolEndpointInput = {
    id?: number
    nombre?: string | null
    metodo: $Enums.Tipo
    num_parametros: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EndpointCreateOrConnectWithoutRolEndpointInput = {
    where: EndpointWhereUniqueInput
    create: XOR<EndpointCreateWithoutRolEndpointInput, EndpointUncheckedCreateWithoutRolEndpointInput>
  }

  export type RolCreateWithoutRolEndpointInput = {
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolUsuario?: RolUsuarioCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutRolEndpointInput = {
    id?: number
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolUsuario?: RolUsuarioUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutRolEndpointInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutRolEndpointInput, RolUncheckedCreateWithoutRolEndpointInput>
  }

  export type EndpointUpsertWithoutRolEndpointInput = {
    update: XOR<EndpointUpdateWithoutRolEndpointInput, EndpointUncheckedUpdateWithoutRolEndpointInput>
    create: XOR<EndpointCreateWithoutRolEndpointInput, EndpointUncheckedCreateWithoutRolEndpointInput>
    where?: EndpointWhereInput
  }

  export type EndpointUpdateToOneWithWhereWithoutRolEndpointInput = {
    where?: EndpointWhereInput
    data: XOR<EndpointUpdateWithoutRolEndpointInput, EndpointUncheckedUpdateWithoutRolEndpointInput>
  }

  export type EndpointUpdateWithoutRolEndpointInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    metodo?: EnumTipoFieldUpdateOperationsInput | $Enums.Tipo
    num_parametros?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EndpointUncheckedUpdateWithoutRolEndpointInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    metodo?: EnumTipoFieldUpdateOperationsInput | $Enums.Tipo
    num_parametros?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUpsertWithoutRolEndpointInput = {
    update: XOR<RolUpdateWithoutRolEndpointInput, RolUncheckedUpdateWithoutRolEndpointInput>
    create: XOR<RolCreateWithoutRolEndpointInput, RolUncheckedCreateWithoutRolEndpointInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutRolEndpointInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutRolEndpointInput, RolUncheckedUpdateWithoutRolEndpointInput>
  }

  export type RolUpdateWithoutRolEndpointInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolUsuario?: RolUsuarioUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutRolEndpointInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolUsuario?: RolUsuarioUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateWithoutRolUsuarioInput = {
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolEndpoint?: RolEndpointCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutRolUsuarioInput = {
    id?: number
    nombre: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    RolEndpoint?: RolEndpointUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutRolUsuarioInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutRolUsuarioInput, RolUncheckedCreateWithoutRolUsuarioInput>
  }

  export type UsuarioCreateWithoutRolUsuarioInput = {
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    Jurado?: JuradoCreateNestedOneWithoutUsuarioInput
    NRC?: NRCCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRolUsuarioInput = {
    id?: number
    nombre_completo: string
    email: string
    hash_contrasena: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    Jurado?: JuradoUncheckedCreateNestedOneWithoutUsuarioInput
    NRC?: NRCUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRolUsuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRolUsuarioInput, UsuarioUncheckedCreateWithoutRolUsuarioInput>
  }

  export type RolUpsertWithoutRolUsuarioInput = {
    update: XOR<RolUpdateWithoutRolUsuarioInput, RolUncheckedUpdateWithoutRolUsuarioInput>
    create: XOR<RolCreateWithoutRolUsuarioInput, RolUncheckedCreateWithoutRolUsuarioInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutRolUsuarioInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutRolUsuarioInput, RolUncheckedUpdateWithoutRolUsuarioInput>
  }

  export type RolUpdateWithoutRolUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolEndpoint?: RolEndpointUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutRolUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    RolEndpoint?: RolEndpointUncheckedUpdateManyWithoutRolNestedInput
  }

  export type UsuarioUpsertWithoutRolUsuarioInput = {
    update: XOR<UsuarioUpdateWithoutRolUsuarioInput, UsuarioUncheckedUpdateWithoutRolUsuarioInput>
    create: XOR<UsuarioCreateWithoutRolUsuarioInput, UsuarioUncheckedCreateWithoutRolUsuarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRolUsuarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRolUsuarioInput, UsuarioUncheckedUpdateWithoutRolUsuarioInput>
  }

  export type UsuarioUpdateWithoutRolUsuarioInput = {
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    Jurado?: JuradoUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRolUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_completo?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hash_contrasena?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    Jurado?: JuradoUncheckedUpdateOneWithoutUsuarioNestedInput
    NRC?: NRCUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CriterioCreateWithoutRubricaInput = {
    nombre: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type CriterioUncheckedCreateWithoutRubricaInput = {
    id?: number
    nombre: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type CriterioCreateOrConnectWithoutRubricaInput = {
    where: CriterioWhereUniqueInput
    create: XOR<CriterioCreateWithoutRubricaInput, CriterioUncheckedCreateWithoutRubricaInput>
  }

  export type EvaluacionCreateWithoutRubricaInput = {
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Jurado: JuradoCreateNestedOneWithoutEvaluacionInput
    Videojuego: VideojuegoCreateNestedOneWithoutEvaluacionInput
  }

  export type EvaluacionUncheckedCreateWithoutRubricaInput = {
    id?: number
    jurado_id: number
    videojuego_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EvaluacionCreateOrConnectWithoutRubricaInput = {
    where: EvaluacionWhereUniqueInput
    create: XOR<EvaluacionCreateWithoutRubricaInput, EvaluacionUncheckedCreateWithoutRubricaInput>
  }

  export type CriterioUpsertWithoutRubricaInput = {
    update: XOR<CriterioUpdateWithoutRubricaInput, CriterioUncheckedUpdateWithoutRubricaInput>
    create: XOR<CriterioCreateWithoutRubricaInput, CriterioUncheckedCreateWithoutRubricaInput>
    where?: CriterioWhereInput
  }

  export type CriterioUpdateToOneWithWhereWithoutRubricaInput = {
    where?: CriterioWhereInput
    data: XOR<CriterioUpdateWithoutRubricaInput, CriterioUncheckedUpdateWithoutRubricaInput>
  }

  export type CriterioUpdateWithoutRubricaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CriterioUncheckedUpdateWithoutRubricaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EvaluacionUpsertWithoutRubricaInput = {
    update: XOR<EvaluacionUpdateWithoutRubricaInput, EvaluacionUncheckedUpdateWithoutRubricaInput>
    create: XOR<EvaluacionCreateWithoutRubricaInput, EvaluacionUncheckedCreateWithoutRubricaInput>
    where?: EvaluacionWhereInput
  }

  export type EvaluacionUpdateToOneWithWhereWithoutRubricaInput = {
    where?: EvaluacionWhereInput
    data: XOR<EvaluacionUpdateWithoutRubricaInput, EvaluacionUncheckedUpdateWithoutRubricaInput>
  }

  export type EvaluacionUpdateWithoutRubricaInput = {
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUpdateOneRequiredWithoutEvaluacionNestedInput
    Videojuego?: VideojuegoUpdateOneRequiredWithoutEvaluacionNestedInput
  }

  export type EvaluacionUncheckedUpdateWithoutRubricaInput = {
    id?: IntFieldUpdateOperationsInput | number
    jurado_id?: IntFieldUpdateOperationsInput | number
    videojuego_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteCreateWithoutUsuarioInput = {
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Equipo: EquipoCreateNestedOneWithoutEstudianteInput
    EstudianteNRC?: EstudianteNRCCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutUsuarioInput = {
    id?: number
    equipo_id: number
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutUsuarioInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
  }

  export type JuradoCreateWithoutUsuarioInput = {
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionCreateNestedManyWithoutJuradoInput
    VideojuegoAsignado?: VideojuegoAsignadoCreateNestedManyWithoutJuradoInput
  }

  export type JuradoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionUncheckedCreateNestedManyWithoutJuradoInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedCreateNestedManyWithoutJuradoInput
  }

  export type JuradoCreateOrConnectWithoutUsuarioInput = {
    where: JuradoWhereUniqueInput
    create: XOR<JuradoCreateWithoutUsuarioInput, JuradoUncheckedCreateWithoutUsuarioInput>
  }

  export type NRCCreateWithoutUsuarioInput = {
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCCreateNestedManyWithoutNRCInput
    Materia: MateriaCreateNestedOneWithoutNRCInput
  }

  export type NRCUncheckedCreateWithoutUsuarioInput = {
    codigo_nrc?: number
    materia_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    EstudianteNRC?: EstudianteNRCUncheckedCreateNestedManyWithoutNRCInput
  }

  export type NRCCreateOrConnectWithoutUsuarioInput = {
    where: NRCWhereUniqueInput
    create: XOR<NRCCreateWithoutUsuarioInput, NRCUncheckedCreateWithoutUsuarioInput>
  }

  export type NRCCreateManyUsuarioInputEnvelope = {
    data: NRCCreateManyUsuarioInput | NRCCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type RolUsuarioCreateWithoutUsuarioInput = {
    create_at?: Date | string
    deleted?: boolean
    Rol: RolCreateNestedOneWithoutRolUsuarioInput
  }

  export type RolUsuarioUncheckedCreateWithoutUsuarioInput = {
    id_rol: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: RolUsuarioWhereUniqueInput
    create: XOR<RolUsuarioCreateWithoutUsuarioInput, RolUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type RolUsuarioCreateManyUsuarioInputEnvelope = {
    data: RolUsuarioCreateManyUsuarioInput | RolUsuarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EstudianteUpsertWithoutUsuarioInput = {
    update: XOR<EstudianteUpdateWithoutUsuarioInput, EstudianteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutUsuarioInput, EstudianteUncheckedUpdateWithoutUsuarioInput>
  }

  export type EstudianteUpdateWithoutUsuarioInput = {
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Equipo?: EquipoUpdateOneRequiredWithoutEstudianteNestedInput
    EstudianteNRC?: EstudianteNRCUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type JuradoUpsertWithoutUsuarioInput = {
    update: XOR<JuradoUpdateWithoutUsuarioInput, JuradoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<JuradoCreateWithoutUsuarioInput, JuradoUncheckedCreateWithoutUsuarioInput>
    where?: JuradoWhereInput
  }

  export type JuradoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: JuradoWhereInput
    data: XOR<JuradoUpdateWithoutUsuarioInput, JuradoUncheckedUpdateWithoutUsuarioInput>
  }

  export type JuradoUpdateWithoutUsuarioInput = {
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateManyWithoutJuradoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUpdateManyWithoutJuradoNestedInput
  }

  export type JuradoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUncheckedUpdateManyWithoutJuradoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedUpdateManyWithoutJuradoNestedInput
  }

  export type NRCUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NRCWhereUniqueInput
    update: XOR<NRCUpdateWithoutUsuarioInput, NRCUncheckedUpdateWithoutUsuarioInput>
    create: XOR<NRCCreateWithoutUsuarioInput, NRCUncheckedCreateWithoutUsuarioInput>
  }

  export type NRCUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NRCWhereUniqueInput
    data: XOR<NRCUpdateWithoutUsuarioInput, NRCUncheckedUpdateWithoutUsuarioInput>
  }

  export type NRCUpdateManyWithWhereWithoutUsuarioInput = {
    where: NRCScalarWhereInput
    data: XOR<NRCUpdateManyMutationInput, NRCUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type RolUsuarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: RolUsuarioWhereUniqueInput
    update: XOR<RolUsuarioUpdateWithoutUsuarioInput, RolUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<RolUsuarioCreateWithoutUsuarioInput, RolUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type RolUsuarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: RolUsuarioWhereUniqueInput
    data: XOR<RolUsuarioUpdateWithoutUsuarioInput, RolUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type RolUsuarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: RolUsuarioScalarWhereInput
    data: XOR<RolUsuarioUpdateManyMutationInput, RolUsuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EvaluacionCreateWithoutVideojuegoInput = {
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Jurado: JuradoCreateNestedOneWithoutEvaluacionInput
    Rubrica?: RubricaCreateNestedManyWithoutEvaluacionInput
  }

  export type EvaluacionUncheckedCreateWithoutVideojuegoInput = {
    id?: number
    jurado_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Rubrica?: RubricaUncheckedCreateNestedManyWithoutEvaluacionInput
  }

  export type EvaluacionCreateOrConnectWithoutVideojuegoInput = {
    where: EvaluacionWhereUniqueInput
    create: XOR<EvaluacionCreateWithoutVideojuegoInput, EvaluacionUncheckedCreateWithoutVideojuegoInput>
  }

  export type EvaluacionCreateManyVideojuegoInputEnvelope = {
    data: EvaluacionCreateManyVideojuegoInput | EvaluacionCreateManyVideojuegoInput[]
    skipDuplicates?: boolean
  }

  export type EquipoCreateWithoutVideojuegoInput = {
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteCreateNestedManyWithoutEquipoInput
  }

  export type EquipoUncheckedCreateWithoutVideojuegoInput = {
    id?: number
    nombre_equipo: string
    url_logo: string
    estado?: $Enums.Estado
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Estudiante?: EstudianteUncheckedCreateNestedManyWithoutEquipoInput
  }

  export type EquipoCreateOrConnectWithoutVideojuegoInput = {
    where: EquipoWhereUniqueInput
    create: XOR<EquipoCreateWithoutVideojuegoInput, EquipoUncheckedCreateWithoutVideojuegoInput>
  }

  export type VideojuegoAsignadoCreateWithoutVideojuegoInput = {
    create_at?: Date | string
    deleted?: boolean
    Jurado: JuradoCreateNestedOneWithoutVideojuegoAsignadoInput
  }

  export type VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput = {
    id_jurado: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoAsignadoCreateOrConnectWithoutVideojuegoInput = {
    where: VideojuegoAsignadoWhereUniqueInput
    create: XOR<VideojuegoAsignadoCreateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput>
  }

  export type VideojuegoAsignadoCreateManyVideojuegoInputEnvelope = {
    data: VideojuegoAsignadoCreateManyVideojuegoInput | VideojuegoAsignadoCreateManyVideojuegoInput[]
    skipDuplicates?: boolean
  }

  export type EvaluacionUpsertWithWhereUniqueWithoutVideojuegoInput = {
    where: EvaluacionWhereUniqueInput
    update: XOR<EvaluacionUpdateWithoutVideojuegoInput, EvaluacionUncheckedUpdateWithoutVideojuegoInput>
    create: XOR<EvaluacionCreateWithoutVideojuegoInput, EvaluacionUncheckedCreateWithoutVideojuegoInput>
  }

  export type EvaluacionUpdateWithWhereUniqueWithoutVideojuegoInput = {
    where: EvaluacionWhereUniqueInput
    data: XOR<EvaluacionUpdateWithoutVideojuegoInput, EvaluacionUncheckedUpdateWithoutVideojuegoInput>
  }

  export type EvaluacionUpdateManyWithWhereWithoutVideojuegoInput = {
    where: EvaluacionScalarWhereInput
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyWithoutVideojuegoInput>
  }

  export type EquipoUpsertWithoutVideojuegoInput = {
    update: XOR<EquipoUpdateWithoutVideojuegoInput, EquipoUncheckedUpdateWithoutVideojuegoInput>
    create: XOR<EquipoCreateWithoutVideojuegoInput, EquipoUncheckedCreateWithoutVideojuegoInput>
    where?: EquipoWhereInput
  }

  export type EquipoUpdateToOneWithWhereWithoutVideojuegoInput = {
    where?: EquipoWhereInput
    data: XOR<EquipoUpdateWithoutVideojuegoInput, EquipoUncheckedUpdateWithoutVideojuegoInput>
  }

  export type EquipoUpdateWithoutVideojuegoInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateManyWithoutEquipoNestedInput
  }

  export type EquipoUncheckedUpdateWithoutVideojuegoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    url_logo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUncheckedUpdateManyWithoutEquipoNestedInput
  }

  export type VideojuegoAsignadoUpsertWithWhereUniqueWithoutVideojuegoInput = {
    where: VideojuegoAsignadoWhereUniqueInput
    update: XOR<VideojuegoAsignadoUpdateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedUpdateWithoutVideojuegoInput>
    create: XOR<VideojuegoAsignadoCreateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedCreateWithoutVideojuegoInput>
  }

  export type VideojuegoAsignadoUpdateWithWhereUniqueWithoutVideojuegoInput = {
    where: VideojuegoAsignadoWhereUniqueInput
    data: XOR<VideojuegoAsignadoUpdateWithoutVideojuegoInput, VideojuegoAsignadoUncheckedUpdateWithoutVideojuegoInput>
  }

  export type VideojuegoAsignadoUpdateManyWithWhereWithoutVideojuegoInput = {
    where: VideojuegoAsignadoScalarWhereInput
    data: XOR<VideojuegoAsignadoUpdateManyMutationInput, VideojuegoAsignadoUncheckedUpdateManyWithoutVideojuegoInput>
  }

  export type JuradoCreateWithoutVideojuegoAsignadoInput = {
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionCreateNestedManyWithoutJuradoInput
    Usuario: UsuarioCreateNestedOneWithoutJuradoInput
  }

  export type JuradoUncheckedCreateWithoutVideojuegoAsignadoInput = {
    id?: number
    id_user: number
    estado?: $Enums.EstadoJurado
    token_confirmacion: string
    ultima_conexion: Date | string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionUncheckedCreateNestedManyWithoutJuradoInput
  }

  export type JuradoCreateOrConnectWithoutVideojuegoAsignadoInput = {
    where: JuradoWhereUniqueInput
    create: XOR<JuradoCreateWithoutVideojuegoAsignadoInput, JuradoUncheckedCreateWithoutVideojuegoAsignadoInput>
  }

  export type VideojuegoCreateWithoutVideojuegoAsignadoInput = {
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionCreateNestedManyWithoutVideojuegoInput
    Equipo: EquipoCreateNestedOneWithoutVideojuegoInput
  }

  export type VideojuegoUncheckedCreateWithoutVideojuegoAsignadoInput = {
    id?: number
    equipo_id: number
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
    Evaluacion?: EvaluacionUncheckedCreateNestedManyWithoutVideojuegoInput
  }

  export type VideojuegoCreateOrConnectWithoutVideojuegoAsignadoInput = {
    where: VideojuegoWhereUniqueInput
    create: XOR<VideojuegoCreateWithoutVideojuegoAsignadoInput, VideojuegoUncheckedCreateWithoutVideojuegoAsignadoInput>
  }

  export type JuradoUpsertWithoutVideojuegoAsignadoInput = {
    update: XOR<JuradoUpdateWithoutVideojuegoAsignadoInput, JuradoUncheckedUpdateWithoutVideojuegoAsignadoInput>
    create: XOR<JuradoCreateWithoutVideojuegoAsignadoInput, JuradoUncheckedCreateWithoutVideojuegoAsignadoInput>
    where?: JuradoWhereInput
  }

  export type JuradoUpdateToOneWithWhereWithoutVideojuegoAsignadoInput = {
    where?: JuradoWhereInput
    data: XOR<JuradoUpdateWithoutVideojuegoAsignadoInput, JuradoUncheckedUpdateWithoutVideojuegoAsignadoInput>
  }

  export type JuradoUpdateWithoutVideojuegoAsignadoInput = {
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateManyWithoutJuradoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutJuradoNestedInput
  }

  export type JuradoUncheckedUpdateWithoutVideojuegoAsignadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoJuradoFieldUpdateOperationsInput | $Enums.EstadoJurado
    token_confirmacion?: StringFieldUpdateOperationsInput | string
    ultima_conexion?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUncheckedUpdateManyWithoutJuradoNestedInput
  }

  export type VideojuegoUpsertWithoutVideojuegoAsignadoInput = {
    update: XOR<VideojuegoUpdateWithoutVideojuegoAsignadoInput, VideojuegoUncheckedUpdateWithoutVideojuegoAsignadoInput>
    create: XOR<VideojuegoCreateWithoutVideojuegoAsignadoInput, VideojuegoUncheckedCreateWithoutVideojuegoAsignadoInput>
    where?: VideojuegoWhereInput
  }

  export type VideojuegoUpdateToOneWithWhereWithoutVideojuegoAsignadoInput = {
    where?: VideojuegoWhereInput
    data: XOR<VideojuegoUpdateWithoutVideojuegoAsignadoInput, VideojuegoUncheckedUpdateWithoutVideojuegoAsignadoInput>
  }

  export type VideojuegoUpdateWithoutVideojuegoAsignadoInput = {
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateManyWithoutVideojuegoNestedInput
    Equipo?: EquipoUpdateOneRequiredWithoutVideojuegoNestedInput
  }

  export type VideojuegoUncheckedUpdateWithoutVideojuegoAsignadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipo_id?: IntFieldUpdateOperationsInput | number
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUncheckedUpdateManyWithoutVideojuegoNestedInput
  }

  export type RubricaCreateManyCriterioInput = {
    id_evaluacion: number
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RubricaUpdateWithoutCriterioInput = {
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateOneRequiredWithoutRubricaNestedInput
  }

  export type RubricaUncheckedUpdateWithoutCriterioInput = {
    id_evaluacion?: IntFieldUpdateOperationsInput | number
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RubricaUncheckedUpdateManyWithoutCriterioInput = {
    id_evaluacion?: IntFieldUpdateOperationsInput | number
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointCreateManyEndpointInput = {
    id_rol: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolEndpointUpdateWithoutEndpointInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rol?: RolUpdateOneRequiredWithoutRolEndpointNestedInput
  }

  export type RolEndpointUncheckedUpdateWithoutEndpointInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointUncheckedUpdateManyWithoutEndpointInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteCreateManyEquipoInput = {
    id?: number
    id_user: number
    github: string
    confirmado?: boolean
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoCreateManyEquipoInput = {
    id?: number
    nombre_videojuego: string
    descripcion: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteUpdateWithoutEquipoInput = {
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    EstudianteNRC?: EstudianteNRCUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutEquipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateManyWithoutEquipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoUpdateWithoutEquipoInput = {
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUpdateManyWithoutVideojuegoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUpdateManyWithoutVideojuegoNestedInput
  }

  export type VideojuegoUncheckedUpdateWithoutEquipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Evaluacion?: EvaluacionUncheckedUpdateManyWithoutVideojuegoNestedInput
    VideojuegoAsignado?: VideojuegoAsignadoUncheckedUpdateManyWithoutVideojuegoNestedInput
  }

  export type VideojuegoUncheckedUpdateManyWithoutEquipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_videojuego?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCCreateManyEstudianteInput = {
    id_nrc: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteNRCUpdateWithoutEstudianteInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    NRC?: NRCUpdateOneRequiredWithoutEstudianteNRCNestedInput
  }

  export type EstudianteNRCUncheckedUpdateWithoutEstudianteInput = {
    id_nrc?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCUncheckedUpdateManyWithoutEstudianteInput = {
    id_nrc?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RubricaCreateManyEvaluacionInput = {
    id_criterio: number
    valoracion: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RubricaUpdateWithoutEvaluacionInput = {
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Criterio?: CriterioUpdateOneRequiredWithoutRubricaNestedInput
  }

  export type RubricaUncheckedUpdateWithoutEvaluacionInput = {
    id_criterio?: IntFieldUpdateOperationsInput | number
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RubricaUncheckedUpdateManyWithoutEvaluacionInput = {
    id_criterio?: IntFieldUpdateOperationsInput | number
    valoracion?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EvaluacionCreateManyJuradoInput = {
    id?: number
    videojuego_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoAsignadoCreateManyJuradoInput = {
    id_videojuego: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EvaluacionUpdateWithoutJuradoInput = {
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Videojuego?: VideojuegoUpdateOneRequiredWithoutEvaluacionNestedInput
    Rubrica?: RubricaUpdateManyWithoutEvaluacionNestedInput
  }

  export type EvaluacionUncheckedUpdateWithoutJuradoInput = {
    id?: IntFieldUpdateOperationsInput | number
    videojuego_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rubrica?: RubricaUncheckedUpdateManyWithoutEvaluacionNestedInput
  }

  export type EvaluacionUncheckedUpdateManyWithoutJuradoInput = {
    id?: IntFieldUpdateOperationsInput | number
    videojuego_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoUpdateWithoutJuradoInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Videojuego?: VideojuegoUpdateOneRequiredWithoutVideojuegoAsignadoNestedInput
  }

  export type VideojuegoAsignadoUncheckedUpdateWithoutJuradoInput = {
    id_videojuego?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoUncheckedUpdateManyWithoutJuradoInput = {
    id_videojuego?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NRCCreateManyMateriaInput = {
    codigo_nrc?: number
    profesor_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type NRCUpdateWithoutMateriaInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUpdateManyWithoutNRCNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutNRCNestedInput
  }

  export type NRCUncheckedUpdateWithoutMateriaInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    profesor_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUncheckedUpdateManyWithoutNRCNestedInput
  }

  export type NRCUncheckedUpdateManyWithoutMateriaInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    profesor_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCCreateManyNRCInput = {
    id_estudiante: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EstudianteNRCUpdateWithoutNRCInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Estudiante?: EstudianteUpdateOneRequiredWithoutEstudianteNRCNestedInput
  }

  export type EstudianteNRCUncheckedUpdateWithoutNRCInput = {
    id_estudiante?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudianteNRCUncheckedUpdateManyWithoutNRCInput = {
    id_estudiante?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointCreateManyRolInput = {
    id_endpoint: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolUsuarioCreateManyRolInput = {
    id_usuario: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type RolEndpointUpdateWithoutRolInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Endpoint?: EndpointUpdateOneRequiredWithoutRolEndpointNestedInput
  }

  export type RolEndpointUncheckedUpdateWithoutRolInput = {
    id_endpoint?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolEndpointUncheckedUpdateManyWithoutRolInput = {
    id_endpoint?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioUpdateWithoutRolInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneRequiredWithoutRolUsuarioNestedInput
  }

  export type RolUsuarioUncheckedUpdateWithoutRolInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioUncheckedUpdateManyWithoutRolInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NRCCreateManyUsuarioInput = {
    codigo_nrc?: number
    materia_id: number
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type RolUsuarioCreateManyUsuarioInput = {
    id_rol: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type NRCUpdateWithoutUsuarioInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUpdateManyWithoutNRCNestedInput
    Materia?: MateriaUpdateOneRequiredWithoutNRCNestedInput
  }

  export type NRCUncheckedUpdateWithoutUsuarioInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    materia_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    EstudianteNRC?: EstudianteNRCUncheckedUpdateManyWithoutNRCNestedInput
  }

  export type NRCUncheckedUpdateManyWithoutUsuarioInput = {
    codigo_nrc?: IntFieldUpdateOperationsInput | number
    materia_id?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioUpdateWithoutUsuarioInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rol?: RolUpdateOneRequiredWithoutRolUsuarioNestedInput
  }

  export type RolUsuarioUncheckedUpdateWithoutUsuarioInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolUsuarioUncheckedUpdateManyWithoutUsuarioInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EvaluacionCreateManyVideojuegoInput = {
    id?: number
    jurado_id: number
    comentarios: string
    create_at?: Date | string
    update_at?: Date | string
    deleted?: boolean
  }

  export type VideojuegoAsignadoCreateManyVideojuegoInput = {
    id_jurado: number
    create_at?: Date | string
    deleted?: boolean
  }

  export type EvaluacionUpdateWithoutVideojuegoInput = {
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUpdateOneRequiredWithoutEvaluacionNestedInput
    Rubrica?: RubricaUpdateManyWithoutEvaluacionNestedInput
  }

  export type EvaluacionUncheckedUpdateWithoutVideojuegoInput = {
    id?: IntFieldUpdateOperationsInput | number
    jurado_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Rubrica?: RubricaUncheckedUpdateManyWithoutEvaluacionNestedInput
  }

  export type EvaluacionUncheckedUpdateManyWithoutVideojuegoInput = {
    id?: IntFieldUpdateOperationsInput | number
    jurado_id?: IntFieldUpdateOperationsInput | number
    comentarios?: StringFieldUpdateOperationsInput | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoUpdateWithoutVideojuegoInput = {
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Jurado?: JuradoUpdateOneRequiredWithoutVideojuegoAsignadoNestedInput
  }

  export type VideojuegoAsignadoUncheckedUpdateWithoutVideojuegoInput = {
    id_jurado?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VideojuegoAsignadoUncheckedUpdateManyWithoutVideojuegoInput = {
    id_jurado?: IntFieldUpdateOperationsInput | number
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}